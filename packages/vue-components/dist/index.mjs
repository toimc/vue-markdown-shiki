var ti = Object.defineProperty;
var ni = (e, t, n) => t in e ? ti(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var k = (e, t, n) => ni(e, typeof t != "symbol" ? t + "" : t, n);
import { markRaw as kn, createElementBlock as ne, openBlock as Q, createElementVNode as ue, defineComponent as At, ref as ve, computed as tn, renderSlot as Nu, toDisplayString as nn, createVNode as de, createBlock as zn, Fragment as Mt, withCtx as ui, renderList as $n, normalizeClass as un, withDirectives as ri, vShow as ii, toRefs as ai, watch as oi, onBeforeMount as si, inject as li, resolveComponent as ci, h as di, provide as fi, unref as hi } from "vue";
const pi = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&#39;",
  '"': "&quot;"
}, mi = /[&<>'"]/g, we = (e) => e.replace(
  mi,
  (t) => pi[t]
), Iu = (e, { shouldAllowHtml: t, shouldEscapeText: n }) => {
  const u = e.children ?? [], r = ["text", "emoji", "code_inline"];
  return t && r.push("html_inline"), u.filter(
    (a) => {
      var o;
      return r.includes(a.type) && // filter permalink symbol that generated by markdown-it-anchor
      !((o = a.meta) != null && o.isPermalinkSymbol);
    }
  ).reduce((a, o) => n && (o.type === "code_inline" || o.type === "text") ? `${a}${we(o.content)}` : `${a}${o.content}`, "").trim();
}, Mu = (e, {
  level: t,
  shouldAllowHtml: n,
  shouldAllowNested: u,
  shouldEscapeText: r,
  slugify: i,
  format: a
}) => {
  const o = [], s = [], l = (c) => {
    for (; s.length !== 0 && c.level <= s[0].level; )
      s.shift();
    s.length === 0 ? (o.push(c), s.push(c)) : (s[0].children.push(c), s.unshift(c));
  };
  for (let c = 0; c < e.length; c += 1) {
    const d = e[c];
    if (d.type !== "heading_open" || d.level !== 0 && !u)
      continue;
    const f = Number.parseInt(d.tag.slice(1), 10);
    if (!t.includes(f))
      continue;
    const p = e[c + 1];
    /* istanbul ignore if -- @preserve */
    if (!p)
      continue;
    const h = Iu(p, {
      shouldAllowHtml: n,
      shouldEscapeText: r
    }), g = d.attrGet("id") ?? i(h);
    l({
      level: f,
      title: (a == null ? void 0 : a(h)) ?? h,
      slug: g,
      link: `#${g}`,
      children: []
    });
  }
  return o;
}, gi = /[\u0000-\u001f]/g, _i = /[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'â€œâ€â€˜â€™<>,.?/]+/g, bi = /[\u0300-\u036F]/g, lt = (e) => e.normalize("NFKD").replace(bi, "").replace(gi, "").replace(_i, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/^(\d)/, "_$1").toLowerCase(), yi = (e, {
  level: t = [2, 3],
  shouldAllowNested: n = !1,
  slugify: u = lt,
  format: r
} = {}) => {
  const i = e.renderer.render.bind(e.renderer);
  e.renderer.render = (a, o, s) => (s.headers = Mu(a, {
    level: t,
    shouldAllowHtml: !1,
    shouldAllowNested: n,
    shouldEscapeText: !1,
    slugify: u,
    format: r
  }), i(a, o, s));
}, ki = (e) => {
  const t = e.renderer.render.bind(e.renderer);
  e.renderer.render = (n, u, r) => {
    const i = n.findIndex((a) => a.tag === "h1");
    return r.title = i > -1 ? Iu(n[i + 1], {
      shouldAllowHtml: !1,
      shouldEscapeText: !1
    }) : "", t(n, u, r);
  };
}, xi = ({
  listTag: e,
  listClass: t,
  itemClass: n,
  linkTag: u,
  linkClass: r
}) => {
  const i = we(e), a = t ? ` class="${we(t)}"` : "", o = "li", s = n ? ` class="${we(n)}"` : "", l = we(u), c = r ? ` class="${we(r)}"` : "", d = (p) => u === "router-link" ? ` to="${p}"` : ` href="${p}"`, f = (p) => `<${i}${a}>${p.map(
    (h) => `<${o}${s}><${l}${c}${d(h.link)}>${h.title}</${l}>${h.children.length > 0 ? f(h.children) : ""}</${o}>`
  ).join("")}</${i}>`;
  return f;
}, wi = ({
  pattern: e,
  containerTag: t,
  containerClass: n
}) => (u, r, i, a) => {
  if (u.sCount[r] - u.blkIndent >= 4)
    return !1;
  const o = u.bMarks[r] + u.tShift[r], s = u.eMarks[r], l = u.src.slice(o, s).split(" ")[0];
  if (!e.test(l))
    return !1;
  if (a)
    return !0;
  u.line = r + 1;
  const c = u.push("toc_open", t, 1);
  c.markup = "", c.map = [r, u.line], n && c.attrSet("class", n);
  const d = u.push("toc_body", "", 0);
  d.markup = l, d.map = [r, u.line], d.hidden = !0;
  const f = u.push("toc_close", t, -1);
  return f.markup = "", d.map = [r, u.line], !0;
}, Ci = (e, {
  pattern: t = /^\[\[toc\]\]$/i,
  slugify: n = lt,
  format: u,
  level: r = [2, 3],
  shouldAllowNested: i = !1,
  containerTag: a = "nav",
  containerClass: o = "table-of-contents",
  listTag: s = "ul",
  listClass: l = "",
  itemClass: c = "",
  linkTag: d = "a",
  linkClass: f = ""
} = {}) => {
  e.block.ruler.before(
    "heading",
    "toc",
    wi({
      pattern: t,
      containerTag: a,
      containerClass: o
    }),
    {
      alt: ["paragraph", "reference", "blockquote"]
    }
  );
  const p = xi({
    listTag: s,
    listClass: l,
    itemClass: c,
    linkTag: d,
    linkClass: f
  });
  e.renderer.rules.toc_body = (h) => p(
    Mu(h, {
      level: r,
      shouldAllowHtml: !0,
      shouldAllowNested: i,
      shouldEscapeText: !0,
      slugify: n,
      format: u
    })
  );
}, qn = {};
function vi(e) {
  let t = qn[e];
  if (t)
    return t;
  t = qn[e] = [];
  for (let n = 0; n < 128; n++) {
    const u = String.fromCharCode(n);
    t.push(u);
  }
  for (let n = 0; n < e.length; n++) {
    const u = e.charCodeAt(n);
    t[u] = "%" + ("0" + u.toString(16).toUpperCase()).slice(-2);
  }
  return t;
}
function De(e, t) {
  typeof t != "string" && (t = De.defaultChars);
  const n = vi(t);
  return e.replace(/(%[a-f0-9]{2})+/gi, function(u) {
    let r = "";
    for (let i = 0, a = u.length; i < a; i += 3) {
      const o = parseInt(u.slice(i + 1, i + 3), 16);
      if (o < 128) {
        r += n[o];
        continue;
      }
      if ((o & 224) === 192 && i + 3 < a) {
        const s = parseInt(u.slice(i + 4, i + 6), 16);
        if ((s & 192) === 128) {
          const l = o << 6 & 1984 | s & 63;
          l < 128 ? r += "ï¿½ï¿½" : r += String.fromCharCode(l), i += 3;
          continue;
        }
      }
      if ((o & 240) === 224 && i + 6 < a) {
        const s = parseInt(u.slice(i + 4, i + 6), 16), l = parseInt(u.slice(i + 7, i + 9), 16);
        if ((s & 192) === 128 && (l & 192) === 128) {
          const c = o << 12 & 61440 | s << 6 & 4032 | l & 63;
          c < 2048 || c >= 55296 && c <= 57343 ? r += "ï¿½ï¿½ï¿½" : r += String.fromCharCode(c), i += 6;
          continue;
        }
      }
      if ((o & 248) === 240 && i + 9 < a) {
        const s = parseInt(u.slice(i + 4, i + 6), 16), l = parseInt(u.slice(i + 7, i + 9), 16), c = parseInt(u.slice(i + 10, i + 12), 16);
        if ((s & 192) === 128 && (l & 192) === 128 && (c & 192) === 128) {
          let d = o << 18 & 1835008 | s << 12 & 258048 | l << 6 & 4032 | c & 63;
          d < 65536 || d > 1114111 ? r += "ï¿½ï¿½ï¿½ï¿½" : (d -= 65536, r += String.fromCharCode(55296 + (d >> 10), 56320 + (d & 1023))), i += 9;
          continue;
        }
      }
      r += "ï¿½";
    }
    return r;
  });
}
De.defaultChars = ";/?:@&=+$,#";
De.componentChars = "";
const Gn = {};
function Ai(e) {
  let t = Gn[e];
  if (t)
    return t;
  t = Gn[e] = [];
  for (let n = 0; n < 128; n++) {
    const u = String.fromCharCode(n);
    /^[0-9a-z]$/i.test(u) ? t.push(u) : t.push("%" + ("0" + n.toString(16).toUpperCase()).slice(-2));
  }
  for (let n = 0; n < e.length; n++)
    t[e.charCodeAt(n)] = e[n];
  return t;
}
function Je(e, t, n) {
  typeof t != "string" && (n = t, t = Je.defaultChars), typeof n > "u" && (n = !0);
  const u = Ai(t);
  let r = "";
  for (let i = 0, a = e.length; i < a; i++) {
    const o = e.charCodeAt(i);
    if (n && o === 37 && i + 2 < a && /^[0-9a-f]{2}$/i.test(e.slice(i + 1, i + 3))) {
      r += e.slice(i, i + 3), i += 2;
      continue;
    }
    if (o < 128) {
      r += u[o];
      continue;
    }
    if (o >= 55296 && o <= 57343) {
      if (o >= 55296 && o <= 56319 && i + 1 < a) {
        const s = e.charCodeAt(i + 1);
        if (s >= 56320 && s <= 57343) {
          r += encodeURIComponent(e[i] + e[i + 1]), i++;
          continue;
        }
      }
      r += "%EF%BF%BD";
      continue;
    }
    r += encodeURIComponent(e[i]);
  }
  return r;
}
Je.defaultChars = ";/?:@&=+$,-_.!~*'()#";
Je.componentChars = "-_.!~*'()";
function xn(e) {
  let t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
}
function ct() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
const Ei = /^([a-z0-9.+-]+:)/i, Si = /:[0-9]*$/, Di = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, Fi = ["<", ">", '"', "`", " ", "\r", `
`, "	"], Ti = ["{", "}", "|", "\\", "^", "`"].concat(Fi), Ri = ["'"].concat(Ti), Hn = ["%", "/", "?", ";", "#"].concat(Ri), Un = ["/", "?", "#"], Li = 255, Wn = /^[+a-z0-9A-Z_-]{0,63}$/, Pi = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Vn = {
  javascript: !0,
  "javascript:": !0
}, Zn = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function wn(e, t) {
  if (e && e instanceof ct) return e;
  const n = new ct();
  return n.parse(e, t), n;
}
ct.prototype.parse = function(e, t) {
  let n, u, r, i = e;
  if (i = i.trim(), !t && e.split("#").length === 1) {
    const l = Di.exec(i);
    if (l)
      return this.pathname = l[1], l[2] && (this.search = l[2]), this;
  }
  let a = Ei.exec(i);
  if (a && (a = a[0], n = a.toLowerCase(), this.protocol = a, i = i.substr(a.length)), (t || a || i.match(/^\/\/[^@\/]+@[^@\/]+/)) && (r = i.substr(0, 2) === "//", r && !(a && Vn[a]) && (i = i.substr(2), this.slashes = !0)), !Vn[a] && (r || a && !Zn[a])) {
    let l = -1;
    for (let h = 0; h < Un.length; h++)
      u = i.indexOf(Un[h]), u !== -1 && (l === -1 || u < l) && (l = u);
    let c, d;
    l === -1 ? d = i.lastIndexOf("@") : d = i.lastIndexOf("@", l), d !== -1 && (c = i.slice(0, d), i = i.slice(d + 1), this.auth = c), l = -1;
    for (let h = 0; h < Hn.length; h++)
      u = i.indexOf(Hn[h]), u !== -1 && (l === -1 || u < l) && (l = u);
    l === -1 && (l = i.length), i[l - 1] === ":" && l--;
    const f = i.slice(0, l);
    i = i.slice(l), this.parseHost(f), this.hostname = this.hostname || "";
    const p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      const h = this.hostname.split(/\./);
      for (let g = 0, m = h.length; g < m; g++) {
        const b = h[g];
        if (b && !b.match(Wn)) {
          let _ = "";
          for (let y = 0, x = b.length; y < x; y++)
            b.charCodeAt(y) > 127 ? _ += "x" : _ += b[y];
          if (!_.match(Wn)) {
            const y = h.slice(0, g), x = h.slice(g + 1), C = b.match(Pi);
            C && (y.push(C[1]), x.unshift(C[2])), x.length && (i = x.join(".") + i), this.hostname = y.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > Li && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  const o = i.indexOf("#");
  o !== -1 && (this.hash = i.substr(o), i = i.slice(0, o));
  const s = i.indexOf("?");
  return s !== -1 && (this.search = i.substr(s), i = i.slice(0, s)), i && (this.pathname = i), Zn[n] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
ct.prototype.parseHost = function(e) {
  let t = Si.exec(e);
  t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
};
const Ni = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: De,
  encode: Je,
  format: xn,
  parse: wn
}, Symbol.toStringTag, { value: "Module" })), Ou = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Bu = /[\0-\x1F\x7F-\x9F]/, Ii = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/, Cn = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, ju = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/, zu = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, Mi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Any: Ou,
  Cc: Bu,
  Cf: Ii,
  P: Cn,
  S: ju,
  Z: zu
}, Symbol.toStringTag, { value: "Module" })), Oi = new Uint16Array(
  // prettier-ignore
  'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map((e) => e.charCodeAt(0))
), Bi = new Uint16Array(
  // prettier-ignore
  "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map((e) => e.charCodeAt(0))
);
var Ot;
const ji = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), zi = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Ot = String.fromCodePoint) !== null && Ot !== void 0 ? Ot : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function $i(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = ji.get(e)) !== null && t !== void 0 ? t : e;
}
var z;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(z || (z = {}));
const qi = 32;
var pe;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(pe || (pe = {}));
function rn(e) {
  return e >= z.ZERO && e <= z.NINE;
}
function Gi(e) {
  return e >= z.UPPER_A && e <= z.UPPER_F || e >= z.LOWER_A && e <= z.LOWER_F;
}
function Hi(e) {
  return e >= z.UPPER_A && e <= z.UPPER_Z || e >= z.LOWER_A && e <= z.LOWER_Z || rn(e);
}
function Ui(e) {
  return e === z.EQUALS || Hi(e);
}
var O;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(O || (O = {}));
var he;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(he || (he = {}));
class Wi {
  constructor(t, n, u) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = u, this.state = O.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = he.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = O.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case O.EntityStart:
        return t.charCodeAt(n) === z.NUM ? (this.state = O.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = O.NamedEntity, this.stateNamedEntity(t, n));
      case O.NumericStart:
        return this.stateNumericStart(t, n);
      case O.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case O.NumericHex:
        return this.stateNumericHex(t, n);
      case O.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | qi) === z.LOWER_X ? (this.state = O.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = O.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, u, r) {
    if (n !== u) {
      const i = u - n;
      this.result = this.result * Math.pow(r, i) + parseInt(t.substr(n, i), r), this.consumed += i;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const u = n;
    for (; n < t.length; ) {
      const r = t.charCodeAt(n);
      if (rn(r) || Gi(r))
        n += 1;
      else
        return this.addToNumericResult(t, u, n, 16), this.emitNumericEntity(r, 3);
    }
    return this.addToNumericResult(t, u, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const u = n;
    for (; n < t.length; ) {
      const r = t.charCodeAt(n);
      if (rn(r))
        n += 1;
      else
        return this.addToNumericResult(t, u, n, 10), this.emitNumericEntity(r, 2);
    }
    return this.addToNumericResult(t, u, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var u;
    if (this.consumed <= n)
      return (u = this.errors) === null || u === void 0 || u.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === z.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === he.Strict)
      return 0;
    return this.emitCodePoint($i(this.result), this.consumed), this.errors && (t !== z.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: u } = this;
    let r = u[this.treeIndex], i = (r & pe.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const a = t.charCodeAt(n);
      if (this.treeIndex = Vi(u, r, this.treeIndex + Math.max(1, i), a), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === he.Attribute && // We shouldn't have consumed any characters after the entity,
        (i === 0 || // And there should be no invalid characters.
        Ui(a)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (r = u[this.treeIndex], i = (r & pe.VALUE_LENGTH) >> 14, i !== 0) {
        if (a === z.SEMI)
          return this.emitNamedEntityData(this.treeIndex, i, this.consumed + this.excess);
        this.decodeMode !== he.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: u } = this, r = (u[n] & pe.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, r, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, u) {
    const { decodeTree: r } = this;
    return this.emitCodePoint(n === 1 ? r[t] & ~pe.VALUE_LENGTH : r[t + 1], u), n === 3 && this.emitCodePoint(r[t + 2], u), u;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case O.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== he.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case O.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case O.NumericHex:
        return this.emitNumericEntity(0, 3);
      case O.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case O.EntityStart:
        return 0;
    }
  }
}
function $u(e) {
  let t = "";
  const n = new Wi(e, (u) => t += zi(u));
  return function(r, i) {
    let a = 0, o = 0;
    for (; (o = r.indexOf("&", o)) >= 0; ) {
      t += r.slice(a, o), n.startEntity(i);
      const l = n.write(
        r,
        // Skip the "&"
        o + 1
      );
      if (l < 0) {
        a = o + n.end();
        break;
      }
      a = o + l, o = l === 0 ? a + 1 : a;
    }
    const s = t + r.slice(a);
    return t = "", s;
  };
}
function Vi(e, t, n, u) {
  const r = (t & pe.BRANCH_LENGTH) >> 7, i = t & pe.JUMP_TABLE;
  if (r === 0)
    return i !== 0 && u === i ? n : -1;
  if (i) {
    const s = u - i;
    return s < 0 || s >= r ? -1 : e[n + s] - 1;
  }
  let a = n, o = a + r - 1;
  for (; a <= o; ) {
    const s = a + o >>> 1, l = e[s];
    if (l < u)
      a = s + 1;
    else if (l > u)
      o = s - 1;
    else
      return e[s + r];
  }
  return -1;
}
const Zi = $u(Oi);
$u(Bi);
function qu(e, t = he.Legacy) {
  return Zi(e, t);
}
function Ji(e) {
  return Object.prototype.toString.call(e);
}
function vn(e) {
  return Ji(e) === "[object String]";
}
const Ki = Object.prototype.hasOwnProperty;
function Qi(e, t) {
  return Ki.call(e, t);
}
function Et(e) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    if (n) {
      if (typeof n != "object")
        throw new TypeError(n + "must be object");
      Object.keys(n).forEach(function(u) {
        e[u] = n[u];
      });
    }
  }), e;
}
function Gu(e, t, n) {
  return [].concat(e.slice(0, t), n, e.slice(t + 1));
}
function An(e) {
  return !(e >= 55296 && e <= 57343 || e >= 64976 && e <= 65007 || (e & 65535) === 65535 || (e & 65535) === 65534 || e >= 0 && e <= 8 || e === 11 || e >= 14 && e <= 31 || e >= 127 && e <= 159 || e > 1114111);
}
function dt(e) {
  if (e > 65535) {
    e -= 65536;
    const t = 55296 + (e >> 10), n = 56320 + (e & 1023);
    return String.fromCharCode(t, n);
  }
  return String.fromCharCode(e);
}
const Hu = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g, Xi = /&([a-z#][a-z0-9]{1,31});/gi, Yi = new RegExp(Hu.source + "|" + Xi.source, "gi"), ea = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function ta(e, t) {
  if (t.charCodeAt(0) === 35 && ea.test(t)) {
    const u = t[1].toLowerCase() === "x" ? parseInt(t.slice(2), 16) : parseInt(t.slice(1), 10);
    return An(u) ? dt(u) : e;
  }
  const n = qu(e);
  return n !== e ? n : e;
}
function na(e) {
  return e.indexOf("\\") < 0 ? e : e.replace(Hu, "$1");
}
function Fe(e) {
  return e.indexOf("\\") < 0 && e.indexOf("&") < 0 ? e : e.replace(Yi, function(t, n, u) {
    return n || ta(t, u);
  });
}
const ua = /[&<>"]/, ra = /[&<>"]/g, ia = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function aa(e) {
  return ia[e];
}
function me(e) {
  return ua.test(e) ? e.replace(ra, aa) : e;
}
const oa = /[.?*+^$[\]\\(){}|-]/g;
function sa(e) {
  return e.replace(oa, "\\$&");
}
function T(e) {
  switch (e) {
    case 9:
    case 32:
      return !0;
  }
  return !1;
}
function ze(e) {
  if (e >= 8192 && e <= 8202)
    return !0;
  switch (e) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return !0;
  }
  return !1;
}
function $e(e) {
  return Cn.test(e) || ju.test(e);
}
function qe(e) {
  switch (e) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function St(e) {
  return e = e.trim().replace(/\s+/g, " "), "áº".toLowerCase() === "á¹¾" && (e = e.replace(/áº/g, "ÃŸ")), e.toLowerCase().toUpperCase();
}
const la = { mdurl: Ni, ucmicro: Mi }, ca = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayReplaceAt: Gu,
  assign: Et,
  escapeHtml: me,
  escapeRE: sa,
  fromCodePoint: dt,
  has: Qi,
  isMdAsciiPunct: qe,
  isPunctChar: $e,
  isSpace: T,
  isString: vn,
  isValidEntityCode: An,
  isWhiteSpace: ze,
  lib: la,
  normalizeReference: St,
  unescapeAll: Fe,
  unescapeMd: na
}, Symbol.toStringTag, { value: "Module" }));
function da(e, t, n) {
  let u, r, i, a;
  const o = e.posMax, s = e.pos;
  for (e.pos = t + 1, u = 1; e.pos < o; ) {
    if (i = e.src.charCodeAt(e.pos), i === 93 && (u--, u === 0)) {
      r = !0;
      break;
    }
    if (a = e.pos, e.md.inline.skipToken(e), i === 91) {
      if (a === e.pos - 1)
        u++;
      else if (n)
        return e.pos = s, -1;
    }
  }
  let l = -1;
  return r && (l = e.pos), e.pos = s, l;
}
function fa(e, t, n) {
  let u, r = t;
  const i = {
    ok: !1,
    pos: 0,
    str: ""
  };
  if (e.charCodeAt(r) === 60) {
    for (r++; r < n; ) {
      if (u = e.charCodeAt(r), u === 10 || u === 60)
        return i;
      if (u === 62)
        return i.pos = r + 1, i.str = Fe(e.slice(t + 1, r)), i.ok = !0, i;
      if (u === 92 && r + 1 < n) {
        r += 2;
        continue;
      }
      r++;
    }
    return i;
  }
  let a = 0;
  for (; r < n && (u = e.charCodeAt(r), !(u === 32 || u < 32 || u === 127)); ) {
    if (u === 92 && r + 1 < n) {
      if (e.charCodeAt(r + 1) === 32)
        break;
      r += 2;
      continue;
    }
    if (u === 40 && (a++, a > 32))
      return i;
    if (u === 41) {
      if (a === 0)
        break;
      a--;
    }
    r++;
  }
  return t === r || a !== 0 || (i.str = Fe(e.slice(t, r)), i.pos = r, i.ok = !0), i;
}
function ha(e, t, n, u) {
  let r, i = t;
  const a = {
    // if `true`, this is a valid link title
    ok: !1,
    // if `true`, this link can be continued on the next line
    can_continue: !1,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (u)
    a.str = u.str, a.marker = u.marker;
  else {
    if (i >= n)
      return a;
    let o = e.charCodeAt(i);
    if (o !== 34 && o !== 39 && o !== 40)
      return a;
    t++, i++, o === 40 && (o = 41), a.marker = o;
  }
  for (; i < n; ) {
    if (r = e.charCodeAt(i), r === a.marker)
      return a.pos = i + 1, a.str += Fe(e.slice(t, i)), a.ok = !0, a;
    if (r === 40 && a.marker === 41)
      return a;
    r === 92 && i + 1 < n && i++, i++;
  }
  return a.can_continue = !0, a.str += Fe(e.slice(t, i)), a;
}
const pa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLinkDestination: fa,
  parseLinkLabel: da,
  parseLinkTitle: ha
}, Symbol.toStringTag, { value: "Module" })), ae = {};
ae.code_inline = function(e, t, n, u, r) {
  const i = e[t];
  return "<code" + r.renderAttrs(i) + ">" + me(i.content) + "</code>";
};
ae.code_block = function(e, t, n, u, r) {
  const i = e[t];
  return "<pre" + r.renderAttrs(i) + "><code>" + me(e[t].content) + `</code></pre>
`;
};
ae.fence = function(e, t, n, u, r) {
  const i = e[t], a = i.info ? Fe(i.info).trim() : "";
  let o = "", s = "";
  if (a) {
    const c = a.split(/(\s+)/g);
    o = c[0], s = c.slice(2).join("");
  }
  let l;
  if (n.highlight ? l = n.highlight(i.content, o, s) || me(i.content) : l = me(i.content), l.indexOf("<pre") === 0)
    return l + `
`;
  if (a) {
    const c = i.attrIndex("class"), d = i.attrs ? i.attrs.slice() : [];
    c < 0 ? d.push(["class", n.langPrefix + o]) : (d[c] = d[c].slice(), d[c][1] += " " + n.langPrefix + o);
    const f = {
      attrs: d
    };
    return `<pre><code${r.renderAttrs(f)}>${l}</code></pre>
`;
  }
  return `<pre><code${r.renderAttrs(i)}>${l}</code></pre>
`;
};
ae.image = function(e, t, n, u, r) {
  const i = e[t];
  return i.attrs[i.attrIndex("alt")][1] = r.renderInlineAsText(i.children, n, u), r.renderToken(e, t, n);
};
ae.hardbreak = function(e, t, n) {
  return n.xhtmlOut ? `<br />
` : `<br>
`;
};
ae.softbreak = function(e, t, n) {
  return n.breaks ? n.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ae.text = function(e, t) {
  return me(e[t].content);
};
ae.html_block = function(e, t) {
  return e[t].content;
};
ae.html_inline = function(e, t) {
  return e[t].content;
};
function Le() {
  this.rules = Et({}, ae);
}
Le.prototype.renderAttrs = function(t) {
  let n, u, r;
  if (!t.attrs)
    return "";
  for (r = "", n = 0, u = t.attrs.length; n < u; n++)
    r += " " + me(t.attrs[n][0]) + '="' + me(t.attrs[n][1]) + '"';
  return r;
};
Le.prototype.renderToken = function(t, n, u) {
  const r = t[n];
  let i = "";
  if (r.hidden)
    return "";
  r.block && r.nesting !== -1 && n && t[n - 1].hidden && (i += `
`), i += (r.nesting === -1 ? "</" : "<") + r.tag, i += this.renderAttrs(r), r.nesting === 0 && u.xhtmlOut && (i += " /");
  let a = !1;
  if (r.block && (a = !0, r.nesting === 1 && n + 1 < t.length)) {
    const o = t[n + 1];
    (o.type === "inline" || o.hidden || o.nesting === -1 && o.tag === r.tag) && (a = !1);
  }
  return i += a ? `>
` : ">", i;
};
Le.prototype.renderInline = function(e, t, n) {
  let u = "";
  const r = this.rules;
  for (let i = 0, a = e.length; i < a; i++) {
    const o = e[i].type;
    typeof r[o] < "u" ? u += r[o](e, i, t, n, this) : u += this.renderToken(e, i, t);
  }
  return u;
};
Le.prototype.renderInlineAsText = function(e, t, n) {
  let u = "";
  for (let r = 0, i = e.length; r < i; r++)
    switch (e[r].type) {
      case "text":
        u += e[r].content;
        break;
      case "image":
        u += this.renderInlineAsText(e[r].children, t, n);
        break;
      case "html_inline":
      case "html_block":
        u += e[r].content;
        break;
      case "softbreak":
      case "hardbreak":
        u += `
`;
        break;
    }
  return u;
};
Le.prototype.render = function(e, t, n) {
  let u = "";
  const r = this.rules;
  for (let i = 0, a = e.length; i < a; i++) {
    const o = e[i].type;
    o === "inline" ? u += this.renderInline(e[i].children, t, n) : typeof r[o] < "u" ? u += r[o](e, i, t, n, this) : u += this.renderToken(e, i, t, n);
  }
  return u;
};
function H() {
  this.__rules__ = [], this.__cache__ = null;
}
H.prototype.__find__ = function(e) {
  for (let t = 0; t < this.__rules__.length; t++)
    if (this.__rules__[t].name === e)
      return t;
  return -1;
};
H.prototype.__compile__ = function() {
  const e = this, t = [""];
  e.__rules__.forEach(function(n) {
    n.enabled && n.alt.forEach(function(u) {
      t.indexOf(u) < 0 && t.push(u);
    });
  }), e.__cache__ = {}, t.forEach(function(n) {
    e.__cache__[n] = [], e.__rules__.forEach(function(u) {
      u.enabled && (n && u.alt.indexOf(n) < 0 || e.__cache__[n].push(u.fn));
    });
  });
};
H.prototype.at = function(e, t, n) {
  const u = this.__find__(e), r = n || {};
  if (u === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__[u].fn = t, this.__rules__[u].alt = r.alt || [], this.__cache__ = null;
};
H.prototype.before = function(e, t, n, u) {
  const r = this.__find__(e), i = u || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__.splice(r, 0, {
    name: t,
    enabled: !0,
    fn: n,
    alt: i.alt || []
  }), this.__cache__ = null;
};
H.prototype.after = function(e, t, n, u) {
  const r = this.__find__(e), i = u || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + e);
  this.__rules__.splice(r + 1, 0, {
    name: t,
    enabled: !0,
    fn: n,
    alt: i.alt || []
  }), this.__cache__ = null;
};
H.prototype.push = function(e, t, n) {
  const u = n || {};
  this.__rules__.push({
    name: e,
    enabled: !0,
    fn: t,
    alt: u.alt || []
  }), this.__cache__ = null;
};
H.prototype.enable = function(e, t) {
  Array.isArray(e) || (e = [e]);
  const n = [];
  return e.forEach(function(u) {
    const r = this.__find__(u);
    if (r < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + u);
    }
    this.__rules__[r].enabled = !0, n.push(u);
  }, this), this.__cache__ = null, n;
};
H.prototype.enableOnly = function(e, t) {
  Array.isArray(e) || (e = [e]), this.__rules__.forEach(function(n) {
    n.enabled = !1;
  }), this.enable(e, t);
};
H.prototype.disable = function(e, t) {
  Array.isArray(e) || (e = [e]);
  const n = [];
  return e.forEach(function(u) {
    const r = this.__find__(u);
    if (r < 0) {
      if (t)
        return;
      throw new Error("Rules manager: invalid rule name " + u);
    }
    this.__rules__[r].enabled = !1, n.push(u);
  }, this), this.__cache__ = null, n;
};
H.prototype.getRules = function(e) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[e] || [];
};
function Y(e, t, n) {
  this.type = e, this.tag = t, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
Y.prototype.attrIndex = function(t) {
  if (!this.attrs)
    return -1;
  const n = this.attrs;
  for (let u = 0, r = n.length; u < r; u++)
    if (n[u][0] === t)
      return u;
  return -1;
};
Y.prototype.attrPush = function(t) {
  this.attrs ? this.attrs.push(t) : this.attrs = [t];
};
Y.prototype.attrSet = function(t, n) {
  const u = this.attrIndex(t), r = [t, n];
  u < 0 ? this.attrPush(r) : this.attrs[u] = r;
};
Y.prototype.attrGet = function(t) {
  const n = this.attrIndex(t);
  let u = null;
  return n >= 0 && (u = this.attrs[n][1]), u;
};
Y.prototype.attrJoin = function(t, n) {
  const u = this.attrIndex(t);
  u < 0 ? this.attrPush([t, n]) : this.attrs[u][1] = this.attrs[u][1] + " " + n;
};
function Uu(e, t, n) {
  this.src = e, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = t;
}
Uu.prototype.Token = Y;
const ma = /\r\n?|\n/g, ga = /\0/g;
function _a(e) {
  let t;
  t = e.src.replace(ma, `
`), t = t.replace(ga, "ï¿½"), e.src = t;
}
function ba(e) {
  let t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}
function ya(e) {
  const t = e.tokens;
  for (let n = 0, u = t.length; n < u; n++) {
    const r = t[n];
    r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
  }
}
function ka(e) {
  return /^<a[>\s]/i.test(e);
}
function xa(e) {
  return /^<\/a\s*>/i.test(e);
}
function wa(e) {
  const t = e.tokens;
  if (e.md.options.linkify)
    for (let n = 0, u = t.length; n < u; n++) {
      if (t[n].type !== "inline" || !e.md.linkify.pretest(t[n].content))
        continue;
      let r = t[n].children, i = 0;
      for (let a = r.length - 1; a >= 0; a--) {
        const o = r[a];
        if (o.type === "link_close") {
          for (a--; r[a].level !== o.level && r[a].type !== "link_open"; )
            a--;
          continue;
        }
        if (o.type === "html_inline" && (ka(o.content) && i > 0 && i--, xa(o.content) && i++), !(i > 0) && o.type === "text" && e.md.linkify.test(o.content)) {
          const s = o.content;
          let l = e.md.linkify.match(s);
          const c = [];
          let d = o.level, f = 0;
          l.length > 0 && l[0].index === 0 && a > 0 && r[a - 1].type === "text_special" && (l = l.slice(1));
          for (let p = 0; p < l.length; p++) {
            const h = l[p].url, g = e.md.normalizeLink(h);
            if (!e.md.validateLink(g))
              continue;
            let m = l[p].text;
            l[p].schema ? l[p].schema === "mailto:" && !/^mailto:/i.test(m) ? m = e.md.normalizeLinkText("mailto:" + m).replace(/^mailto:/, "") : m = e.md.normalizeLinkText(m) : m = e.md.normalizeLinkText("http://" + m).replace(/^http:\/\//, "");
            const b = l[p].index;
            if (b > f) {
              const C = new e.Token("text", "", 0);
              C.content = s.slice(f, b), C.level = d, c.push(C);
            }
            const _ = new e.Token("link_open", "a", 1);
            _.attrs = [["href", g]], _.level = d++, _.markup = "linkify", _.info = "auto", c.push(_);
            const y = new e.Token("text", "", 0);
            y.content = m, y.level = d, c.push(y);
            const x = new e.Token("link_close", "a", -1);
            x.level = --d, x.markup = "linkify", x.info = "auto", c.push(x), f = l[p].lastIndex;
          }
          if (f < s.length) {
            const p = new e.Token("text", "", 0);
            p.content = s.slice(f), p.level = d, c.push(p);
          }
          t[n].children = r = Gu(r, a, c);
        }
      }
    }
}
const Wu = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, Ca = /\((c|tm|r)\)/i, va = /\((c|tm|r)\)/ig, Aa = {
  c: "Â©",
  r: "Â®",
  tm: "â„¢"
};
function Ea(e, t) {
  return Aa[t.toLowerCase()];
}
function Sa(e) {
  let t = 0;
  for (let n = e.length - 1; n >= 0; n--) {
    const u = e[n];
    u.type === "text" && !t && (u.content = u.content.replace(va, Ea)), u.type === "link_open" && u.info === "auto" && t--, u.type === "link_close" && u.info === "auto" && t++;
  }
}
function Da(e) {
  let t = 0;
  for (let n = e.length - 1; n >= 0; n--) {
    const u = e[n];
    u.type === "text" && !t && Wu.test(u.content) && (u.content = u.content.replace(/\+-/g, "Â±").replace(/\.{2,}/g, "â€¦").replace(/([?!])â€¦/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1â€”").replace(/(^|\s)--(?=\s|$)/mg, "$1â€“").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1â€“")), u.type === "link_open" && u.info === "auto" && t--, u.type === "link_close" && u.info === "auto" && t++;
  }
}
function Fa(e) {
  let t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (Ca.test(e.tokens[t].content) && Sa(e.tokens[t].children), Wu.test(e.tokens[t].content) && Da(e.tokens[t].children));
}
const Ta = /['"]/, Jn = /['"]/g, Kn = "â€™";
function tt(e, t, n) {
  return e.slice(0, t) + n + e.slice(t + 1);
}
function Ra(e, t) {
  let n;
  const u = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r], a = e[r].level;
    for (n = u.length - 1; n >= 0 && !(u[n].level <= a); n--)
      ;
    if (u.length = n + 1, i.type !== "text")
      continue;
    let o = i.content, s = 0, l = o.length;
    e:
      for (; s < l; ) {
        Jn.lastIndex = s;
        const c = Jn.exec(o);
        if (!c)
          break;
        let d = !0, f = !0;
        s = c.index + 1;
        const p = c[0] === "'";
        let h = 32;
        if (c.index - 1 >= 0)
          h = o.charCodeAt(c.index - 1);
        else
          for (n = r - 1; n >= 0 && !(e[n].type === "softbreak" || e[n].type === "hardbreak"); n--)
            if (e[n].content) {
              h = e[n].content.charCodeAt(e[n].content.length - 1);
              break;
            }
        let g = 32;
        if (s < l)
          g = o.charCodeAt(s);
        else
          for (n = r + 1; n < e.length && !(e[n].type === "softbreak" || e[n].type === "hardbreak"); n++)
            if (e[n].content) {
              g = e[n].content.charCodeAt(0);
              break;
            }
        const m = qe(h) || $e(String.fromCharCode(h)), b = qe(g) || $e(String.fromCharCode(g)), _ = ze(h), y = ze(g);
        if (y ? d = !1 : b && (_ || m || (d = !1)), _ ? f = !1 : m && (y || b || (f = !1)), g === 34 && c[0] === '"' && h >= 48 && h <= 57 && (f = d = !1), d && f && (d = m, f = b), !d && !f) {
          p && (i.content = tt(i.content, c.index, Kn));
          continue;
        }
        if (f)
          for (n = u.length - 1; n >= 0; n--) {
            let x = u[n];
            if (u[n].level < a)
              break;
            if (x.single === p && u[n].level === a) {
              x = u[n];
              let C, v;
              p ? (C = t.md.options.quotes[2], v = t.md.options.quotes[3]) : (C = t.md.options.quotes[0], v = t.md.options.quotes[1]), i.content = tt(i.content, c.index, v), e[x.token].content = tt(
                e[x.token].content,
                x.pos,
                C
              ), s += v.length - 1, x.token === r && (s += C.length - 1), o = i.content, l = o.length, u.length = n;
              continue e;
            }
          }
        d ? u.push({
          token: r,
          pos: c.index,
          single: p,
          level: a
        }) : f && p && (i.content = tt(i.content, c.index, Kn));
      }
  }
}
function La(e) {
  if (e.md.options.typographer)
    for (let t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !Ta.test(e.tokens[t].content) || Ra(e.tokens[t].children, e);
}
function Pa(e) {
  let t, n;
  const u = e.tokens, r = u.length;
  for (let i = 0; i < r; i++) {
    if (u[i].type !== "inline") continue;
    const a = u[i].children, o = a.length;
    for (t = 0; t < o; t++)
      a[t].type === "text_special" && (a[t].type = "text");
    for (t = n = 0; t < o; t++)
      a[t].type === "text" && t + 1 < o && a[t + 1].type === "text" ? a[t + 1].content = a[t].content + a[t + 1].content : (t !== n && (a[n] = a[t]), n++);
    t !== n && (a.length = n);
  }
}
const Bt = [
  ["normalize", _a],
  ["block", ba],
  ["inline", ya],
  ["linkify", wa],
  ["replacements", Fa],
  ["smartquotes", La],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", Pa]
];
function En() {
  this.ruler = new H();
  for (let e = 0; e < Bt.length; e++)
    this.ruler.push(Bt[e][0], Bt[e][1]);
}
En.prototype.process = function(e) {
  const t = this.ruler.getRules("");
  for (let n = 0, u = t.length; n < u; n++)
    t[n](e);
};
En.prototype.State = Uu;
function oe(e, t, n, u) {
  this.src = e, this.md = t, this.env = n, this.tokens = u, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0;
  const r = this.src;
  for (let i = 0, a = 0, o = 0, s = 0, l = r.length, c = !1; a < l; a++) {
    const d = r.charCodeAt(a);
    if (!c)
      if (T(d)) {
        o++, d === 9 ? s += 4 - s % 4 : s++;
        continue;
      } else
        c = !0;
    (d === 10 || a === l - 1) && (d !== 10 && a++, this.bMarks.push(i), this.eMarks.push(a), this.tShift.push(o), this.sCount.push(s), this.bsCount.push(0), c = !1, o = 0, s = 0, i = a + 1);
  }
  this.bMarks.push(r.length), this.eMarks.push(r.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
oe.prototype.push = function(e, t, n) {
  const u = new Y(e, t, n);
  return u.block = !0, n < 0 && this.level--, u.level = this.level, n > 0 && this.level++, this.tokens.push(u), u;
};
oe.prototype.isEmpty = function(t) {
  return this.bMarks[t] + this.tShift[t] >= this.eMarks[t];
};
oe.prototype.skipEmptyLines = function(t) {
  for (let n = this.lineMax; t < n && !(this.bMarks[t] + this.tShift[t] < this.eMarks[t]); t++)
    ;
  return t;
};
oe.prototype.skipSpaces = function(t) {
  for (let n = this.src.length; t < n; t++) {
    const u = this.src.charCodeAt(t);
    if (!T(u))
      break;
  }
  return t;
};
oe.prototype.skipSpacesBack = function(t, n) {
  if (t <= n)
    return t;
  for (; t > n; )
    if (!T(this.src.charCodeAt(--t)))
      return t + 1;
  return t;
};
oe.prototype.skipChars = function(t, n) {
  for (let u = this.src.length; t < u && this.src.charCodeAt(t) === n; t++)
    ;
  return t;
};
oe.prototype.skipCharsBack = function(t, n, u) {
  if (t <= u)
    return t;
  for (; t > u; )
    if (n !== this.src.charCodeAt(--t))
      return t + 1;
  return t;
};
oe.prototype.getLines = function(t, n, u, r) {
  if (t >= n)
    return "";
  const i = new Array(n - t);
  for (let a = 0, o = t; o < n; o++, a++) {
    let s = 0;
    const l = this.bMarks[o];
    let c = l, d;
    for (o + 1 < n || r ? d = this.eMarks[o] + 1 : d = this.eMarks[o]; c < d && s < u; ) {
      const f = this.src.charCodeAt(c);
      if (T(f))
        f === 9 ? s += 4 - (s + this.bsCount[o]) % 4 : s++;
      else if (c - l < this.tShift[o])
        s++;
      else
        break;
      c++;
    }
    s > u ? i[a] = new Array(s - u + 1).join(" ") + this.src.slice(c, d) : i[a] = this.src.slice(c, d);
  }
  return i.join("");
};
oe.prototype.Token = Y;
const Na = 65536;
function jt(e, t) {
  const n = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  return e.src.slice(n, u);
}
function Qn(e) {
  const t = [], n = e.length;
  let u = 0, r = e.charCodeAt(u), i = !1, a = 0, o = "";
  for (; u < n; )
    r === 124 && (i ? (o += e.substring(a, u - 1), a = u) : (t.push(o + e.substring(a, u)), o = "", a = u + 1)), i = r === 92, u++, r = e.charCodeAt(u);
  return t.push(o + e.substring(a)), t;
}
function Ia(e, t, n, u) {
  if (t + 2 > n)
    return !1;
  let r = t + 1;
  if (e.sCount[r] < e.blkIndent || e.sCount[r] - e.blkIndent >= 4)
    return !1;
  let i = e.bMarks[r] + e.tShift[r];
  if (i >= e.eMarks[r])
    return !1;
  const a = e.src.charCodeAt(i++);
  if (a !== 124 && a !== 45 && a !== 58 || i >= e.eMarks[r])
    return !1;
  const o = e.src.charCodeAt(i++);
  if (o !== 124 && o !== 45 && o !== 58 && !T(o) || a === 45 && T(o))
    return !1;
  for (; i < e.eMarks[r]; ) {
    const x = e.src.charCodeAt(i);
    if (x !== 124 && x !== 45 && x !== 58 && !T(x))
      return !1;
    i++;
  }
  let s = jt(e, t + 1), l = s.split("|");
  const c = [];
  for (let x = 0; x < l.length; x++) {
    const C = l[x].trim();
    if (!C) {
      if (x === 0 || x === l.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(C))
      return !1;
    C.charCodeAt(C.length - 1) === 58 ? c.push(C.charCodeAt(0) === 58 ? "center" : "right") : C.charCodeAt(0) === 58 ? c.push("left") : c.push("");
  }
  if (s = jt(e, t).trim(), s.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4)
    return !1;
  l = Qn(s), l.length && l[0] === "" && l.shift(), l.length && l[l.length - 1] === "" && l.pop();
  const d = l.length;
  if (d === 0 || d !== c.length)
    return !1;
  if (u)
    return !0;
  const f = e.parentType;
  e.parentType = "table";
  const p = e.md.block.ruler.getRules("blockquote"), h = e.push("table_open", "table", 1), g = [t, 0];
  h.map = g;
  const m = e.push("thead_open", "thead", 1);
  m.map = [t, t + 1];
  const b = e.push("tr_open", "tr", 1);
  b.map = [t, t + 1];
  for (let x = 0; x < l.length; x++) {
    const C = e.push("th_open", "th", 1);
    c[x] && (C.attrs = [["style", "text-align:" + c[x]]]);
    const v = e.push("inline", "", 0);
    v.content = l[x].trim(), v.children = [], e.push("th_close", "th", -1);
  }
  e.push("tr_close", "tr", -1), e.push("thead_close", "thead", -1);
  let _, y = 0;
  for (r = t + 2; r < n && !(e.sCount[r] < e.blkIndent); r++) {
    let x = !1;
    for (let v = 0, A = p.length; v < A; v++)
      if (p[v](e, r, n, !0)) {
        x = !0;
        break;
      }
    if (x || (s = jt(e, r).trim(), !s) || e.sCount[r] - e.blkIndent >= 4 || (l = Qn(s), l.length && l[0] === "" && l.shift(), l.length && l[l.length - 1] === "" && l.pop(), y += d - l.length, y > Na))
      break;
    if (r === t + 2) {
      const v = e.push("tbody_open", "tbody", 1);
      v.map = _ = [t + 2, 0];
    }
    const C = e.push("tr_open", "tr", 1);
    C.map = [r, r + 1];
    for (let v = 0; v < d; v++) {
      const A = e.push("td_open", "td", 1);
      c[v] && (A.attrs = [["style", "text-align:" + c[v]]]);
      const S = e.push("inline", "", 0);
      S.content = l[v] ? l[v].trim() : "", S.children = [], e.push("td_close", "td", -1);
    }
    e.push("tr_close", "tr", -1);
  }
  return _ && (e.push("tbody_close", "tbody", -1), _[1] = r), e.push("table_close", "table", -1), g[1] = r, e.parentType = f, e.line = r, !0;
}
function Ma(e, t, n) {
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  let u = t + 1, r = u;
  for (; u < n; ) {
    if (e.isEmpty(u)) {
      u++;
      continue;
    }
    if (e.sCount[u] - e.blkIndent >= 4) {
      u++, r = u;
      continue;
    }
    break;
  }
  e.line = r;
  const i = e.push("code_block", "code", 0);
  return i.content = e.getLines(t, r, 4 + e.blkIndent, !1) + `
`, i.map = [t, e.line], !0;
}
function Oa(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || r + 3 > i)
    return !1;
  const a = e.src.charCodeAt(r);
  if (a !== 126 && a !== 96)
    return !1;
  let o = r;
  r = e.skipChars(r, a);
  let s = r - o;
  if (s < 3)
    return !1;
  const l = e.src.slice(o, r), c = e.src.slice(r, i);
  if (a === 96 && c.indexOf(String.fromCharCode(a)) >= 0)
    return !1;
  if (u)
    return !0;
  let d = t, f = !1;
  for (; d++, !(d >= n || (r = o = e.bMarks[d] + e.tShift[d], i = e.eMarks[d], r < i && e.sCount[d] < e.blkIndent)); )
    if (e.src.charCodeAt(r) === a && !(e.sCount[d] - e.blkIndent >= 4) && (r = e.skipChars(r, a), !(r - o < s) && (r = e.skipSpaces(r), !(r < i)))) {
      f = !0;
      break;
    }
  s = e.sCount[t], e.line = d + (f ? 1 : 0);
  const p = e.push("fence", "code", 0);
  return p.info = c, p.content = e.getLines(t + 1, d, s, !0), p.markup = l, p.map = [t, e.line], !0;
}
function Ba(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t];
  const a = e.lineMax;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(r) !== 62)
    return !1;
  if (u)
    return !0;
  const o = [], s = [], l = [], c = [], d = e.md.block.ruler.getRules("blockquote"), f = e.parentType;
  e.parentType = "blockquote";
  let p = !1, h;
  for (h = t; h < n; h++) {
    const y = e.sCount[h] < e.blkIndent;
    if (r = e.bMarks[h] + e.tShift[h], i = e.eMarks[h], r >= i)
      break;
    if (e.src.charCodeAt(r++) === 62 && !y) {
      let C = e.sCount[h] + 1, v, A;
      e.src.charCodeAt(r) === 32 ? (r++, C++, A = !1, v = !0) : e.src.charCodeAt(r) === 9 ? (v = !0, (e.bsCount[h] + C) % 4 === 3 ? (r++, C++, A = !1) : A = !0) : v = !1;
      let S = C;
      for (o.push(e.bMarks[h]), e.bMarks[h] = r; r < i; ) {
        const L = e.src.charCodeAt(r);
        if (T(L))
          L === 9 ? S += 4 - (S + e.bsCount[h] + (A ? 1 : 0)) % 4 : S++;
        else
          break;
        r++;
      }
      p = r >= i, s.push(e.bsCount[h]), e.bsCount[h] = e.sCount[h] + 1 + (v ? 1 : 0), l.push(e.sCount[h]), e.sCount[h] = S - C, c.push(e.tShift[h]), e.tShift[h] = r - e.bMarks[h];
      continue;
    }
    if (p)
      break;
    let x = !1;
    for (let C = 0, v = d.length; C < v; C++)
      if (d[C](e, h, n, !0)) {
        x = !0;
        break;
      }
    if (x) {
      e.lineMax = h, e.blkIndent !== 0 && (o.push(e.bMarks[h]), s.push(e.bsCount[h]), c.push(e.tShift[h]), l.push(e.sCount[h]), e.sCount[h] -= e.blkIndent);
      break;
    }
    o.push(e.bMarks[h]), s.push(e.bsCount[h]), c.push(e.tShift[h]), l.push(e.sCount[h]), e.sCount[h] = -1;
  }
  const g = e.blkIndent;
  e.blkIndent = 0;
  const m = e.push("blockquote_open", "blockquote", 1);
  m.markup = ">";
  const b = [t, 0];
  m.map = b, e.md.block.tokenize(e, t, h);
  const _ = e.push("blockquote_close", "blockquote", -1);
  _.markup = ">", e.lineMax = a, e.parentType = f, b[1] = e.line;
  for (let y = 0; y < c.length; y++)
    e.bMarks[y + t] = o[y], e.tShift[y + t] = c[y], e.sCount[y + t] = l[y], e.bsCount[y + t] = s[y];
  return e.blkIndent = g, !0;
}
function ja(e, t, n, u) {
  const r = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  let i = e.bMarks[t] + e.tShift[t];
  const a = e.src.charCodeAt(i++);
  if (a !== 42 && a !== 45 && a !== 95)
    return !1;
  let o = 1;
  for (; i < r; ) {
    const l = e.src.charCodeAt(i++);
    if (l !== a && !T(l))
      return !1;
    l === a && o++;
  }
  if (o < 3)
    return !1;
  if (u)
    return !0;
  e.line = t + 1;
  const s = e.push("hr", "hr", 0);
  return s.map = [t, e.line], s.markup = Array(o + 1).join(String.fromCharCode(a)), !0;
}
function Xn(e, t) {
  const n = e.eMarks[t];
  let u = e.bMarks[t] + e.tShift[t];
  const r = e.src.charCodeAt(u++);
  if (r !== 42 && r !== 45 && r !== 43)
    return -1;
  if (u < n) {
    const i = e.src.charCodeAt(u);
    if (!T(i))
      return -1;
  }
  return u;
}
function Yn(e, t) {
  const n = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  let r = n;
  if (r + 1 >= u)
    return -1;
  let i = e.src.charCodeAt(r++);
  if (i < 48 || i > 57)
    return -1;
  for (; ; ) {
    if (r >= u)
      return -1;
    if (i = e.src.charCodeAt(r++), i >= 48 && i <= 57) {
      if (r - n >= 10)
        return -1;
      continue;
    }
    if (i === 41 || i === 46)
      break;
    return -1;
  }
  return r < u && (i = e.src.charCodeAt(r), !T(i)) ? -1 : r;
}
function za(e, t) {
  const n = e.level + 2;
  for (let u = t + 2, r = e.tokens.length - 2; u < r; u++)
    e.tokens[u].level === n && e.tokens[u].type === "paragraph_open" && (e.tokens[u + 2].hidden = !0, e.tokens[u].hidden = !0, u += 2);
}
function $a(e, t, n, u) {
  let r, i, a, o, s = t, l = !0;
  if (e.sCount[s] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[s] - e.listIndent >= 4 && e.sCount[s] < e.blkIndent)
    return !1;
  let c = !1;
  u && e.parentType === "paragraph" && e.sCount[s] >= e.blkIndent && (c = !0);
  let d, f, p;
  if ((p = Yn(e, s)) >= 0) {
    if (d = !0, a = e.bMarks[s] + e.tShift[s], f = Number(e.src.slice(a, p - 1)), c && f !== 1) return !1;
  } else if ((p = Xn(e, s)) >= 0)
    d = !1;
  else
    return !1;
  if (c && e.skipSpaces(p) >= e.eMarks[s])
    return !1;
  if (u)
    return !0;
  const h = e.src.charCodeAt(p - 1), g = e.tokens.length;
  d ? (o = e.push("ordered_list_open", "ol", 1), f !== 1 && (o.attrs = [["start", f]])) : o = e.push("bullet_list_open", "ul", 1);
  const m = [s, 0];
  o.map = m, o.markup = String.fromCharCode(h);
  let b = !1;
  const _ = e.md.block.ruler.getRules("list"), y = e.parentType;
  for (e.parentType = "list"; s < n; ) {
    i = p, r = e.eMarks[s];
    const x = e.sCount[s] + p - (e.bMarks[s] + e.tShift[s]);
    let C = x;
    for (; i < r; ) {
      const G = e.src.charCodeAt(i);
      if (G === 9)
        C += 4 - (C + e.bsCount[s]) % 4;
      else if (G === 32)
        C++;
      else
        break;
      i++;
    }
    const v = i;
    let A;
    v >= r ? A = 1 : A = C - x, A > 4 && (A = 1);
    const S = x + A;
    o = e.push("list_item_open", "li", 1), o.markup = String.fromCharCode(h);
    const L = [s, 0];
    o.map = L, d && (o.info = e.src.slice(a, p - 1));
    const M = e.tight, Z = e.tShift[s], P = e.sCount[s], $ = e.listIndent;
    if (e.listIndent = e.blkIndent, e.blkIndent = S, e.tight = !0, e.tShift[s] = v - e.bMarks[s], e.sCount[s] = C, v >= r && e.isEmpty(s + 1) ? e.line = Math.min(e.line + 2, n) : e.md.block.tokenize(e, s, n, !0), (!e.tight || b) && (l = !1), b = e.line - s > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = $, e.tShift[s] = Z, e.sCount[s] = P, e.tight = M, o = e.push("list_item_close", "li", -1), o.markup = String.fromCharCode(h), s = e.line, L[1] = s, s >= n || e.sCount[s] < e.blkIndent || e.sCount[s] - e.blkIndent >= 4)
      break;
    let D = !1;
    for (let G = 0, Ie = _.length; G < Ie; G++)
      if (_[G](e, s, n, !0)) {
        D = !0;
        break;
      }
    if (D)
      break;
    if (d) {
      if (p = Yn(e, s), p < 0)
        break;
      a = e.bMarks[s] + e.tShift[s];
    } else if (p = Xn(e, s), p < 0)
      break;
    if (h !== e.src.charCodeAt(p - 1))
      break;
  }
  return d ? o = e.push("ordered_list_close", "ol", -1) : o = e.push("bullet_list_close", "ul", -1), o.markup = String.fromCharCode(h), m[1] = s, e.line = s, e.parentType = y, l && za(e, g), !0;
}
function qa(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t], a = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(r) !== 91)
    return !1;
  function o(_) {
    const y = e.lineMax;
    if (_ >= y || e.isEmpty(_))
      return null;
    let x = !1;
    if (e.sCount[_] - e.blkIndent > 3 && (x = !0), e.sCount[_] < 0 && (x = !0), !x) {
      const A = e.md.block.ruler.getRules("reference"), S = e.parentType;
      e.parentType = "reference";
      let L = !1;
      for (let M = 0, Z = A.length; M < Z; M++)
        if (A[M](e, _, y, !0)) {
          L = !0;
          break;
        }
      if (e.parentType = S, L)
        return null;
    }
    const C = e.bMarks[_] + e.tShift[_], v = e.eMarks[_];
    return e.src.slice(C, v + 1);
  }
  let s = e.src.slice(r, i + 1);
  i = s.length;
  let l = -1;
  for (r = 1; r < i; r++) {
    const _ = s.charCodeAt(r);
    if (_ === 91)
      return !1;
    if (_ === 93) {
      l = r;
      break;
    } else if (_ === 10) {
      const y = o(a);
      y !== null && (s += y, i = s.length, a++);
    } else if (_ === 92 && (r++, r < i && s.charCodeAt(r) === 10)) {
      const y = o(a);
      y !== null && (s += y, i = s.length, a++);
    }
  }
  if (l < 0 || s.charCodeAt(l + 1) !== 58)
    return !1;
  for (r = l + 2; r < i; r++) {
    const _ = s.charCodeAt(r);
    if (_ === 10) {
      const y = o(a);
      y !== null && (s += y, i = s.length, a++);
    } else if (!T(_)) break;
  }
  const c = e.md.helpers.parseLinkDestination(s, r, i);
  if (!c.ok)
    return !1;
  const d = e.md.normalizeLink(c.str);
  if (!e.md.validateLink(d))
    return !1;
  r = c.pos;
  const f = r, p = a, h = r;
  for (; r < i; r++) {
    const _ = s.charCodeAt(r);
    if (_ === 10) {
      const y = o(a);
      y !== null && (s += y, i = s.length, a++);
    } else if (!T(_)) break;
  }
  let g = e.md.helpers.parseLinkTitle(s, r, i);
  for (; g.can_continue; ) {
    const _ = o(a);
    if (_ === null) break;
    s += _, r = i, i = s.length, a++, g = e.md.helpers.parseLinkTitle(s, r, i, g);
  }
  let m;
  for (r < i && h !== r && g.ok ? (m = g.str, r = g.pos) : (m = "", r = f, a = p); r < i; ) {
    const _ = s.charCodeAt(r);
    if (!T(_))
      break;
    r++;
  }
  if (r < i && s.charCodeAt(r) !== 10 && m)
    for (m = "", r = f, a = p; r < i; ) {
      const _ = s.charCodeAt(r);
      if (!T(_))
        break;
      r++;
    }
  if (r < i && s.charCodeAt(r) !== 10)
    return !1;
  const b = St(s.slice(1, l));
  return b ? (u || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[b] > "u" && (e.env.references[b] = { title: m, href: d }), e.line = a), !0) : !1;
}
const Ga = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Ha = "[a-zA-Z_:][a-zA-Z0-9:._-]*", Ua = "[^\"'=<>`\\x00-\\x20]+", Wa = "'[^']*'", Va = '"[^"]*"', Za = "(?:" + Ua + "|" + Wa + "|" + Va + ")", Ja = "(?:\\s+" + Ha + "(?:\\s*=\\s*" + Za + ")?)", Vu = "<[A-Za-z][A-Za-z0-9\\-]*" + Ja + "*\\s*\\/?>", Zu = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", Ka = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->", Qa = "<[?][\\s\\S]*?[?]>", Xa = "<![A-Za-z][^>]*>", Ya = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", eo = new RegExp("^(?:" + Vu + "|" + Zu + "|" + Ka + "|" + Qa + "|" + Xa + "|" + Ya + ")"), to = new RegExp("^(?:" + Vu + "|" + Zu + ")"), xe = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + Ga.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(to.source + "\\s*$"), /^$/, !1]
];
function no(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(r) !== 60)
    return !1;
  let a = e.src.slice(r, i), o = 0;
  for (; o < xe.length && !xe[o][0].test(a); o++)
    ;
  if (o === xe.length)
    return !1;
  if (u)
    return xe[o][2];
  let s = t + 1;
  if (!xe[o][1].test(a)) {
    for (; s < n && !(e.sCount[s] < e.blkIndent); s++)
      if (r = e.bMarks[s] + e.tShift[s], i = e.eMarks[s], a = e.src.slice(r, i), xe[o][1].test(a)) {
        a.length !== 0 && s++;
        break;
      }
  }
  e.line = s;
  const l = e.push("html_block", "", 0);
  return l.map = [t, s], l.content = e.getLines(t, s, e.blkIndent, !0), !0;
}
function uo(e, t, n, u) {
  let r = e.bMarks[t] + e.tShift[t], i = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  let a = e.src.charCodeAt(r);
  if (a !== 35 || r >= i)
    return !1;
  let o = 1;
  for (a = e.src.charCodeAt(++r); a === 35 && r < i && o <= 6; )
    o++, a = e.src.charCodeAt(++r);
  if (o > 6 || r < i && !T(a))
    return !1;
  if (u)
    return !0;
  i = e.skipSpacesBack(i, r);
  const s = e.skipCharsBack(i, 35, r);
  s > r && T(e.src.charCodeAt(s - 1)) && (i = s), e.line = t + 1;
  const l = e.push("heading_open", "h" + String(o), 1);
  l.markup = "########".slice(0, o), l.map = [t, e.line];
  const c = e.push("inline", "", 0);
  c.content = e.src.slice(r, i).trim(), c.map = [t, e.line], c.children = [];
  const d = e.push("heading_close", "h" + String(o), -1);
  return d.markup = "########".slice(0, o), !0;
}
function ro(e, t, n) {
  const u = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  const r = e.parentType;
  e.parentType = "paragraph";
  let i = 0, a, o = t + 1;
  for (; o < n && !e.isEmpty(o); o++) {
    if (e.sCount[o] - e.blkIndent > 3)
      continue;
    if (e.sCount[o] >= e.blkIndent) {
      let p = e.bMarks[o] + e.tShift[o];
      const h = e.eMarks[o];
      if (p < h && (a = e.src.charCodeAt(p), (a === 45 || a === 61) && (p = e.skipChars(p, a), p = e.skipSpaces(p), p >= h))) {
        i = a === 61 ? 1 : 2;
        break;
      }
    }
    if (e.sCount[o] < 0)
      continue;
    let f = !1;
    for (let p = 0, h = u.length; p < h; p++)
      if (u[p](e, o, n, !0)) {
        f = !0;
        break;
      }
    if (f)
      break;
  }
  if (!i)
    return !1;
  const s = e.getLines(t, o, e.blkIndent, !1).trim();
  e.line = o + 1;
  const l = e.push("heading_open", "h" + String(i), 1);
  l.markup = String.fromCharCode(a), l.map = [t, e.line];
  const c = e.push("inline", "", 0);
  c.content = s, c.map = [t, e.line - 1], c.children = [];
  const d = e.push("heading_close", "h" + String(i), -1);
  return d.markup = String.fromCharCode(a), e.parentType = r, !0;
}
function io(e, t, n) {
  const u = e.md.block.ruler.getRules("paragraph"), r = e.parentType;
  let i = t + 1;
  for (e.parentType = "paragraph"; i < n && !e.isEmpty(i); i++) {
    if (e.sCount[i] - e.blkIndent > 3 || e.sCount[i] < 0)
      continue;
    let l = !1;
    for (let c = 0, d = u.length; c < d; c++)
      if (u[c](e, i, n, !0)) {
        l = !0;
        break;
      }
    if (l)
      break;
  }
  const a = e.getLines(t, i, e.blkIndent, !1).trim();
  e.line = i;
  const o = e.push("paragraph_open", "p", 1);
  o.map = [t, e.line];
  const s = e.push("inline", "", 0);
  return s.content = a, s.map = [t, e.line], s.children = [], e.push("paragraph_close", "p", -1), e.parentType = r, !0;
}
const nt = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", Ia, ["paragraph", "reference"]],
  ["code", Ma],
  ["fence", Oa, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", Ba, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", ja, ["paragraph", "reference", "blockquote", "list"]],
  ["list", $a, ["paragraph", "reference", "blockquote"]],
  ["reference", qa],
  ["html_block", no, ["paragraph", "reference", "blockquote"]],
  ["heading", uo, ["paragraph", "reference", "blockquote"]],
  ["lheading", ro],
  ["paragraph", io]
];
function Dt() {
  this.ruler = new H();
  for (let e = 0; e < nt.length; e++)
    this.ruler.push(nt[e][0], nt[e][1], { alt: (nt[e][2] || []).slice() });
}
Dt.prototype.tokenize = function(e, t, n) {
  const u = this.ruler.getRules(""), r = u.length, i = e.md.options.maxNesting;
  let a = t, o = !1;
  for (; a < n && (e.line = a = e.skipEmptyLines(a), !(a >= n || e.sCount[a] < e.blkIndent)); ) {
    if (e.level >= i) {
      e.line = n;
      break;
    }
    const s = e.line;
    let l = !1;
    for (let c = 0; c < r; c++)
      if (l = u[c](e, a, n, !1), l) {
        if (s >= e.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!l) throw new Error("none of the block rules matched");
    e.tight = !o, e.isEmpty(e.line - 1) && (o = !0), a = e.line, a < n && e.isEmpty(a) && (o = !0, a++, e.line = a);
  }
};
Dt.prototype.parse = function(e, t, n, u) {
  if (!e)
    return;
  const r = new this.State(e, t, n, u);
  this.tokenize(r, r.line, r.lineMax);
};
Dt.prototype.State = oe;
function Ke(e, t, n, u) {
  this.src = e, this.env = n, this.md = t, this.tokens = u, this.tokens_meta = Array(u.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1, this.linkLevel = 0;
}
Ke.prototype.pushPending = function() {
  const e = new Y("text", "", 0);
  return e.content = this.pending, e.level = this.pendingLevel, this.tokens.push(e), this.pending = "", e;
};
Ke.prototype.push = function(e, t, n) {
  this.pending && this.pushPending();
  const u = new Y(e, t, n);
  let r = null;
  return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), u.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], r = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(u), this.tokens_meta.push(r), u;
};
Ke.prototype.scanDelims = function(e, t) {
  const n = this.posMax, u = this.src.charCodeAt(e), r = e > 0 ? this.src.charCodeAt(e - 1) : 32;
  let i = e;
  for (; i < n && this.src.charCodeAt(i) === u; )
    i++;
  const a = i - e, o = i < n ? this.src.charCodeAt(i) : 32, s = qe(r) || $e(String.fromCharCode(r)), l = qe(o) || $e(String.fromCharCode(o)), c = ze(r), d = ze(o), f = !d && (!l || c || s), p = !c && (!s || d || l);
  return { can_open: f && (t || !p || s), can_close: p && (t || !f || l), length: a };
};
Ke.prototype.Token = Y;
function ao(e) {
  switch (e) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
function oo(e, t) {
  let n = e.pos;
  for (; n < e.posMax && !ao(e.src.charCodeAt(n)); )
    n++;
  return n === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, n)), e.pos = n, !0);
}
const so = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function lo(e, t) {
  if (!e.md.options.linkify || e.linkLevel > 0) return !1;
  const n = e.pos, u = e.posMax;
  if (n + 3 > u || e.src.charCodeAt(n) !== 58 || e.src.charCodeAt(n + 1) !== 47 || e.src.charCodeAt(n + 2) !== 47) return !1;
  const r = e.pending.match(so);
  if (!r) return !1;
  const i = r[1], a = e.md.linkify.matchAtStart(e.src.slice(n - i.length));
  if (!a) return !1;
  let o = a.url;
  if (o.length <= i.length) return !1;
  o = o.replace(/\*+$/, "");
  const s = e.md.normalizeLink(o);
  if (!e.md.validateLink(s)) return !1;
  if (!t) {
    e.pending = e.pending.slice(0, -i.length);
    const l = e.push("link_open", "a", 1);
    l.attrs = [["href", s]], l.markup = "linkify", l.info = "auto";
    const c = e.push("text", "", 0);
    c.content = e.md.normalizeLinkText(o);
    const d = e.push("link_close", "a", -1);
    d.markup = "linkify", d.info = "auto";
  }
  return e.pos += o.length - i.length, !0;
}
function co(e, t) {
  let n = e.pos;
  if (e.src.charCodeAt(n) !== 10)
    return !1;
  const u = e.pending.length - 1, r = e.posMax;
  if (!t)
    if (u >= 0 && e.pending.charCodeAt(u) === 32)
      if (u >= 1 && e.pending.charCodeAt(u - 1) === 32) {
        let i = u - 1;
        for (; i >= 1 && e.pending.charCodeAt(i - 1) === 32; ) i--;
        e.pending = e.pending.slice(0, i), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (n++; n < r && T(e.src.charCodeAt(n)); )
    n++;
  return e.pos = n, !0;
}
const Sn = [];
for (let e = 0; e < 256; e++)
  Sn.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e) {
  Sn[e.charCodeAt(0)] = 1;
});
function fo(e, t) {
  let n = e.pos;
  const u = e.posMax;
  if (e.src.charCodeAt(n) !== 92 || (n++, n >= u)) return !1;
  let r = e.src.charCodeAt(n);
  if (r === 10) {
    for (t || e.push("hardbreak", "br", 0), n++; n < u && (r = e.src.charCodeAt(n), !!T(r)); )
      n++;
    return e.pos = n, !0;
  }
  let i = e.src[n];
  if (r >= 55296 && r <= 56319 && n + 1 < u) {
    const o = e.src.charCodeAt(n + 1);
    o >= 56320 && o <= 57343 && (i += e.src[n + 1], n++);
  }
  const a = "\\" + i;
  if (!t) {
    const o = e.push("text_special", "", 0);
    r < 256 && Sn[r] !== 0 ? o.content = i : o.content = a, o.markup = a, o.info = "escape";
  }
  return e.pos = n + 1, !0;
}
function ho(e, t) {
  let n = e.pos;
  if (e.src.charCodeAt(n) !== 96)
    return !1;
  const r = n;
  n++;
  const i = e.posMax;
  for (; n < i && e.src.charCodeAt(n) === 96; )
    n++;
  const a = e.src.slice(r, n), o = a.length;
  if (e.backticksScanned && (e.backticks[o] || 0) <= r)
    return t || (e.pending += a), e.pos += o, !0;
  let s = n, l;
  for (; (l = e.src.indexOf("`", s)) !== -1; ) {
    for (s = l + 1; s < i && e.src.charCodeAt(s) === 96; )
      s++;
    const c = s - l;
    if (c === o) {
      if (!t) {
        const d = e.push("code_inline", "code", 0);
        d.markup = a, d.content = e.src.slice(n, l).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      return e.pos = s, !0;
    }
    e.backticks[c] = l;
  }
  return e.backticksScanned = !0, t || (e.pending += a), e.pos += o, !0;
}
function po(e, t) {
  const n = e.pos, u = e.src.charCodeAt(n);
  if (t || u !== 126)
    return !1;
  const r = e.scanDelims(e.pos, !0);
  let i = r.length;
  const a = String.fromCharCode(u);
  if (i < 2)
    return !1;
  let o;
  i % 2 && (o = e.push("text", "", 0), o.content = a, i--);
  for (let s = 0; s < i; s += 2)
    o = e.push("text", "", 0), o.content = a + a, e.delimiters.push({
      marker: u,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: r.can_open,
      close: r.can_close
    });
  return e.pos += r.length, !0;
}
function eu(e, t) {
  let n;
  const u = [], r = t.length;
  for (let i = 0; i < r; i++) {
    const a = t[i];
    if (a.marker !== 126 || a.end === -1)
      continue;
    const o = t[a.end];
    n = e.tokens[a.token], n.type = "s_open", n.tag = "s", n.nesting = 1, n.markup = "~~", n.content = "", n = e.tokens[o.token], n.type = "s_close", n.tag = "s", n.nesting = -1, n.markup = "~~", n.content = "", e.tokens[o.token - 1].type === "text" && e.tokens[o.token - 1].content === "~" && u.push(o.token - 1);
  }
  for (; u.length; ) {
    const i = u.pop();
    let a = i + 1;
    for (; a < e.tokens.length && e.tokens[a].type === "s_close"; )
      a++;
    a--, i !== a && (n = e.tokens[a], e.tokens[a] = e.tokens[i], e.tokens[i] = n);
  }
}
function mo(e) {
  const t = e.tokens_meta, n = e.tokens_meta.length;
  eu(e, e.delimiters);
  for (let u = 0; u < n; u++)
    t[u] && t[u].delimiters && eu(e, t[u].delimiters);
}
const Ju = {
  tokenize: po,
  postProcess: mo
};
function go(e, t) {
  const n = e.pos, u = e.src.charCodeAt(n);
  if (t || u !== 95 && u !== 42)
    return !1;
  const r = e.scanDelims(e.pos, u === 42);
  for (let i = 0; i < r.length; i++) {
    const a = e.push("text", "", 0);
    a.content = String.fromCharCode(u), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: u,
      // Total length of these series of delimiters.
      //
      length: r.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: r.can_open,
      close: r.can_close
    });
  }
  return e.pos += r.length, !0;
}
function tu(e, t) {
  const n = t.length;
  for (let u = n - 1; u >= 0; u--) {
    const r = t[u];
    if (r.marker !== 95 && r.marker !== 42 || r.end === -1)
      continue;
    const i = t[r.end], a = u > 0 && t[u - 1].end === r.end + 1 && // check that first two markers match and adjacent
    t[u - 1].marker === r.marker && t[u - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    t[r.end + 1].token === i.token + 1, o = String.fromCharCode(r.marker), s = e.tokens[r.token];
    s.type = a ? "strong_open" : "em_open", s.tag = a ? "strong" : "em", s.nesting = 1, s.markup = a ? o + o : o, s.content = "";
    const l = e.tokens[i.token];
    l.type = a ? "strong_close" : "em_close", l.tag = a ? "strong" : "em", l.nesting = -1, l.markup = a ? o + o : o, l.content = "", a && (e.tokens[t[u - 1].token].content = "", e.tokens[t[r.end + 1].token].content = "", u--);
  }
}
function _o(e) {
  const t = e.tokens_meta, n = e.tokens_meta.length;
  tu(e, e.delimiters);
  for (let u = 0; u < n; u++)
    t[u] && t[u].delimiters && tu(e, t[u].delimiters);
}
const Ku = {
  tokenize: go,
  postProcess: _o
};
function bo(e, t) {
  let n, u, r, i, a = "", o = "", s = e.pos, l = !0;
  if (e.src.charCodeAt(e.pos) !== 91)
    return !1;
  const c = e.pos, d = e.posMax, f = e.pos + 1, p = e.md.helpers.parseLinkLabel(e, e.pos, !0);
  if (p < 0)
    return !1;
  let h = p + 1;
  if (h < d && e.src.charCodeAt(h) === 40) {
    for (l = !1, h++; h < d && (n = e.src.charCodeAt(h), !(!T(n) && n !== 10)); h++)
      ;
    if (h >= d)
      return !1;
    if (s = h, r = e.md.helpers.parseLinkDestination(e.src, h, e.posMax), r.ok) {
      for (a = e.md.normalizeLink(r.str), e.md.validateLink(a) ? h = r.pos : a = "", s = h; h < d && (n = e.src.charCodeAt(h), !(!T(n) && n !== 10)); h++)
        ;
      if (r = e.md.helpers.parseLinkTitle(e.src, h, e.posMax), h < d && s !== h && r.ok)
        for (o = r.str, h = r.pos; h < d && (n = e.src.charCodeAt(h), !(!T(n) && n !== 10)); h++)
          ;
    }
    (h >= d || e.src.charCodeAt(h) !== 41) && (l = !0), h++;
  }
  if (l) {
    if (typeof e.env.references > "u")
      return !1;
    if (h < d && e.src.charCodeAt(h) === 91 ? (s = h + 1, h = e.md.helpers.parseLinkLabel(e, h), h >= 0 ? u = e.src.slice(s, h++) : h = p + 1) : h = p + 1, u || (u = e.src.slice(f, p)), i = e.env.references[St(u)], !i)
      return e.pos = c, !1;
    a = i.href, o = i.title;
  }
  if (!t) {
    e.pos = f, e.posMax = p;
    const g = e.push("link_open", "a", 1), m = [["href", a]];
    g.attrs = m, o && m.push(["title", o]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, e.push("link_close", "a", -1);
  }
  return e.pos = h, e.posMax = d, !0;
}
function yo(e, t) {
  let n, u, r, i, a, o, s, l, c = "";
  const d = e.pos, f = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91)
    return !1;
  const p = e.pos + 2, h = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1);
  if (h < 0)
    return !1;
  if (i = h + 1, i < f && e.src.charCodeAt(i) === 40) {
    for (i++; i < f && (n = e.src.charCodeAt(i), !(!T(n) && n !== 10)); i++)
      ;
    if (i >= f)
      return !1;
    for (l = i, o = e.md.helpers.parseLinkDestination(e.src, i, e.posMax), o.ok && (c = e.md.normalizeLink(o.str), e.md.validateLink(c) ? i = o.pos : c = ""), l = i; i < f && (n = e.src.charCodeAt(i), !(!T(n) && n !== 10)); i++)
      ;
    if (o = e.md.helpers.parseLinkTitle(e.src, i, e.posMax), i < f && l !== i && o.ok)
      for (s = o.str, i = o.pos; i < f && (n = e.src.charCodeAt(i), !(!T(n) && n !== 10)); i++)
        ;
    else
      s = "";
    if (i >= f || e.src.charCodeAt(i) !== 41)
      return e.pos = d, !1;
    i++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (i < f && e.src.charCodeAt(i) === 91 ? (l = i + 1, i = e.md.helpers.parseLinkLabel(e, i), i >= 0 ? r = e.src.slice(l, i++) : i = h + 1) : i = h + 1, r || (r = e.src.slice(p, h)), a = e.env.references[St(r)], !a)
      return e.pos = d, !1;
    c = a.href, s = a.title;
  }
  if (!t) {
    u = e.src.slice(p, h);
    const g = [];
    e.md.inline.parse(
      u,
      e.md,
      e.env,
      g
    );
    const m = e.push("image", "img", 0), b = [["src", c], ["alt", ""]];
    m.attrs = b, m.children = g, m.content = u, s && b.push(["title", s]);
  }
  return e.pos = i, e.posMax = f, !0;
}
const ko = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, xo = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function wo(e, t) {
  let n = e.pos;
  if (e.src.charCodeAt(n) !== 60)
    return !1;
  const u = e.pos, r = e.posMax;
  for (; ; ) {
    if (++n >= r) return !1;
    const a = e.src.charCodeAt(n);
    if (a === 60) return !1;
    if (a === 62) break;
  }
  const i = e.src.slice(u + 1, n);
  if (xo.test(i)) {
    const a = e.md.normalizeLink(i);
    if (!e.md.validateLink(a))
      return !1;
    if (!t) {
      const o = e.push("link_open", "a", 1);
      o.attrs = [["href", a]], o.markup = "autolink", o.info = "auto";
      const s = e.push("text", "", 0);
      s.content = e.md.normalizeLinkText(i);
      const l = e.push("link_close", "a", -1);
      l.markup = "autolink", l.info = "auto";
    }
    return e.pos += i.length + 2, !0;
  }
  if (ko.test(i)) {
    const a = e.md.normalizeLink("mailto:" + i);
    if (!e.md.validateLink(a))
      return !1;
    if (!t) {
      const o = e.push("link_open", "a", 1);
      o.attrs = [["href", a]], o.markup = "autolink", o.info = "auto";
      const s = e.push("text", "", 0);
      s.content = e.md.normalizeLinkText(i);
      const l = e.push("link_close", "a", -1);
      l.markup = "autolink", l.info = "auto";
    }
    return e.pos += i.length + 2, !0;
  }
  return !1;
}
function Co(e) {
  return /^<a[>\s]/i.test(e);
}
function vo(e) {
  return /^<\/a\s*>/i.test(e);
}
function Ao(e) {
  const t = e | 32;
  return t >= 97 && t <= 122;
}
function Eo(e, t) {
  if (!e.md.options.html)
    return !1;
  const n = e.posMax, u = e.pos;
  if (e.src.charCodeAt(u) !== 60 || u + 2 >= n)
    return !1;
  const r = e.src.charCodeAt(u + 1);
  if (r !== 33 && r !== 63 && r !== 47 && !Ao(r))
    return !1;
  const i = e.src.slice(u).match(eo);
  if (!i)
    return !1;
  if (!t) {
    const a = e.push("html_inline", "", 0);
    a.content = i[0], Co(a.content) && e.linkLevel++, vo(a.content) && e.linkLevel--;
  }
  return e.pos += i[0].length, !0;
}
const So = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, Do = /^&([a-z][a-z0-9]{1,31});/i;
function Fo(e, t) {
  const n = e.pos, u = e.posMax;
  if (e.src.charCodeAt(n) !== 38 || n + 1 >= u) return !1;
  if (e.src.charCodeAt(n + 1) === 35) {
    const i = e.src.slice(n).match(So);
    if (i) {
      if (!t) {
        const a = i[1][0].toLowerCase() === "x" ? parseInt(i[1].slice(1), 16) : parseInt(i[1], 10), o = e.push("text_special", "", 0);
        o.content = An(a) ? dt(a) : dt(65533), o.markup = i[0], o.info = "entity";
      }
      return e.pos += i[0].length, !0;
    }
  } else {
    const i = e.src.slice(n).match(Do);
    if (i) {
      const a = qu(i[0]);
      if (a !== i[0]) {
        if (!t) {
          const o = e.push("text_special", "", 0);
          o.content = a, o.markup = i[0], o.info = "entity";
        }
        return e.pos += i[0].length, !0;
      }
    }
  }
  return !1;
}
function nu(e) {
  const t = {}, n = e.length;
  if (!n) return;
  let u = 0, r = -2;
  const i = [];
  for (let a = 0; a < n; a++) {
    const o = e[a];
    if (i.push(0), (e[u].marker !== o.marker || r !== o.token - 1) && (u = a), r = o.token, o.length = o.length || 0, !o.close) continue;
    t.hasOwnProperty(o.marker) || (t[o.marker] = [-1, -1, -1, -1, -1, -1]);
    const s = t[o.marker][(o.open ? 3 : 0) + o.length % 3];
    let l = u - i[u] - 1, c = l;
    for (; l > s; l -= i[l] + 1) {
      const d = e[l];
      if (d.marker === o.marker && d.open && d.end < 0) {
        let f = !1;
        if ((d.close || o.open) && (d.length + o.length) % 3 === 0 && (d.length % 3 !== 0 || o.length % 3 !== 0) && (f = !0), !f) {
          const p = l > 0 && !e[l - 1].open ? i[l - 1] + 1 : 0;
          i[a] = a - l + p, i[l] = p, o.open = !1, d.end = a, d.close = !1, c = -1, r = -2;
          break;
        }
      }
    }
    c !== -1 && (t[o.marker][(o.open ? 3 : 0) + (o.length || 0) % 3] = c);
  }
}
function To(e) {
  const t = e.tokens_meta, n = e.tokens_meta.length;
  nu(e.delimiters);
  for (let u = 0; u < n; u++)
    t[u] && t[u].delimiters && nu(t[u].delimiters);
}
function Ro(e) {
  let t, n, u = 0;
  const r = e.tokens, i = e.tokens.length;
  for (t = n = 0; t < i; t++)
    r[t].nesting < 0 && u--, r[t].level = u, r[t].nesting > 0 && u++, r[t].type === "text" && t + 1 < i && r[t + 1].type === "text" ? r[t + 1].content = r[t].content + r[t + 1].content : (t !== n && (r[n] = r[t]), n++);
  t !== n && (r.length = n);
}
const zt = [
  ["text", oo],
  ["linkify", lo],
  ["newline", co],
  ["escape", fo],
  ["backticks", ho],
  ["strikethrough", Ju.tokenize],
  ["emphasis", Ku.tokenize],
  ["link", bo],
  ["image", yo],
  ["autolink", wo],
  ["html_inline", Eo],
  ["entity", Fo]
], $t = [
  ["balance_pairs", To],
  ["strikethrough", Ju.postProcess],
  ["emphasis", Ku.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", Ro]
];
function Qe() {
  this.ruler = new H();
  for (let e = 0; e < zt.length; e++)
    this.ruler.push(zt[e][0], zt[e][1]);
  this.ruler2 = new H();
  for (let e = 0; e < $t.length; e++)
    this.ruler2.push($t[e][0], $t[e][1]);
}
Qe.prototype.skipToken = function(e) {
  const t = e.pos, n = this.ruler.getRules(""), u = n.length, r = e.md.options.maxNesting, i = e.cache;
  if (typeof i[t] < "u") {
    e.pos = i[t];
    return;
  }
  let a = !1;
  if (e.level < r) {
    for (let o = 0; o < u; o++)
      if (e.level++, a = n[o](e, !0), e.level--, a) {
        if (t >= e.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    e.pos = e.posMax;
  a || e.pos++, i[t] = e.pos;
};
Qe.prototype.tokenize = function(e) {
  const t = this.ruler.getRules(""), n = t.length, u = e.posMax, r = e.md.options.maxNesting;
  for (; e.pos < u; ) {
    const i = e.pos;
    let a = !1;
    if (e.level < r) {
      for (let o = 0; o < n; o++)
        if (a = t[o](e, !1), a) {
          if (i >= e.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (a) {
      if (e.pos >= u)
        break;
      continue;
    }
    e.pending += e.src[e.pos++];
  }
  e.pending && e.pushPending();
};
Qe.prototype.parse = function(e, t, n, u) {
  const r = new this.State(e, t, n, u);
  this.tokenize(r);
  const i = this.ruler2.getRules(""), a = i.length;
  for (let o = 0; o < a; o++)
    i[o](r);
};
Qe.prototype.State = Ke;
function Lo(e) {
  const t = {};
  e = e || {}, t.src_Any = Ou.source, t.src_Cc = Bu.source, t.src_Z = zu.source, t.src_P = Cn.source, t.src_ZPCc = [t.src_Z, t.src_P, t.src_Cc].join("|"), t.src_ZCc = [t.src_Z, t.src_Cc].join("|");
  const n = "[><ï½œ]";
  return t.src_pseudo_letter = "(?:(?!" + n + "|" + t.src_ZPCc + ")" + t.src_Any + ")", t.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", t.src_auth = "(?:(?:(?!" + t.src_ZCc + "|[@/\\[\\]()]).)+@)?", t.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", t.src_host_terminator = "(?=$|" + n + "|" + t.src_ZPCc + ")(?!" + (e["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + t.src_ZPCc + "))", t.src_path = "(?:[/?#](?:(?!" + t.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + t.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + t.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + t.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + t.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + t.src_ZCc + "|[']).)+\\'|\\'(?=" + t.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + t.src_ZCc + "|[.]|$)|" + (e["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + t.src_ZCc + "|$)|;(?!" + t.src_ZCc + "|$)|\\!+(?!" + t.src_ZCc + "|[!]|$)|\\?(?!" + t.src_ZCc + "|[?]|$))+|\\/)?", t.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', t.src_xn = "xn--[a-z0-9\\-]{1,59}", t.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + t.src_xn + "|" + t.src_pseudo_letter + "{1,63})", t.src_domain = "(?:" + t.src_xn + "|(?:" + t.src_pseudo_letter + ")|(?:" + t.src_pseudo_letter + "(?:-|" + t.src_pseudo_letter + "){0,61}" + t.src_pseudo_letter + "))", t.src_host = "(?:(?:(?:(?:" + t.src_domain + ")\\.)*" + t.src_domain + "))", t.tpl_host_fuzzy = "(?:" + t.src_ip4 + "|(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%)))", t.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + t.src_domain + ")\\.)+(?:%TLDS%))", t.src_host_strict = t.src_host + t.src_host_terminator, t.tpl_host_fuzzy_strict = t.tpl_host_fuzzy + t.src_host_terminator, t.src_host_port_strict = t.src_host + t.src_port + t.src_host_terminator, t.tpl_host_port_fuzzy_strict = t.tpl_host_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_port_no_ip_fuzzy_strict = t.tpl_host_no_ip_fuzzy + t.src_port + t.src_host_terminator, t.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + t.src_ZPCc + "|>|$))", t.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + t.src_ZCc + ")(" + t.src_email_name + "@" + t.tpl_host_fuzzy_strict + ")", t.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + t.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + t.tpl_host_port_fuzzy_strict + t.src_path + ")", t.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|ï½œ]|" + t.src_ZPCc + "))((?![$+<=>^`|ï½œ])" + t.tpl_host_port_no_ip_fuzzy_strict + t.src_path + ")", t;
}
function an(e) {
  return Array.prototype.slice.call(arguments, 1).forEach(function(n) {
    n && Object.keys(n).forEach(function(u) {
      e[u] = n[u];
    });
  }), e;
}
function Ft(e) {
  return Object.prototype.toString.call(e);
}
function Po(e) {
  return Ft(e) === "[object String]";
}
function No(e) {
  return Ft(e) === "[object Object]";
}
function Io(e) {
  return Ft(e) === "[object RegExp]";
}
function uu(e) {
  return Ft(e) === "[object Function]";
}
function Mo(e) {
  return e.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
const Qu = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function Oo(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t || Qu.hasOwnProperty(n);
  }, !1);
}
const Bo = {
  "http:": {
    validate: function(e, t, n) {
      const u = e.slice(t);
      return n.re.http || (n.re.http = new RegExp(
        "^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path,
        "i"
      )), n.re.http.test(u) ? u.match(n.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(e, t, n) {
      const u = e.slice(t);
      return n.re.no_http || (n.re.no_http = new RegExp(
        "^" + n.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path,
        "i"
      )), n.re.no_http.test(u) ? t >= 3 && e[t - 3] === ":" || t >= 3 && e[t - 3] === "/" ? 0 : u.match(n.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(e, t, n) {
      const u = e.slice(t);
      return n.re.mailto || (n.re.mailto = new RegExp(
        "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
        "i"
      )), n.re.mailto.test(u) ? u.match(n.re.mailto)[0].length : 0;
    }
  }
}, jo = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", zo = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|Ñ€Ñ„".split("|");
function $o(e) {
  e.__index__ = -1, e.__text_cache__ = "";
}
function qo(e) {
  return function(t, n) {
    const u = t.slice(n);
    return e.test(u) ? u.match(e)[0].length : 0;
  };
}
function ru() {
  return function(e, t) {
    t.normalize(e);
  };
}
function ft(e) {
  const t = e.re = Lo(e.__opts__), n = e.__tlds__.slice();
  e.onCompile(), e.__tlds_replaced__ || n.push(jo), n.push(t.src_xn), t.src_tlds = n.join("|");
  function u(o) {
    return o.replace("%TLDS%", t.src_tlds);
  }
  t.email_fuzzy = RegExp(u(t.tpl_email_fuzzy), "i"), t.link_fuzzy = RegExp(u(t.tpl_link_fuzzy), "i"), t.link_no_ip_fuzzy = RegExp(u(t.tpl_link_no_ip_fuzzy), "i"), t.host_fuzzy_test = RegExp(u(t.tpl_host_fuzzy_test), "i");
  const r = [];
  e.__compiled__ = {};
  function i(o, s) {
    throw new Error('(LinkifyIt) Invalid schema "' + o + '": ' + s);
  }
  Object.keys(e.__schemas__).forEach(function(o) {
    const s = e.__schemas__[o];
    if (s === null)
      return;
    const l = { validate: null, link: null };
    if (e.__compiled__[o] = l, No(s)) {
      Io(s.validate) ? l.validate = qo(s.validate) : uu(s.validate) ? l.validate = s.validate : i(o, s), uu(s.normalize) ? l.normalize = s.normalize : s.normalize ? i(o, s) : l.normalize = ru();
      return;
    }
    if (Po(s)) {
      r.push(o);
      return;
    }
    i(o, s);
  }), r.forEach(function(o) {
    e.__compiled__[e.__schemas__[o]] && (e.__compiled__[o].validate = e.__compiled__[e.__schemas__[o]].validate, e.__compiled__[o].normalize = e.__compiled__[e.__schemas__[o]].normalize);
  }), e.__compiled__[""] = { validate: null, normalize: ru() };
  const a = Object.keys(e.__compiled__).filter(function(o) {
    return o.length > 0 && e.__compiled__[o];
  }).map(Mo).join("|");
  e.re.schema_test = RegExp("(^|(?!_)(?:[><ï½œ]|" + t.src_ZPCc + "))(" + a + ")", "i"), e.re.schema_search = RegExp("(^|(?!_)(?:[><ï½œ]|" + t.src_ZPCc + "))(" + a + ")", "ig"), e.re.schema_at_start = RegExp("^" + e.re.schema_search.source, "i"), e.re.pretest = RegExp(
    "(" + e.re.schema_test.source + ")|(" + e.re.host_fuzzy_test.source + ")|@",
    "i"
  ), $o(e);
}
function Go(e, t) {
  const n = e.__index__, u = e.__last_index__, r = e.__text_cache__.slice(n, u);
  this.schema = e.__schema__.toLowerCase(), this.index = n + t, this.lastIndex = u + t, this.raw = r, this.text = r, this.url = r;
}
function on(e, t) {
  const n = new Go(e, t);
  return e.__compiled__[n.schema].normalize(n, e), n;
}
function V(e, t) {
  if (!(this instanceof V))
    return new V(e, t);
  t || Oo(e) && (t = e, e = {}), this.__opts__ = an({}, Qu, t), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = an({}, Bo, e), this.__compiled__ = {}, this.__tlds__ = zo, this.__tlds_replaced__ = !1, this.re = {}, ft(this);
}
V.prototype.add = function(t, n) {
  return this.__schemas__[t] = n, ft(this), this;
};
V.prototype.set = function(t) {
  return this.__opts__ = an(this.__opts__, t), this;
};
V.prototype.test = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length)
    return !1;
  let n, u, r, i, a, o, s, l, c;
  if (this.re.schema_test.test(t)) {
    for (s = this.re.schema_search, s.lastIndex = 0; (n = s.exec(t)) !== null; )
      if (i = this.testSchemaAt(t, n[2], s.lastIndex), i) {
        this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + i;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = t.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (u = t.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (a = u.index + u[1].length, (this.__index__ < 0 || a < this.__index__) && (this.__schema__ = "", this.__index__ = a, this.__last_index__ = u.index + u[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (c = t.indexOf("@"), c >= 0 && (r = t.match(this.re.email_fuzzy)) !== null && (a = r.index + r[1].length, o = r.index + r[0].length, (this.__index__ < 0 || a < this.__index__ || a === this.__index__ && o > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = a, this.__last_index__ = o))), this.__index__ >= 0;
};
V.prototype.pretest = function(t) {
  return this.re.pretest.test(t);
};
V.prototype.testSchemaAt = function(t, n, u) {
  return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(t, u, this) : 0;
};
V.prototype.match = function(t) {
  const n = [];
  let u = 0;
  this.__index__ >= 0 && this.__text_cache__ === t && (n.push(on(this, u)), u = this.__last_index__);
  let r = u ? t.slice(u) : t;
  for (; this.test(r); )
    n.push(on(this, u)), r = r.slice(this.__last_index__), u += this.__last_index__;
  return n.length ? n : null;
};
V.prototype.matchAtStart = function(t) {
  if (this.__text_cache__ = t, this.__index__ = -1, !t.length) return null;
  const n = this.re.schema_at_start.exec(t);
  if (!n) return null;
  const u = this.testSchemaAt(t, n[2], n[0].length);
  return u ? (this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + u, on(this, 0)) : null;
};
V.prototype.tlds = function(t, n) {
  return t = Array.isArray(t) ? t : [t], n ? (this.__tlds__ = this.__tlds__.concat(t).sort().filter(function(u, r, i) {
    return u !== i[r - 1];
  }).reverse(), ft(this), this) : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = !0, ft(this), this);
};
V.prototype.normalize = function(t) {
  t.schema || (t.url = "http://" + t.url), t.schema === "mailto:" && !/^mailto:/i.test(t.url) && (t.url = "mailto:" + t.url);
};
V.prototype.onCompile = function() {
};
const Ae = 2147483647, re = 36, Dn = 1, Ge = 26, Ho = 38, Uo = 700, Xu = 72, Yu = 128, er = "-", Wo = /^xn--/, Vo = /[^\0-\x7F]/, Zo = /[\x2E\u3002\uFF0E\uFF61]/g, Jo = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, qt = re - Dn, ie = Math.floor, Gt = String.fromCharCode;
function fe(e) {
  throw new RangeError(Jo[e]);
}
function Ko(e, t) {
  const n = [];
  let u = e.length;
  for (; u--; )
    n[u] = t(e[u]);
  return n;
}
function tr(e, t) {
  const n = e.split("@");
  let u = "";
  n.length > 1 && (u = n[0] + "@", e = n[1]), e = e.replace(Zo, ".");
  const r = e.split("."), i = Ko(r, t).join(".");
  return u + i;
}
function nr(e) {
  const t = [];
  let n = 0;
  const u = e.length;
  for (; n < u; ) {
    const r = e.charCodeAt(n++);
    if (r >= 55296 && r <= 56319 && n < u) {
      const i = e.charCodeAt(n++);
      (i & 64512) == 56320 ? t.push(((r & 1023) << 10) + (i & 1023) + 65536) : (t.push(r), n--);
    } else
      t.push(r);
  }
  return t;
}
const Qo = (e) => String.fromCodePoint(...e), Xo = function(e) {
  return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : re;
}, iu = function(e, t) {
  return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
}, ur = function(e, t, n) {
  let u = 0;
  for (e = n ? ie(e / Uo) : e >> 1, e += ie(e / t); e > qt * Ge >> 1; u += re)
    e = ie(e / qt);
  return ie(u + (qt + 1) * e / (e + Ho));
}, rr = function(e) {
  const t = [], n = e.length;
  let u = 0, r = Yu, i = Xu, a = e.lastIndexOf(er);
  a < 0 && (a = 0);
  for (let o = 0; o < a; ++o)
    e.charCodeAt(o) >= 128 && fe("not-basic"), t.push(e.charCodeAt(o));
  for (let o = a > 0 ? a + 1 : 0; o < n; ) {
    const s = u;
    for (let c = 1, d = re; ; d += re) {
      o >= n && fe("invalid-input");
      const f = Xo(e.charCodeAt(o++));
      f >= re && fe("invalid-input"), f > ie((Ae - u) / c) && fe("overflow"), u += f * c;
      const p = d <= i ? Dn : d >= i + Ge ? Ge : d - i;
      if (f < p)
        break;
      const h = re - p;
      c > ie(Ae / h) && fe("overflow"), c *= h;
    }
    const l = t.length + 1;
    i = ur(u - s, l, s == 0), ie(u / l) > Ae - r && fe("overflow"), r += ie(u / l), u %= l, t.splice(u++, 0, r);
  }
  return String.fromCodePoint(...t);
}, ir = function(e) {
  const t = [];
  e = nr(e);
  const n = e.length;
  let u = Yu, r = 0, i = Xu;
  for (const s of e)
    s < 128 && t.push(Gt(s));
  const a = t.length;
  let o = a;
  for (a && t.push(er); o < n; ) {
    let s = Ae;
    for (const c of e)
      c >= u && c < s && (s = c);
    const l = o + 1;
    s - u > ie((Ae - r) / l) && fe("overflow"), r += (s - u) * l, u = s;
    for (const c of e)
      if (c < u && ++r > Ae && fe("overflow"), c === u) {
        let d = r;
        for (let f = re; ; f += re) {
          const p = f <= i ? Dn : f >= i + Ge ? Ge : f - i;
          if (d < p)
            break;
          const h = d - p, g = re - p;
          t.push(
            Gt(iu(p + h % g, 0))
          ), d = ie(h / g);
        }
        t.push(Gt(iu(d, 0))), i = ur(r, l, o === a), r = 0, ++o;
      }
    ++r, ++u;
  }
  return t.join("");
}, Yo = function(e) {
  return tr(e, function(t) {
    return Wo.test(t) ? rr(t.slice(4).toLowerCase()) : t;
  });
}, es = function(e) {
  return tr(e, function(t) {
    return Vo.test(t) ? "xn--" + ir(t) : t;
  });
}, ar = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: nr,
    encode: Qo
  },
  decode: rr,
  encode: ir,
  toASCII: es,
  toUnicode: Yo
}, ts = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, ns = {
  options: {
    // Enable HTML tags in source
    html: !1,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !1,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
}, us = {
  options: {
    // Enable HTML tags in source
    html: !0,
    // Use '/' to close single tags (<br />)
    xhtmlOut: !0,
    // Convert '\n' in paragraphs into <br>
    breaks: !1,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: !1,
    // Enable some language-neutral replacements + quotes beautification
    typographer: !1,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use 'Â«Â»â€â€œ' for Russian, 'â€â€œâ€šâ€˜' for German,
    // and ['Â«\xA0', '\xA0Â»', 'â€¹\xA0', '\xA0â€º'] for French (including nbsp).
    quotes: "â€œâ€â€˜â€™",
    /* â€œâ€â€˜â€™ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
}, rs = {
  default: ts,
  zero: ns,
  commonmark: us
}, is = /^(vbscript|javascript|file|data):/, as = /^data:image\/(gif|png|jpeg|webp);/;
function os(e) {
  const t = e.trim().toLowerCase();
  return is.test(t) ? as.test(t) : !0;
}
const or = ["http:", "https:", "mailto:"];
function ss(e) {
  const t = wn(e, !0);
  if (t.hostname && (!t.protocol || or.indexOf(t.protocol) >= 0))
    try {
      t.hostname = ar.toASCII(t.hostname);
    } catch {
    }
  return Je(xn(t));
}
function ls(e) {
  const t = wn(e, !0);
  if (t.hostname && (!t.protocol || or.indexOf(t.protocol) >= 0))
    try {
      t.hostname = ar.toUnicode(t.hostname);
    } catch {
    }
  return De(xn(t), De.defaultChars + "%");
}
function X(e, t) {
  if (!(this instanceof X))
    return new X(e, t);
  t || vn(e) || (t = e || {}, e = "default"), this.inline = new Qe(), this.block = new Dt(), this.core = new En(), this.renderer = new Le(), this.linkify = new V(), this.validateLink = os, this.normalizeLink = ss, this.normalizeLinkText = ls, this.utils = ca, this.helpers = Et({}, pa), this.options = {}, this.configure(e), t && this.set(t);
}
X.prototype.set = function(e) {
  return Et(this.options, e), this;
};
X.prototype.configure = function(e) {
  const t = this;
  if (vn(e)) {
    const n = e;
    if (e = rs[n], !e)
      throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  }
  if (!e)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return e.options && t.set(e.options), e.components && Object.keys(e.components).forEach(function(n) {
    e.components[n].rules && t[n].ruler.enableOnly(e.components[n].rules), e.components[n].rules2 && t[n].ruler2.enableOnly(e.components[n].rules2);
  }), this;
};
X.prototype.enable = function(e, t) {
  let n = [];
  Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(r) {
    n = n.concat(this[r].ruler.enable(e, !0));
  }, this), n = n.concat(this.inline.ruler2.enable(e, !0));
  const u = e.filter(function(r) {
    return n.indexOf(r) < 0;
  });
  if (u.length && !t)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + u);
  return this;
};
X.prototype.disable = function(e, t) {
  let n = [];
  Array.isArray(e) || (e = [e]), ["core", "block", "inline"].forEach(function(r) {
    n = n.concat(this[r].ruler.disable(e, !0));
  }, this), n = n.concat(this.inline.ruler2.disable(e, !0));
  const u = e.filter(function(r) {
    return n.indexOf(r) < 0;
  });
  if (u.length && !t)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + u);
  return this;
};
X.prototype.use = function(e) {
  const t = [this].concat(Array.prototype.slice.call(arguments, 1));
  return e.apply(e, t), this;
};
X.prototype.parse = function(e, t) {
  if (typeof e != "string")
    throw new Error("Input data should be a String");
  const n = new this.core.State(e, this, t);
  return this.core.process(n), n.tokens;
};
X.prototype.render = function(e, t) {
  return t = t || {}, this.renderer.render(this.parse(e, t), this.options, t);
};
X.prototype.parseInline = function(e, t) {
  const n = new this.core.State(e, this, t);
  return n.inlineMode = !0, this.core.process(n), n.tokens;
};
X.prototype.renderInline = function(e, t) {
  return t = t || {}, this.renderer.render(this.parseInline(e, t), this.options, t);
};
var au = !1, Te = { false: "push", true: "unshift", after: "push", before: "unshift" }, ht = { isPermalinkSymbol: !0 };
function sn(e, t, n, u) {
  var r;
  if (!au) {
    var i = "Using deprecated markdown-it-anchor permalink option, see https://github.com/valeriangalliat/markdown-it-anchor#permalinks";
    typeof process == "object" && process && process.emitWarning ? process.emitWarning(i) : console.warn(i), au = !0;
  }
  var a = [Object.assign(new n.Token("link_open", "a", 1), { attrs: [].concat(t.permalinkClass ? [["class", t.permalinkClass]] : [], [["href", t.permalinkHref(e, n)]], Object.entries(t.permalinkAttrs(e, n))) }), Object.assign(new n.Token("html_block", "", 0), { content: t.permalinkSymbol, meta: ht }), new n.Token("link_close", "a", -1)];
  t.permalinkSpace && n.tokens[u + 1].children[Te[t.permalinkBefore]](Object.assign(new n.Token("text", "", 0), { content: " " })), (r = n.tokens[u + 1].children)[Te[t.permalinkBefore]].apply(r, a);
}
function sr(e) {
  return "#" + e;
}
function lr(e) {
  return {};
}
var cs = { class: "header-anchor", symbol: "#", renderHref: sr, renderAttrs: lr };
function Xe(e) {
  function t(n) {
    return n = Object.assign({}, t.defaults, n), function(u, r, i, a) {
      return e(u, n, r, i, a);
    };
  }
  return t.defaults = Object.assign({}, cs), t.renderPermalinkImpl = e, t;
}
function Fn(e) {
  var t = [], n = e.filter(function(u) {
    if (u[0] !== "class") return !0;
    t.push(u[1]);
  });
  return t.length > 0 && n.unshift(["class", t.join(" ")]), n;
}
var Tt = Xe(function(e, t, n, u, r) {
  var i, a = [Object.assign(new u.Token("link_open", "a", 1), { attrs: Fn([].concat(t.class ? [["class", t.class]] : [], [["href", t.renderHref(e, u)]], t.ariaHidden ? [["aria-hidden", "true"]] : [], Object.entries(t.renderAttrs(e, u)))) }), Object.assign(new u.Token("html_inline", "", 0), { content: t.symbol, meta: ht }), new u.Token("link_close", "a", -1)];
  if (t.space) {
    var o = typeof t.space == "string" ? t.space : " ";
    u.tokens[r + 1].children[Te[t.placement]](Object.assign(new u.Token(typeof t.space == "string" ? "html_inline" : "text", "", 0), { content: o }));
  }
  (i = u.tokens[r + 1].children)[Te[t.placement]].apply(i, a);
});
Object.assign(Tt.defaults, { space: !0, placement: "after", ariaHidden: !1 });
var ge = Xe(Tt.renderPermalinkImpl);
ge.defaults = Object.assign({}, Tt.defaults, { ariaHidden: !0 });
var cr = Xe(function(e, t, n, u, r) {
  var i = [Object.assign(new u.Token("link_open", "a", 1), { attrs: Fn([].concat(t.class ? [["class", t.class]] : [], [["href", t.renderHref(e, u)]], Object.entries(t.renderAttrs(e, u)))) })].concat(t.safariReaderFix ? [new u.Token("span_open", "span", 1)] : [], u.tokens[r + 1].children, t.safariReaderFix ? [new u.Token("span_close", "span", -1)] : [], [new u.Token("link_close", "a", -1)]);
  u.tokens[r + 1] = Object.assign(new u.Token("inline", "", 0), { children: i });
});
Object.assign(cr.defaults, { safariReaderFix: !1 });
var ou = Xe(function(e, t, n, u, r) {
  var i;
  if (!["visually-hidden", "aria-label", "aria-describedby", "aria-labelledby"].includes(t.style)) throw new Error("`permalink.linkAfterHeader` called with unknown style option `" + t.style + "`");
  if (!["aria-describedby", "aria-labelledby"].includes(t.style) && !t.assistiveText) throw new Error("`permalink.linkAfterHeader` called without the `assistiveText` option in `" + t.style + "` style");
  if (t.style === "visually-hidden" && !t.visuallyHiddenClass) throw new Error("`permalink.linkAfterHeader` called without the `visuallyHiddenClass` option in `visually-hidden` style");
  var a = u.tokens[r + 1].children.filter(function(d) {
    return d.type === "text" || d.type === "code_inline";
  }).reduce(function(d, f) {
    return d + f.content;
  }, ""), o = [], s = [];
  if (t.class && s.push(["class", t.class]), s.push(["href", t.renderHref(e, u)]), s.push.apply(s, Object.entries(t.renderAttrs(e, u))), t.style === "visually-hidden") {
    if (o.push(Object.assign(new u.Token("span_open", "span", 1), { attrs: [["class", t.visuallyHiddenClass]] }), Object.assign(new u.Token("text", "", 0), { content: t.assistiveText(a) }), new u.Token("span_close", "span", -1)), t.space) {
      var l = typeof t.space == "string" ? t.space : " ";
      o[Te[t.placement]](Object.assign(new u.Token(typeof t.space == "string" ? "html_inline" : "text", "", 0), { content: l }));
    }
    o[Te[t.placement]](Object.assign(new u.Token("span_open", "span", 1), { attrs: [["aria-hidden", "true"]] }), Object.assign(new u.Token("html_inline", "", 0), { content: t.symbol, meta: ht }), new u.Token("span_close", "span", -1));
  } else o.push(Object.assign(new u.Token("html_inline", "", 0), { content: t.symbol, meta: ht }));
  t.style === "aria-label" ? s.push(["aria-label", t.assistiveText(a)]) : ["aria-describedby", "aria-labelledby"].includes(t.style) && s.push([t.style, e]);
  var c = [Object.assign(new u.Token("link_open", "a", 1), { attrs: Fn(s) })].concat(o, [new u.Token("link_close", "a", -1)]);
  (i = u.tokens).splice.apply(i, [r + 3, 0].concat(c)), t.wrapper && (u.tokens.splice(r, 0, Object.assign(new u.Token("html_block", "", 0), { content: t.wrapper[0] + `
` })), u.tokens.splice(r + 3 + c.length + 1, 0, Object.assign(new u.Token("html_block", "", 0), { content: t.wrapper[1] + `
` })));
});
function su(e, t, n, u) {
  var r = e, i = u;
  if (n && Object.prototype.hasOwnProperty.call(t, r)) throw new Error("User defined `id` attribute `" + e + "` is not unique. Please fix it in your Markdown to continue.");
  for (; Object.prototype.hasOwnProperty.call(t, r); ) r = e + "-" + i, i += 1;
  return t[r] = !0, r;
}
function _e(e, t) {
  t = Object.assign({}, _e.defaults, t), e.core.ruler.push("anchor", function(n) {
    for (var u, r = {}, i = n.tokens, a = Array.isArray(t.level) ? (u = t.level, function(d) {
      return u.includes(d);
    }) : /* @__PURE__ */ function(d) {
      return function(f) {
        return f >= d;
      };
    }(t.level), o = 0; o < i.length; o++) {
      var s = i[o];
      if (s.type === "heading_open" && a(Number(s.tag.substr(1)))) {
        var l = t.getTokensText(i[o + 1].children), c = s.attrGet("id");
        c = c == null ? su(c = t.slugifyWithState ? t.slugifyWithState(l, n) : t.slugify(l), r, !1, t.uniqueSlugStartIndex) : su(c, r, !0, t.uniqueSlugStartIndex), s.attrSet("id", c), t.tabIndex !== !1 && s.attrSet("tabindex", "" + t.tabIndex), typeof t.permalink == "function" ? t.permalink(c, t, n, o) : (t.permalink || t.renderPermalink && t.renderPermalink !== sn) && t.renderPermalink(c, t, n, o), o = i.indexOf(s), t.callback && t.callback(s, { slug: c, title: l });
      }
    }
  });
}
Object.assign(ou.defaults, { style: "visually-hidden", space: !0, placement: "after", wrapper: null }), _e.permalink = { __proto__: null, legacy: sn, renderHref: sr, renderAttrs: lr, makePermalink: Xe, linkInsideHeader: Tt, ariaHidden: ge, headerLink: cr, linkAfterHeader: ou }, _e.defaults = { level: 1, slugify: function(e) {
  return encodeURIComponent(String(e).trim().toLowerCase().replace(/\s+/g, "-"));
}, uniqueSlugStartIndex: 1, tabIndex: "-1", getTokensText: function(e) {
  return e.filter(function(t) {
    return ["text", "code_inline"].includes(t.type);
  }).map(function(t) {
    return t.content;
  }).join("");
}, permalink: !1, renderPermalink: sn, permalinkClass: ge.defaults.class, permalinkSpace: ge.defaults.space, permalinkSymbol: "Â¶", permalinkBefore: ge.defaults.placement === "before", permalinkHref: ge.defaults.renderHref, permalinkAttrs: ge.defaults.renderAttrs }, _e.default = _e;
function ds(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var se = {}, lu;
function fs() {
  if (lu) return se;
  lu = 1, se.getAttrs = function(i, a, o) {
    const s = /[^\t\n\f />"'=]/, l = " ", c = "=", d = ".", f = "#", p = [];
    let h = "", g = "", m = !0, b = !1;
    for (let _ = a + o.leftDelimiter.length; _ < i.length; _++) {
      if (i.slice(_, _ + o.rightDelimiter.length) === o.rightDelimiter) {
        h !== "" && p.push([h, g]);
        break;
      }
      const y = i.charAt(_);
      if (y === c && m) {
        m = !1;
        continue;
      }
      if (y === d && h === "") {
        i.charAt(_ + 1) === d ? (h = "css-module", _ += 1) : h = "class", m = !1;
        continue;
      }
      if (y === f && h === "") {
        h = "id", m = !1;
        continue;
      }
      if (y === '"' && g === "" && !b) {
        b = !0;
        continue;
      }
      if (y === '"' && b) {
        b = !1;
        continue;
      }
      if (y === l && !b) {
        if (h === "")
          continue;
        p.push([h, g]), h = "", g = "", m = !0;
        continue;
      }
      if (!(m && y.search(s) === -1)) {
        if (m) {
          h += y;
          continue;
        }
        g += y;
      }
    }
    if (o.allowedAttributes && o.allowedAttributes.length) {
      const _ = o.allowedAttributes;
      return p.filter(function(y) {
        const x = y[0];
        function C(v) {
          return x === v || v instanceof RegExp && v.test(x);
        }
        return _.some(C);
      });
    }
    return p;
  }, se.addAttrs = function(i, a) {
    for (let o = 0, s = i.length; o < s; ++o) {
      const l = i[o][0];
      l === "class" ? a.attrJoin("class", i[o][1]) : l === "css-module" ? a.attrJoin("css-module", i[o][1]) : a.attrPush(i[o]);
    }
    return a;
  }, se.hasDelimiters = function(i, a) {
    if (!i)
      throw new Error('Parameter `where` not passed. Should be "start", "end" or "only".');
    return function(o) {
      const s = a.leftDelimiter.length + 1 + a.rightDelimiter.length;
      if (!o || typeof o != "string" || o.length < s)
        return !1;
      function l(g) {
        const m = g.charAt(a.leftDelimiter.length) === ".", b = g.charAt(a.leftDelimiter.length) === "#";
        return m || b ? g.length >= s + 1 : g.length >= s;
      }
      let c, d, f, p;
      const h = s - a.rightDelimiter.length;
      switch (i) {
        case "start":
          f = o.slice(0, a.leftDelimiter.length), c = f === a.leftDelimiter ? 0 : -1, d = c === -1 ? -1 : o.indexOf(a.rightDelimiter, h), p = o.charAt(d + a.rightDelimiter.length), p && a.rightDelimiter.indexOf(p) !== -1 && (d = -1);
          break;
        case "end":
          c = o.lastIndexOf(a.leftDelimiter), d = c === -1 ? -1 : o.indexOf(a.rightDelimiter, c + h), d = d === o.length - a.rightDelimiter.length ? d : -1;
          break;
        case "only":
          f = o.slice(0, a.leftDelimiter.length), c = f === a.leftDelimiter ? 0 : -1, f = o.slice(o.length - a.rightDelimiter.length), d = f === a.rightDelimiter ? o.length - a.rightDelimiter.length : -1;
          break;
        default:
          throw new Error(`Unexpected case ${i}, expected 'start', 'end' or 'only'`);
      }
      return c !== -1 && d !== -1 && l(o.substring(c, d + a.rightDelimiter.length));
    };
  }, se.removeDelimiter = function(i, a) {
    const o = e(a.leftDelimiter), s = e(a.rightDelimiter), l = new RegExp(
      "[ \\n]?" + o + "[^" + o + s + "]+" + s + "$"
    ), c = i.search(l);
    return c !== -1 ? i.slice(0, c) : i;
  };
  function e(i) {
    return i.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  se.escapeRegExp = e, se.getMatchingOpeningToken = function(i, a) {
    if (i[a].type === "softbreak")
      return !1;
    if (i[a].nesting === 0)
      return i[a];
    const o = i[a].level, s = i[a].type.replace("_close", "_open");
    for (; a >= 0; --a)
      if (i[a].type === s && i[a].level === o)
        return i[a];
    return !1;
  };
  const t = /[&<>"]/, n = /[&<>"]/g, u = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function r(i) {
    return u[i];
  }
  return se.escapeHtml = function(i) {
    return t.test(i) ? i.replace(n, r) : i;
  }, se;
}
var Ht, cu;
function hs() {
  if (cu) return Ht;
  cu = 1;
  const e = fs();
  Ht = (u) => {
    const r = new RegExp("^ {0,3}[-*_]{3,} ?" + e.escapeRegExp(u.leftDelimiter) + "[^" + e.escapeRegExp(u.rightDelimiter) + "]");
    return [
      {
        /**
         * ```python {.cls}
         * for i in range(10):
         *     print(i)
         * ```
         */
        name: "fenced code blocks",
        tests: [
          {
            shift: 0,
            block: !0,
            info: e.hasDelimiters("end", u)
          }
        ],
        transform: (i, a) => {
          const o = i[a], s = o.info.lastIndexOf(u.leftDelimiter), l = e.getAttrs(o.info, s, u);
          e.addAttrs(l, o), o.info = e.removeDelimiter(o.info, u);
        }
      },
      {
        /**
         * bla `click()`{.c} ![](img.png){.d}
         *
         * differs from 'inline attributes' as it does
         * not have a closing tag (nesting: -1)
         */
        name: "inline nesting 0",
        tests: [
          {
            shift: 0,
            type: "inline",
            children: [
              {
                shift: -1,
                type: (i) => i === "image" || i === "code_inline"
              },
              {
                shift: 0,
                type: "text",
                content: e.hasDelimiters("start", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = s.content.indexOf(u.rightDelimiter), c = i[a].children[o - 1], d = e.getAttrs(s.content, 0, u);
          e.addAttrs(d, c), s.content.length === l + u.rightDelimiter.length ? i[a].children.splice(o, 1) : s.content = s.content.slice(l + u.rightDelimiter.length);
        }
      },
      {
        /**
         * | h1 |
         * | -- |
         * | c1 |
         *
         * {.c}
         */
        name: "tables",
        tests: [
          {
            // let this token be i, such that for-loop continues at
            // next token after tokens.splice
            shift: 0,
            type: "table_close"
          },
          {
            shift: 1,
            type: "paragraph_open"
          },
          {
            shift: 2,
            type: "inline",
            content: e.hasDelimiters("only", u)
          }
        ],
        transform: (i, a) => {
          const o = i[a + 2], s = e.getMatchingOpeningToken(i, a), l = e.getAttrs(o.content, 0, u);
          e.addAttrs(l, s), i.splice(a + 1, 3);
        }
      },
      {
        /**
         * | A | B |
         * | -- | -- |
         * | 1 | 2 |
         *
         * | C | D |
         * | -- | -- |
         *
         * only `| A | B |` sets the colsnum metadata
         */
        name: "tables thead metadata",
        tests: [
          {
            shift: 0,
            type: "tr_close"
          },
          {
            shift: 1,
            type: "thead_close"
          },
          {
            shift: 2,
            type: "tbody_open"
          }
        ],
        transform: (i, a) => {
          const o = e.getMatchingOpeningToken(i, a), s = i[a - 1];
          let l = 0, c = a;
          for (; --c; ) {
            if (i[c] === o) {
              i[c - 1].meta = Object.assign({}, i[c + 2].meta, { colsnum: l });
              break;
            }
            l += (i[c].level === s.level && i[c].type === s.type) >> 0;
          }
          i[a + 2].meta = Object.assign({}, i[a + 2].meta, { colsnum: l });
        }
      },
      {
        /**
         * | A | B | C | D |
         * | -- | -- | -- | -- |
         * | 1 | 11 | 111 | 1111 {rowspan=3} |
         * | 2 {colspan=2 rowspan=2} | 22 | 222 | 2222 |
         * | 3 | 33 | 333 | 3333 |
         */
        name: "tables tbody calculate",
        tests: [
          {
            shift: 0,
            type: "tbody_close",
            hidden: !1
          }
        ],
        /**
         * @param {number} i index of the tbody ending
         */
        transform: (i, a) => {
          let o = a - 2;
          for (; o > 0 && i[--o].type !== "tbody_open"; ) ;
          const s = i[o].meta.colsnum >> 0;
          if (s < 2)
            return;
          const l = i[a].level + 2;
          for (let c = o; c < a; c++) {
            if (i[c].level > l)
              continue;
            const d = i[c], f = d.hidden ? 0 : d.attrGet("rowspan") >> 0, p = d.hidden ? 0 : d.attrGet("colspan") >> 0;
            if (f > 1) {
              let h = s - (p > 0 ? p : 1);
              for (let g = c, m = f; m > 1; g++)
                i[g].type == "tr_open" && (i[g].meta = Object.assign({}, i[g].meta), i[g].meta && i[g].meta.colsnum && (h -= 1), i[g].meta.colsnum = h, m--);
            }
            if (d.type == "tr_open" && d.meta && d.meta.colsnum) {
              const h = d.meta.colsnum;
              for (let g = c, m = 0; g < a; g++) {
                if (i[g].type == "td_open")
                  m += 1;
                else if (i[g].type == "tr_close")
                  break;
                m > h && (i[g].hidden || n(i[g]));
              }
            }
            if (p > 1) {
              const h = [];
              let g = c + 3, m = s;
              for (let y = c; y > o; y--)
                if (i[y].type == "tr_open") {
                  m = i[y].meta && i[y].meta.colsnum || m;
                  break;
                } else i[y].type === "td_open" && h.unshift(y);
              for (let y = c + 2; y < a; y++)
                if (i[y].type == "tr_close") {
                  g = y;
                  break;
                } else i[y].type == "td_open" && h.push(y);
              const b = h.indexOf(c);
              let _ = m - b;
              _ = _ > p ? p : _, p > _ && d.attrSet("colspan", _ + "");
              for (let y = h.slice(m + 1 - s - _)[0]; y < g; y++)
                i[y].hidden || n(i[y]);
            }
          }
        }
      },
      {
        /**
         * *emphasis*{.with attrs=1}
         */
        name: "inline attributes",
        tests: [
          {
            shift: 0,
            type: "inline",
            children: [
              {
                shift: -1,
                nesting: -1
                // closing inline tag, </em>{.a}
              },
              {
                shift: 0,
                type: "text",
                content: e.hasDelimiters("start", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = s.content, c = e.getAttrs(l, 0, u), d = e.getMatchingOpeningToken(i[a].children, o - 1);
          e.addAttrs(c, d), s.content = l.slice(l.indexOf(u.rightDelimiter) + u.rightDelimiter.length);
        }
      },
      {
        /**
         * - item
         * {.a}
         */
        name: "list softbreak",
        tests: [
          {
            shift: -2,
            type: "list_item_open"
          },
          {
            shift: 0,
            type: "inline",
            children: [
              {
                position: -2,
                type: "softbreak"
              },
              {
                position: -1,
                type: "text",
                content: e.hasDelimiters("only", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const l = i[a].children[o].content, c = e.getAttrs(l, 0, u);
          let d = a - 2;
          for (; i[d - 1] && i[d - 1].type !== "ordered_list_open" && i[d - 1].type !== "bullet_list_open"; )
            d--;
          e.addAttrs(c, i[d - 1]), i[a].children = i[a].children.slice(0, -2);
        }
      },
      {
        /**
         * - nested list
         *   - with double \n
         *   {.a} <-- apply to nested ul
         *
         * {.b} <-- apply to root <ul>
         */
        name: "list double softbreak",
        tests: [
          {
            // let this token be i = 0 so that we can erase
            // the <p>{.a}</p> tokens below
            shift: 0,
            type: (i) => i === "bullet_list_close" || i === "ordered_list_close"
          },
          {
            shift: 1,
            type: "paragraph_open"
          },
          {
            shift: 2,
            type: "inline",
            content: e.hasDelimiters("only", u),
            children: (i) => i.length === 1
          },
          {
            shift: 3,
            type: "paragraph_close"
          }
        ],
        transform: (i, a) => {
          const s = i[a + 2].content, l = e.getAttrs(s, 0, u), c = e.getMatchingOpeningToken(i, a);
          e.addAttrs(l, c), i.splice(a + 1, 3);
        }
      },
      {
        /**
         * - end of {.list-item}
         */
        name: "list item end",
        tests: [
          {
            shift: -2,
            type: "list_item_open"
          },
          {
            shift: 0,
            type: "inline",
            children: [
              {
                position: -1,
                type: "text",
                content: e.hasDelimiters("end", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = s.content, c = e.getAttrs(l, l.lastIndexOf(u.leftDelimiter), u);
          e.addAttrs(c, i[a - 2]);
          const d = l.slice(0, l.lastIndexOf(u.leftDelimiter));
          s.content = t(d) !== " " ? d : d.slice(0, -1);
        }
      },
      {
        /**
         * something with softbreak
         * {.cls}
         */
        name: `
{.a} softbreak then curly in start`,
        tests: [
          {
            shift: 0,
            type: "inline",
            children: [
              {
                position: -2,
                type: "softbreak"
              },
              {
                position: -1,
                type: "text",
                content: e.hasDelimiters("only", u)
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = e.getAttrs(s.content, 0, u);
          let c = a + 1;
          for (; i[c + 1] && i[c + 1].nesting === -1; )
            c++;
          const d = e.getMatchingOpeningToken(i, c);
          e.addAttrs(l, d), i[a].children = i[a].children.slice(0, -2);
        }
      },
      {
        /**
         * horizontal rule --- {#id}
         */
        name: "horizontal rule",
        tests: [
          {
            shift: 0,
            type: "paragraph_open"
          },
          {
            shift: 1,
            type: "inline",
            children: (i) => i.length === 1,
            content: (i) => i.match(r) !== null
          },
          {
            shift: 2,
            type: "paragraph_close"
          }
        ],
        transform: (i, a) => {
          const o = i[a];
          o.type = "hr", o.tag = "hr", o.nesting = 0;
          const s = i[a + 1].content, l = s.lastIndexOf(u.leftDelimiter), c = e.getAttrs(s, l, u);
          e.addAttrs(c, o), o.markup = s, i.splice(a + 1, 2);
        }
      },
      {
        /**
         * end of {.block}
         */
        name: "end of block",
        tests: [
          {
            shift: 0,
            type: "inline",
            children: [
              {
                position: -1,
                content: e.hasDelimiters("end", u),
                type: (i) => i !== "code_inline" && i !== "math_inline"
              }
            ]
          }
        ],
        /**
         * @param {!number} j
         */
        transform: (i, a, o) => {
          const s = i[a].children[o], l = s.content, c = e.getAttrs(l, l.lastIndexOf(u.leftDelimiter), u);
          let d = a + 1;
          do
            if (i[d] && i[d].nesting === -1)
              break;
          while (d++ < i.length);
          const f = e.getMatchingOpeningToken(i, d);
          e.addAttrs(c, f);
          const p = l.slice(0, l.lastIndexOf(u.leftDelimiter));
          s.content = t(p) !== " " ? p : p.slice(0, -1);
        }
      }
    ];
  };
  function t(u) {
    return u.slice(-1)[0];
  }
  function n(u) {
    u.hidden = !0, u.children && u.children.forEach((r) => (r.content = "", n(r), void 0));
  }
  return Ht;
}
var Ut, du;
function ps() {
  if (du) return Ut;
  du = 1;
  const e = hs(), t = {
    leftDelimiter: "{",
    rightDelimiter: "}",
    allowedAttributes: []
  };
  Ut = function(s, l) {
    let c = Object.assign({}, t);
    c = Object.assign(c, l);
    const d = e(c);
    function f(p) {
      const h = p.tokens;
      for (let g = 0; g < h.length; g++)
        for (let m = 0; m < d.length; m++) {
          const b = d[m];
          let _ = null;
          if (b.tests.every((x) => {
            const C = n(h, g, x);
            return C.j !== null && (_ = C.j), C.match;
          }))
            try {
              b.transform(h, g, _), (b.name === "inline attributes" || b.name === "inline nesting 0") && m--;
            } catch (x) {
              console.error(`markdown-it-attrs: Error in pattern '${b.name}': ${x.message}`), console.error(x.stack);
            }
        }
    }
    s.core.ruler.before("linkify", "curly_attributes", f);
  };
  function n(o, s, l) {
    const c = {
      match: !1,
      j: null
      // position of child
    }, d = l.shift !== void 0 ? s + l.shift : l.position;
    if (l.shift !== void 0 && d < 0)
      return c;
    const f = i(o, d);
    if (f === void 0)
      return c;
    for (const p of Object.keys(l))
      if (!(p === "shift" || p === "position")) {
        if (f[p] === void 0)
          return c;
        if (p === "children" && u(l.children)) {
          if (f.children.length === 0)
            return c;
          let h;
          const g = l.children, m = f.children;
          if (g.every((b) => b.position !== void 0)) {
            if (h = g.every((b) => n(m, b.position, b).match), h) {
              const b = a(g).position;
              c.j = b >= 0 ? b : m.length + b;
            }
          } else
            for (let b = 0; b < m.length; b++)
              if (h = g.every((_) => n(m, b, _).match), h) {
                c.j = b;
                break;
              }
          if (h === !1)
            return c;
          continue;
        }
        switch (typeof l[p]) {
          case "boolean":
          case "number":
          case "string":
            if (f[p] !== l[p])
              return c;
            break;
          case "function":
            if (!l[p](f[p]))
              return c;
            break;
          case "object":
            if (r(l[p])) {
              if (l[p].every((g) => g(f[p])) === !1)
                return c;
              break;
            }
          // fall through for objects !== arrays of functions
          default:
            throw new Error(`Unknown type of pattern test (key: ${p}). Test should be of type boolean, number, string, function or array of functions.`);
        }
      }
    return c.match = !0, c;
  }
  function u(o) {
    return Array.isArray(o) && o.length && o.every((s) => typeof s == "object");
  }
  function r(o) {
    return Array.isArray(o) && o.length && o.every((s) => typeof s == "function");
  }
  function i(o, s) {
    return s >= 0 ? o[s] : o[o.length + s];
  }
  function a(o) {
    return o.slice(-1)[0] || {};
  }
  return Ut;
}
var ms = ps();
const gs = /* @__PURE__ */ ds(ms);
function _s(e, t) {
  return e[t].content;
}
function bs(e, t, n, u, r) {
  const i = e.utils.arrayReplaceAt, a = e.utils.lib.ucmicro, o = e.utils.has, s = new RegExp([a.Z.source, a.P.source, a.Cc.source].join("|"));
  function l(c, d, f) {
    let p = 0;
    const h = [];
    if (c.replace(r, function(g, m, b) {
      let _;
      if (o(n, g)) {
        if (_ = n[g], m > 0 && !s.test(b[m - 1]) || m + g.length < b.length && !s.test(b[m + g.length]))
          return;
      } else
        _ = g.slice(1, -1);
      if (m > p) {
        const x = new f("text", "", 0);
        x.content = c.slice(p, m), h.push(x);
      }
      const y = new f("emoji", "", 0);
      y.markup = _, y.content = t[_], h.push(y), p = m + g.length;
    }), p < c.length) {
      const g = new f("text", "", 0);
      g.content = c.slice(p), h.push(g);
    }
    return h;
  }
  return function(d) {
    let f;
    const p = d.tokens;
    let h = 0;
    for (let g = 0, m = p.length; g < m; g++) {
      if (p[g].type !== "inline")
        continue;
      let b = p[g].children;
      for (let _ = b.length - 1; _ >= 0; _--)
        f = b[_], (f.type === "link_open" || f.type === "link_close") && f.info === "auto" && (h -= f.nesting), f.type === "text" && h === 0 && u.test(f.content) && (p[g].children = b = i(
          b,
          _,
          l(f.content, f.level, d.Token)
        ));
    }
  };
}
function ys(e) {
  return e.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
function ks(e) {
  let t = e.defs;
  e.enabled.length && (t = Object.keys(t).reduce((o, s) => (e.enabled.indexOf(s) >= 0 && (o[s] = t[s]), o), {}));
  const n = Object.keys(e.shortcuts).reduce((o, s) => t[s] ? Array.isArray(e.shortcuts[s]) ? (e.shortcuts[s].forEach((l) => {
    o[l] = s;
  }), o) : (o[e.shortcuts[s]] = s, o) : o, {}), u = Object.keys(t);
  let r;
  u.length === 0 ? r = "^$" : r = u.map((o) => `:${o}:`).concat(Object.keys(n)).sort().reverse().map((o) => ys(o)).join("|");
  const i = RegExp(r), a = RegExp(r, "g");
  return {
    defs: t,
    shortcuts: n,
    scanRE: i,
    replaceRE: a
  };
}
function xs(e, t) {
  const n = {
    defs: {},
    shortcuts: {},
    enabled: []
  }, u = ks(e.utils.assign({}, n, t || {}));
  e.renderer.rules.emoji = _s, e.core.ruler.after(
    "linkify",
    "emoji",
    bs(e, u.defs, u.shortcuts, u.scanRE, u.replaceRE)
  );
}
const ws = {
  angry: [">:(", ">:-("],
  blush: [':")', ':-")'],
  broken_heart: ["</3", "<\\3"],
  // :\ and :-\ not used because of conflict with markdown escaping
  confused: [":/", ":-/"],
  // twemoji shows question
  cry: [":'(", ":'-(", ":,(", ":,-("],
  frowning: [":(", ":-("],
  heart: ["<3"],
  imp: ["]:(", "]:-("],
  innocent: ["o:)", "O:)", "o:-)", "O:-)", "0:)", "0:-)"],
  joy: [":')", ":'-)", ":,)", ":,-)", ":'D", ":'-D", ":,D", ":,-D"],
  kissing: [":*", ":-*"],
  laughing: ["x-)", "X-)"],
  neutral_face: [":|", ":-|"],
  open_mouth: [":o", ":-o", ":O", ":-O"],
  rage: [":@", ":-@"],
  smile: [":D", ":-D"],
  smiley: [":)", ":-)"],
  smiling_imp: ["]:)", "]:-)"],
  sob: [":,'(", ":,'-(", ";(", ";-("],
  stuck_out_tongue: [":P", ":-P"],
  sunglasses: ["8-)", "B-)"],
  sweat: [",:(", ",:-("],
  sweat_smile: [",:)", ",:-)"],
  unamused: [":s", ":-S", ":z", ":-Z", ":$", ":-$"],
  wink: [";)", ";-)"]
}, Cs = {
  100: "ğŸ’¯",
  1234: "ğŸ”¢",
  grinning: "ğŸ˜€",
  smiley: "ğŸ˜ƒ",
  smile: "ğŸ˜„",
  grin: "ğŸ˜",
  laughing: "ğŸ˜†",
  satisfied: "ğŸ˜†",
  sweat_smile: "ğŸ˜…",
  rofl: "ğŸ¤£",
  joy: "ğŸ˜‚",
  slightly_smiling_face: "ğŸ™‚",
  upside_down_face: "ğŸ™ƒ",
  melting_face: "ğŸ« ",
  wink: "ğŸ˜‰",
  blush: "ğŸ˜Š",
  innocent: "ğŸ˜‡",
  smiling_face_with_three_hearts: "ğŸ¥°",
  heart_eyes: "ğŸ˜",
  star_struck: "ğŸ¤©",
  kissing_heart: "ğŸ˜˜",
  kissing: "ğŸ˜—",
  relaxed: "â˜ºï¸",
  kissing_closed_eyes: "ğŸ˜š",
  kissing_smiling_eyes: "ğŸ˜™",
  smiling_face_with_tear: "ğŸ¥²",
  yum: "ğŸ˜‹",
  stuck_out_tongue: "ğŸ˜›",
  stuck_out_tongue_winking_eye: "ğŸ˜œ",
  zany_face: "ğŸ¤ª",
  stuck_out_tongue_closed_eyes: "ğŸ˜",
  money_mouth_face: "ğŸ¤‘",
  hugs: "ğŸ¤—",
  hand_over_mouth: "ğŸ¤­",
  face_with_open_eyes_and_hand_over_mouth: "ğŸ«¢",
  face_with_peeking_eye: "ğŸ«£",
  shushing_face: "ğŸ¤«",
  thinking: "ğŸ¤”",
  saluting_face: "ğŸ«¡",
  zipper_mouth_face: "ğŸ¤",
  raised_eyebrow: "ğŸ¤¨",
  neutral_face: "ğŸ˜",
  expressionless: "ğŸ˜‘",
  no_mouth: "ğŸ˜¶",
  dotted_line_face: "ğŸ«¥",
  face_in_clouds: "ğŸ˜¶â€ğŸŒ«ï¸",
  smirk: "ğŸ˜",
  unamused: "ğŸ˜’",
  roll_eyes: "ğŸ™„",
  grimacing: "ğŸ˜¬",
  face_exhaling: "ğŸ˜®â€ğŸ’¨",
  lying_face: "ğŸ¤¥",
  shaking_face: "ğŸ«¨",
  relieved: "ğŸ˜Œ",
  pensive: "ğŸ˜”",
  sleepy: "ğŸ˜ª",
  drooling_face: "ğŸ¤¤",
  sleeping: "ğŸ˜´",
  mask: "ğŸ˜·",
  face_with_thermometer: "ğŸ¤’",
  face_with_head_bandage: "ğŸ¤•",
  nauseated_face: "ğŸ¤¢",
  vomiting_face: "ğŸ¤®",
  sneezing_face: "ğŸ¤§",
  hot_face: "ğŸ¥µ",
  cold_face: "ğŸ¥¶",
  woozy_face: "ğŸ¥´",
  dizzy_face: "ğŸ˜µ",
  face_with_spiral_eyes: "ğŸ˜µâ€ğŸ’«",
  exploding_head: "ğŸ¤¯",
  cowboy_hat_face: "ğŸ¤ ",
  partying_face: "ğŸ¥³",
  disguised_face: "ğŸ¥¸",
  sunglasses: "ğŸ˜",
  nerd_face: "ğŸ¤“",
  monocle_face: "ğŸ§",
  confused: "ğŸ˜•",
  face_with_diagonal_mouth: "ğŸ«¤",
  worried: "ğŸ˜Ÿ",
  slightly_frowning_face: "ğŸ™",
  frowning_face: "â˜¹ï¸",
  open_mouth: "ğŸ˜®",
  hushed: "ğŸ˜¯",
  astonished: "ğŸ˜²",
  flushed: "ğŸ˜³",
  pleading_face: "ğŸ¥º",
  face_holding_back_tears: "ğŸ¥¹",
  frowning: "ğŸ˜¦",
  anguished: "ğŸ˜§",
  fearful: "ğŸ˜¨",
  cold_sweat: "ğŸ˜°",
  disappointed_relieved: "ğŸ˜¥",
  cry: "ğŸ˜¢",
  sob: "ğŸ˜­",
  scream: "ğŸ˜±",
  confounded: "ğŸ˜–",
  persevere: "ğŸ˜£",
  disappointed: "ğŸ˜",
  sweat: "ğŸ˜“",
  weary: "ğŸ˜©",
  tired_face: "ğŸ˜«",
  yawning_face: "ğŸ¥±",
  triumph: "ğŸ˜¤",
  rage: "ğŸ˜¡",
  pout: "ğŸ˜¡",
  angry: "ğŸ˜ ",
  cursing_face: "ğŸ¤¬",
  smiling_imp: "ğŸ˜ˆ",
  imp: "ğŸ‘¿",
  skull: "ğŸ’€",
  skull_and_crossbones: "â˜ ï¸",
  hankey: "ğŸ’©",
  poop: "ğŸ’©",
  shit: "ğŸ’©",
  clown_face: "ğŸ¤¡",
  japanese_ogre: "ğŸ‘¹",
  japanese_goblin: "ğŸ‘º",
  ghost: "ğŸ‘»",
  alien: "ğŸ‘½",
  space_invader: "ğŸ‘¾",
  robot: "ğŸ¤–",
  smiley_cat: "ğŸ˜º",
  smile_cat: "ğŸ˜¸",
  joy_cat: "ğŸ˜¹",
  heart_eyes_cat: "ğŸ˜»",
  smirk_cat: "ğŸ˜¼",
  kissing_cat: "ğŸ˜½",
  scream_cat: "ğŸ™€",
  crying_cat_face: "ğŸ˜¿",
  pouting_cat: "ğŸ˜¾",
  see_no_evil: "ğŸ™ˆ",
  hear_no_evil: "ğŸ™‰",
  speak_no_evil: "ğŸ™Š",
  love_letter: "ğŸ’Œ",
  cupid: "ğŸ’˜",
  gift_heart: "ğŸ’",
  sparkling_heart: "ğŸ’–",
  heartpulse: "ğŸ’—",
  heartbeat: "ğŸ’“",
  revolving_hearts: "ğŸ’",
  two_hearts: "ğŸ’•",
  heart_decoration: "ğŸ’Ÿ",
  heavy_heart_exclamation: "â£ï¸",
  broken_heart: "ğŸ’”",
  heart_on_fire: "â¤ï¸â€ğŸ”¥",
  mending_heart: "â¤ï¸â€ğŸ©¹",
  heart: "â¤ï¸",
  pink_heart: "ğŸ©·",
  orange_heart: "ğŸ§¡",
  yellow_heart: "ğŸ’›",
  green_heart: "ğŸ’š",
  blue_heart: "ğŸ’™",
  light_blue_heart: "ğŸ©µ",
  purple_heart: "ğŸ’œ",
  brown_heart: "ğŸ¤",
  black_heart: "ğŸ–¤",
  grey_heart: "ğŸ©¶",
  white_heart: "ğŸ¤",
  kiss: "ğŸ’‹",
  anger: "ğŸ’¢",
  boom: "ğŸ’¥",
  collision: "ğŸ’¥",
  dizzy: "ğŸ’«",
  sweat_drops: "ğŸ’¦",
  dash: "ğŸ’¨",
  hole: "ğŸ•³ï¸",
  speech_balloon: "ğŸ’¬",
  eye_speech_bubble: "ğŸ‘ï¸â€ğŸ—¨ï¸",
  left_speech_bubble: "ğŸ—¨ï¸",
  right_anger_bubble: "ğŸ—¯ï¸",
  thought_balloon: "ğŸ’­",
  zzz: "ğŸ’¤",
  wave: "ğŸ‘‹",
  raised_back_of_hand: "ğŸ¤š",
  raised_hand_with_fingers_splayed: "ğŸ–ï¸",
  hand: "âœ‹",
  raised_hand: "âœ‹",
  vulcan_salute: "ğŸ––",
  rightwards_hand: "ğŸ«±",
  leftwards_hand: "ğŸ«²",
  palm_down_hand: "ğŸ«³",
  palm_up_hand: "ğŸ«´",
  leftwards_pushing_hand: "ğŸ«·",
  rightwards_pushing_hand: "ğŸ«¸",
  ok_hand: "ğŸ‘Œ",
  pinched_fingers: "ğŸ¤Œ",
  pinching_hand: "ğŸ¤",
  v: "âœŒï¸",
  crossed_fingers: "ğŸ¤",
  hand_with_index_finger_and_thumb_crossed: "ğŸ«°",
  love_you_gesture: "ğŸ¤Ÿ",
  metal: "ğŸ¤˜",
  call_me_hand: "ğŸ¤™",
  point_left: "ğŸ‘ˆ",
  point_right: "ğŸ‘‰",
  point_up_2: "ğŸ‘†",
  middle_finger: "ğŸ–•",
  fu: "ğŸ–•",
  point_down: "ğŸ‘‡",
  point_up: "â˜ï¸",
  index_pointing_at_the_viewer: "ğŸ«µ",
  "+1": "ğŸ‘",
  thumbsup: "ğŸ‘",
  "-1": "ğŸ‘",
  thumbsdown: "ğŸ‘",
  fist_raised: "âœŠ",
  fist: "âœŠ",
  fist_oncoming: "ğŸ‘Š",
  facepunch: "ğŸ‘Š",
  punch: "ğŸ‘Š",
  fist_left: "ğŸ¤›",
  fist_right: "ğŸ¤œ",
  clap: "ğŸ‘",
  raised_hands: "ğŸ™Œ",
  heart_hands: "ğŸ«¶",
  open_hands: "ğŸ‘",
  palms_up_together: "ğŸ¤²",
  handshake: "ğŸ¤",
  pray: "ğŸ™",
  writing_hand: "âœï¸",
  nail_care: "ğŸ’…",
  selfie: "ğŸ¤³",
  muscle: "ğŸ’ª",
  mechanical_arm: "ğŸ¦¾",
  mechanical_leg: "ğŸ¦¿",
  leg: "ğŸ¦µ",
  foot: "ğŸ¦¶",
  ear: "ğŸ‘‚",
  ear_with_hearing_aid: "ğŸ¦»",
  nose: "ğŸ‘ƒ",
  brain: "ğŸ§ ",
  anatomical_heart: "ğŸ«€",
  lungs: "ğŸ«",
  tooth: "ğŸ¦·",
  bone: "ğŸ¦´",
  eyes: "ğŸ‘€",
  eye: "ğŸ‘ï¸",
  tongue: "ğŸ‘…",
  lips: "ğŸ‘„",
  biting_lip: "ğŸ«¦",
  baby: "ğŸ‘¶",
  child: "ğŸ§’",
  boy: "ğŸ‘¦",
  girl: "ğŸ‘§",
  adult: "ğŸ§‘",
  blond_haired_person: "ğŸ‘±",
  man: "ğŸ‘¨",
  bearded_person: "ğŸ§”",
  man_beard: "ğŸ§”â€â™‚ï¸",
  woman_beard: "ğŸ§”â€â™€ï¸",
  red_haired_man: "ğŸ‘¨â€ğŸ¦°",
  curly_haired_man: "ğŸ‘¨â€ğŸ¦±",
  white_haired_man: "ğŸ‘¨â€ğŸ¦³",
  bald_man: "ğŸ‘¨â€ğŸ¦²",
  woman: "ğŸ‘©",
  red_haired_woman: "ğŸ‘©â€ğŸ¦°",
  person_red_hair: "ğŸ§‘â€ğŸ¦°",
  curly_haired_woman: "ğŸ‘©â€ğŸ¦±",
  person_curly_hair: "ğŸ§‘â€ğŸ¦±",
  white_haired_woman: "ğŸ‘©â€ğŸ¦³",
  person_white_hair: "ğŸ§‘â€ğŸ¦³",
  bald_woman: "ğŸ‘©â€ğŸ¦²",
  person_bald: "ğŸ§‘â€ğŸ¦²",
  blond_haired_woman: "ğŸ‘±â€â™€ï¸",
  blonde_woman: "ğŸ‘±â€â™€ï¸",
  blond_haired_man: "ğŸ‘±â€â™‚ï¸",
  older_adult: "ğŸ§“",
  older_man: "ğŸ‘´",
  older_woman: "ğŸ‘µ",
  frowning_person: "ğŸ™",
  frowning_man: "ğŸ™â€â™‚ï¸",
  frowning_woman: "ğŸ™â€â™€ï¸",
  pouting_face: "ğŸ™",
  pouting_man: "ğŸ™â€â™‚ï¸",
  pouting_woman: "ğŸ™â€â™€ï¸",
  no_good: "ğŸ™…",
  no_good_man: "ğŸ™…â€â™‚ï¸",
  ng_man: "ğŸ™…â€â™‚ï¸",
  no_good_woman: "ğŸ™…â€â™€ï¸",
  ng_woman: "ğŸ™…â€â™€ï¸",
  ok_person: "ğŸ™†",
  ok_man: "ğŸ™†â€â™‚ï¸",
  ok_woman: "ğŸ™†â€â™€ï¸",
  tipping_hand_person: "ğŸ’",
  information_desk_person: "ğŸ’",
  tipping_hand_man: "ğŸ’â€â™‚ï¸",
  sassy_man: "ğŸ’â€â™‚ï¸",
  tipping_hand_woman: "ğŸ’â€â™€ï¸",
  sassy_woman: "ğŸ’â€â™€ï¸",
  raising_hand: "ğŸ™‹",
  raising_hand_man: "ğŸ™‹â€â™‚ï¸",
  raising_hand_woman: "ğŸ™‹â€â™€ï¸",
  deaf_person: "ğŸ§",
  deaf_man: "ğŸ§â€â™‚ï¸",
  deaf_woman: "ğŸ§â€â™€ï¸",
  bow: "ğŸ™‡",
  bowing_man: "ğŸ™‡â€â™‚ï¸",
  bowing_woman: "ğŸ™‡â€â™€ï¸",
  facepalm: "ğŸ¤¦",
  man_facepalming: "ğŸ¤¦â€â™‚ï¸",
  woman_facepalming: "ğŸ¤¦â€â™€ï¸",
  shrug: "ğŸ¤·",
  man_shrugging: "ğŸ¤·â€â™‚ï¸",
  woman_shrugging: "ğŸ¤·â€â™€ï¸",
  health_worker: "ğŸ§‘â€âš•ï¸",
  man_health_worker: "ğŸ‘¨â€âš•ï¸",
  woman_health_worker: "ğŸ‘©â€âš•ï¸",
  student: "ğŸ§‘â€ğŸ“",
  man_student: "ğŸ‘¨â€ğŸ“",
  woman_student: "ğŸ‘©â€ğŸ“",
  teacher: "ğŸ§‘â€ğŸ«",
  man_teacher: "ğŸ‘¨â€ğŸ«",
  woman_teacher: "ğŸ‘©â€ğŸ«",
  judge: "ğŸ§‘â€âš–ï¸",
  man_judge: "ğŸ‘¨â€âš–ï¸",
  woman_judge: "ğŸ‘©â€âš–ï¸",
  farmer: "ğŸ§‘â€ğŸŒ¾",
  man_farmer: "ğŸ‘¨â€ğŸŒ¾",
  woman_farmer: "ğŸ‘©â€ğŸŒ¾",
  cook: "ğŸ§‘â€ğŸ³",
  man_cook: "ğŸ‘¨â€ğŸ³",
  woman_cook: "ğŸ‘©â€ğŸ³",
  mechanic: "ğŸ§‘â€ğŸ”§",
  man_mechanic: "ğŸ‘¨â€ğŸ”§",
  woman_mechanic: "ğŸ‘©â€ğŸ”§",
  factory_worker: "ğŸ§‘â€ğŸ­",
  man_factory_worker: "ğŸ‘¨â€ğŸ­",
  woman_factory_worker: "ğŸ‘©â€ğŸ­",
  office_worker: "ğŸ§‘â€ğŸ’¼",
  man_office_worker: "ğŸ‘¨â€ğŸ’¼",
  woman_office_worker: "ğŸ‘©â€ğŸ’¼",
  scientist: "ğŸ§‘â€ğŸ”¬",
  man_scientist: "ğŸ‘¨â€ğŸ”¬",
  woman_scientist: "ğŸ‘©â€ğŸ”¬",
  technologist: "ğŸ§‘â€ğŸ’»",
  man_technologist: "ğŸ‘¨â€ğŸ’»",
  woman_technologist: "ğŸ‘©â€ğŸ’»",
  singer: "ğŸ§‘â€ğŸ¤",
  man_singer: "ğŸ‘¨â€ğŸ¤",
  woman_singer: "ğŸ‘©â€ğŸ¤",
  artist: "ğŸ§‘â€ğŸ¨",
  man_artist: "ğŸ‘¨â€ğŸ¨",
  woman_artist: "ğŸ‘©â€ğŸ¨",
  pilot: "ğŸ§‘â€âœˆï¸",
  man_pilot: "ğŸ‘¨â€âœˆï¸",
  woman_pilot: "ğŸ‘©â€âœˆï¸",
  astronaut: "ğŸ§‘â€ğŸš€",
  man_astronaut: "ğŸ‘¨â€ğŸš€",
  woman_astronaut: "ğŸ‘©â€ğŸš€",
  firefighter: "ğŸ§‘â€ğŸš’",
  man_firefighter: "ğŸ‘¨â€ğŸš’",
  woman_firefighter: "ğŸ‘©â€ğŸš’",
  police_officer: "ğŸ‘®",
  cop: "ğŸ‘®",
  policeman: "ğŸ‘®â€â™‚ï¸",
  policewoman: "ğŸ‘®â€â™€ï¸",
  detective: "ğŸ•µï¸",
  male_detective: "ğŸ•µï¸â€â™‚ï¸",
  female_detective: "ğŸ•µï¸â€â™€ï¸",
  guard: "ğŸ’‚",
  guardsman: "ğŸ’‚â€â™‚ï¸",
  guardswoman: "ğŸ’‚â€â™€ï¸",
  ninja: "ğŸ¥·",
  construction_worker: "ğŸ‘·",
  construction_worker_man: "ğŸ‘·â€â™‚ï¸",
  construction_worker_woman: "ğŸ‘·â€â™€ï¸",
  person_with_crown: "ğŸ«…",
  prince: "ğŸ¤´",
  princess: "ğŸ‘¸",
  person_with_turban: "ğŸ‘³",
  man_with_turban: "ğŸ‘³â€â™‚ï¸",
  woman_with_turban: "ğŸ‘³â€â™€ï¸",
  man_with_gua_pi_mao: "ğŸ‘²",
  woman_with_headscarf: "ğŸ§•",
  person_in_tuxedo: "ğŸ¤µ",
  man_in_tuxedo: "ğŸ¤µâ€â™‚ï¸",
  woman_in_tuxedo: "ğŸ¤µâ€â™€ï¸",
  person_with_veil: "ğŸ‘°",
  man_with_veil: "ğŸ‘°â€â™‚ï¸",
  woman_with_veil: "ğŸ‘°â€â™€ï¸",
  bride_with_veil: "ğŸ‘°â€â™€ï¸",
  pregnant_woman: "ğŸ¤°",
  pregnant_man: "ğŸ«ƒ",
  pregnant_person: "ğŸ«„",
  breast_feeding: "ğŸ¤±",
  woman_feeding_baby: "ğŸ‘©â€ğŸ¼",
  man_feeding_baby: "ğŸ‘¨â€ğŸ¼",
  person_feeding_baby: "ğŸ§‘â€ğŸ¼",
  angel: "ğŸ‘¼",
  santa: "ğŸ…",
  mrs_claus: "ğŸ¤¶",
  mx_claus: "ğŸ§‘â€ğŸ„",
  superhero: "ğŸ¦¸",
  superhero_man: "ğŸ¦¸â€â™‚ï¸",
  superhero_woman: "ğŸ¦¸â€â™€ï¸",
  supervillain: "ğŸ¦¹",
  supervillain_man: "ğŸ¦¹â€â™‚ï¸",
  supervillain_woman: "ğŸ¦¹â€â™€ï¸",
  mage: "ğŸ§™",
  mage_man: "ğŸ§™â€â™‚ï¸",
  mage_woman: "ğŸ§™â€â™€ï¸",
  fairy: "ğŸ§š",
  fairy_man: "ğŸ§šâ€â™‚ï¸",
  fairy_woman: "ğŸ§šâ€â™€ï¸",
  vampire: "ğŸ§›",
  vampire_man: "ğŸ§›â€â™‚ï¸",
  vampire_woman: "ğŸ§›â€â™€ï¸",
  merperson: "ğŸ§œ",
  merman: "ğŸ§œâ€â™‚ï¸",
  mermaid: "ğŸ§œâ€â™€ï¸",
  elf: "ğŸ§",
  elf_man: "ğŸ§â€â™‚ï¸",
  elf_woman: "ğŸ§â€â™€ï¸",
  genie: "ğŸ§",
  genie_man: "ğŸ§â€â™‚ï¸",
  genie_woman: "ğŸ§â€â™€ï¸",
  zombie: "ğŸ§Ÿ",
  zombie_man: "ğŸ§Ÿâ€â™‚ï¸",
  zombie_woman: "ğŸ§Ÿâ€â™€ï¸",
  troll: "ğŸ§Œ",
  massage: "ğŸ’†",
  massage_man: "ğŸ’†â€â™‚ï¸",
  massage_woman: "ğŸ’†â€â™€ï¸",
  haircut: "ğŸ’‡",
  haircut_man: "ğŸ’‡â€â™‚ï¸",
  haircut_woman: "ğŸ’‡â€â™€ï¸",
  walking: "ğŸš¶",
  walking_man: "ğŸš¶â€â™‚ï¸",
  walking_woman: "ğŸš¶â€â™€ï¸",
  standing_person: "ğŸ§",
  standing_man: "ğŸ§â€â™‚ï¸",
  standing_woman: "ğŸ§â€â™€ï¸",
  kneeling_person: "ğŸ§",
  kneeling_man: "ğŸ§â€â™‚ï¸",
  kneeling_woman: "ğŸ§â€â™€ï¸",
  person_with_probing_cane: "ğŸ§‘â€ğŸ¦¯",
  man_with_probing_cane: "ğŸ‘¨â€ğŸ¦¯",
  woman_with_probing_cane: "ğŸ‘©â€ğŸ¦¯",
  person_in_motorized_wheelchair: "ğŸ§‘â€ğŸ¦¼",
  man_in_motorized_wheelchair: "ğŸ‘¨â€ğŸ¦¼",
  woman_in_motorized_wheelchair: "ğŸ‘©â€ğŸ¦¼",
  person_in_manual_wheelchair: "ğŸ§‘â€ğŸ¦½",
  man_in_manual_wheelchair: "ğŸ‘¨â€ğŸ¦½",
  woman_in_manual_wheelchair: "ğŸ‘©â€ğŸ¦½",
  runner: "ğŸƒ",
  running: "ğŸƒ",
  running_man: "ğŸƒâ€â™‚ï¸",
  running_woman: "ğŸƒâ€â™€ï¸",
  woman_dancing: "ğŸ’ƒ",
  dancer: "ğŸ’ƒ",
  man_dancing: "ğŸ•º",
  business_suit_levitating: "ğŸ•´ï¸",
  dancers: "ğŸ‘¯",
  dancing_men: "ğŸ‘¯â€â™‚ï¸",
  dancing_women: "ğŸ‘¯â€â™€ï¸",
  sauna_person: "ğŸ§–",
  sauna_man: "ğŸ§–â€â™‚ï¸",
  sauna_woman: "ğŸ§–â€â™€ï¸",
  climbing: "ğŸ§—",
  climbing_man: "ğŸ§—â€â™‚ï¸",
  climbing_woman: "ğŸ§—â€â™€ï¸",
  person_fencing: "ğŸ¤º",
  horse_racing: "ğŸ‡",
  skier: "â›·ï¸",
  snowboarder: "ğŸ‚",
  golfing: "ğŸŒï¸",
  golfing_man: "ğŸŒï¸â€â™‚ï¸",
  golfing_woman: "ğŸŒï¸â€â™€ï¸",
  surfer: "ğŸ„",
  surfing_man: "ğŸ„â€â™‚ï¸",
  surfing_woman: "ğŸ„â€â™€ï¸",
  rowboat: "ğŸš£",
  rowing_man: "ğŸš£â€â™‚ï¸",
  rowing_woman: "ğŸš£â€â™€ï¸",
  swimmer: "ğŸŠ",
  swimming_man: "ğŸŠâ€â™‚ï¸",
  swimming_woman: "ğŸŠâ€â™€ï¸",
  bouncing_ball_person: "â›¹ï¸",
  bouncing_ball_man: "â›¹ï¸â€â™‚ï¸",
  basketball_man: "â›¹ï¸â€â™‚ï¸",
  bouncing_ball_woman: "â›¹ï¸â€â™€ï¸",
  basketball_woman: "â›¹ï¸â€â™€ï¸",
  weight_lifting: "ğŸ‹ï¸",
  weight_lifting_man: "ğŸ‹ï¸â€â™‚ï¸",
  weight_lifting_woman: "ğŸ‹ï¸â€â™€ï¸",
  bicyclist: "ğŸš´",
  biking_man: "ğŸš´â€â™‚ï¸",
  biking_woman: "ğŸš´â€â™€ï¸",
  mountain_bicyclist: "ğŸšµ",
  mountain_biking_man: "ğŸšµâ€â™‚ï¸",
  mountain_biking_woman: "ğŸšµâ€â™€ï¸",
  cartwheeling: "ğŸ¤¸",
  man_cartwheeling: "ğŸ¤¸â€â™‚ï¸",
  woman_cartwheeling: "ğŸ¤¸â€â™€ï¸",
  wrestling: "ğŸ¤¼",
  men_wrestling: "ğŸ¤¼â€â™‚ï¸",
  women_wrestling: "ğŸ¤¼â€â™€ï¸",
  water_polo: "ğŸ¤½",
  man_playing_water_polo: "ğŸ¤½â€â™‚ï¸",
  woman_playing_water_polo: "ğŸ¤½â€â™€ï¸",
  handball_person: "ğŸ¤¾",
  man_playing_handball: "ğŸ¤¾â€â™‚ï¸",
  woman_playing_handball: "ğŸ¤¾â€â™€ï¸",
  juggling_person: "ğŸ¤¹",
  man_juggling: "ğŸ¤¹â€â™‚ï¸",
  woman_juggling: "ğŸ¤¹â€â™€ï¸",
  lotus_position: "ğŸ§˜",
  lotus_position_man: "ğŸ§˜â€â™‚ï¸",
  lotus_position_woman: "ğŸ§˜â€â™€ï¸",
  bath: "ğŸ›€",
  sleeping_bed: "ğŸ›Œ",
  people_holding_hands: "ğŸ§‘â€ğŸ¤â€ğŸ§‘",
  two_women_holding_hands: "ğŸ‘­",
  couple: "ğŸ‘«",
  two_men_holding_hands: "ğŸ‘¬",
  couplekiss: "ğŸ’",
  couplekiss_man_woman: "ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨",
  couplekiss_man_man: "ğŸ‘¨â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨",
  couplekiss_woman_woman: "ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘©",
  couple_with_heart: "ğŸ’‘",
  couple_with_heart_woman_man: "ğŸ‘©â€â¤ï¸â€ğŸ‘¨",
  couple_with_heart_man_man: "ğŸ‘¨â€â¤ï¸â€ğŸ‘¨",
  couple_with_heart_woman_woman: "ğŸ‘©â€â¤ï¸â€ğŸ‘©",
  family: "ğŸ‘ª",
  family_man_woman_boy: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦",
  family_man_woman_girl: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§",
  family_man_woman_girl_boy: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦",
  family_man_woman_boy_boy: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦",
  family_man_woman_girl_girl: "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§",
  family_man_man_boy: "ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦",
  family_man_man_girl: "ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§",
  family_man_man_girl_boy: "ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦",
  family_man_man_boy_boy: "ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦",
  family_man_man_girl_girl: "ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘§",
  family_woman_woman_boy: "ğŸ‘©â€ğŸ‘©â€ğŸ‘¦",
  family_woman_woman_girl: "ğŸ‘©â€ğŸ‘©â€ğŸ‘§",
  family_woman_woman_girl_boy: "ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦",
  family_woman_woman_boy_boy: "ğŸ‘©â€ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦",
  family_woman_woman_girl_girl: "ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘§",
  family_man_boy: "ğŸ‘¨â€ğŸ‘¦",
  family_man_boy_boy: "ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦",
  family_man_girl: "ğŸ‘¨â€ğŸ‘§",
  family_man_girl_boy: "ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦",
  family_man_girl_girl: "ğŸ‘¨â€ğŸ‘§â€ğŸ‘§",
  family_woman_boy: "ğŸ‘©â€ğŸ‘¦",
  family_woman_boy_boy: "ğŸ‘©â€ğŸ‘¦â€ğŸ‘¦",
  family_woman_girl: "ğŸ‘©â€ğŸ‘§",
  family_woman_girl_boy: "ğŸ‘©â€ğŸ‘§â€ğŸ‘¦",
  family_woman_girl_girl: "ğŸ‘©â€ğŸ‘§â€ğŸ‘§",
  speaking_head: "ğŸ—£ï¸",
  bust_in_silhouette: "ğŸ‘¤",
  busts_in_silhouette: "ğŸ‘¥",
  people_hugging: "ğŸ«‚",
  footprints: "ğŸ‘£",
  monkey_face: "ğŸµ",
  monkey: "ğŸ’",
  gorilla: "ğŸ¦",
  orangutan: "ğŸ¦§",
  dog: "ğŸ¶",
  dog2: "ğŸ•",
  guide_dog: "ğŸ¦®",
  service_dog: "ğŸ•â€ğŸ¦º",
  poodle: "ğŸ©",
  wolf: "ğŸº",
  fox_face: "ğŸ¦Š",
  raccoon: "ğŸ¦",
  cat: "ğŸ±",
  cat2: "ğŸˆ",
  black_cat: "ğŸˆâ€â¬›",
  lion: "ğŸ¦",
  tiger: "ğŸ¯",
  tiger2: "ğŸ…",
  leopard: "ğŸ†",
  horse: "ğŸ´",
  moose: "ğŸ«",
  donkey: "ğŸ«",
  racehorse: "ğŸ",
  unicorn: "ğŸ¦„",
  zebra: "ğŸ¦“",
  deer: "ğŸ¦Œ",
  bison: "ğŸ¦¬",
  cow: "ğŸ®",
  ox: "ğŸ‚",
  water_buffalo: "ğŸƒ",
  cow2: "ğŸ„",
  pig: "ğŸ·",
  pig2: "ğŸ–",
  boar: "ğŸ—",
  pig_nose: "ğŸ½",
  ram: "ğŸ",
  sheep: "ğŸ‘",
  goat: "ğŸ",
  dromedary_camel: "ğŸª",
  camel: "ğŸ«",
  llama: "ğŸ¦™",
  giraffe: "ğŸ¦’",
  elephant: "ğŸ˜",
  mammoth: "ğŸ¦£",
  rhinoceros: "ğŸ¦",
  hippopotamus: "ğŸ¦›",
  mouse: "ğŸ­",
  mouse2: "ğŸ",
  rat: "ğŸ€",
  hamster: "ğŸ¹",
  rabbit: "ğŸ°",
  rabbit2: "ğŸ‡",
  chipmunk: "ğŸ¿ï¸",
  beaver: "ğŸ¦«",
  hedgehog: "ğŸ¦”",
  bat: "ğŸ¦‡",
  bear: "ğŸ»",
  polar_bear: "ğŸ»â€â„ï¸",
  koala: "ğŸ¨",
  panda_face: "ğŸ¼",
  sloth: "ğŸ¦¥",
  otter: "ğŸ¦¦",
  skunk: "ğŸ¦¨",
  kangaroo: "ğŸ¦˜",
  badger: "ğŸ¦¡",
  feet: "ğŸ¾",
  paw_prints: "ğŸ¾",
  turkey: "ğŸ¦ƒ",
  chicken: "ğŸ”",
  rooster: "ğŸ“",
  hatching_chick: "ğŸ£",
  baby_chick: "ğŸ¤",
  hatched_chick: "ğŸ¥",
  bird: "ğŸ¦",
  penguin: "ğŸ§",
  dove: "ğŸ•Šï¸",
  eagle: "ğŸ¦…",
  duck: "ğŸ¦†",
  swan: "ğŸ¦¢",
  owl: "ğŸ¦‰",
  dodo: "ğŸ¦¤",
  feather: "ğŸª¶",
  flamingo: "ğŸ¦©",
  peacock: "ğŸ¦š",
  parrot: "ğŸ¦œ",
  wing: "ğŸª½",
  black_bird: "ğŸ¦â€â¬›",
  goose: "ğŸª¿",
  frog: "ğŸ¸",
  crocodile: "ğŸŠ",
  turtle: "ğŸ¢",
  lizard: "ğŸ¦",
  snake: "ğŸ",
  dragon_face: "ğŸ²",
  dragon: "ğŸ‰",
  sauropod: "ğŸ¦•",
  "t-rex": "ğŸ¦–",
  whale: "ğŸ³",
  whale2: "ğŸ‹",
  dolphin: "ğŸ¬",
  flipper: "ğŸ¬",
  seal: "ğŸ¦­",
  fish: "ğŸŸ",
  tropical_fish: "ğŸ ",
  blowfish: "ğŸ¡",
  shark: "ğŸ¦ˆ",
  octopus: "ğŸ™",
  shell: "ğŸš",
  coral: "ğŸª¸",
  jellyfish: "ğŸª¼",
  snail: "ğŸŒ",
  butterfly: "ğŸ¦‹",
  bug: "ğŸ›",
  ant: "ğŸœ",
  bee: "ğŸ",
  honeybee: "ğŸ",
  beetle: "ğŸª²",
  lady_beetle: "ğŸ",
  cricket: "ğŸ¦—",
  cockroach: "ğŸª³",
  spider: "ğŸ•·ï¸",
  spider_web: "ğŸ•¸ï¸",
  scorpion: "ğŸ¦‚",
  mosquito: "ğŸ¦Ÿ",
  fly: "ğŸª°",
  worm: "ğŸª±",
  microbe: "ğŸ¦ ",
  bouquet: "ğŸ’",
  cherry_blossom: "ğŸŒ¸",
  white_flower: "ğŸ’®",
  lotus: "ğŸª·",
  rosette: "ğŸµï¸",
  rose: "ğŸŒ¹",
  wilted_flower: "ğŸ¥€",
  hibiscus: "ğŸŒº",
  sunflower: "ğŸŒ»",
  blossom: "ğŸŒ¼",
  tulip: "ğŸŒ·",
  hyacinth: "ğŸª»",
  seedling: "ğŸŒ±",
  potted_plant: "ğŸª´",
  evergreen_tree: "ğŸŒ²",
  deciduous_tree: "ğŸŒ³",
  palm_tree: "ğŸŒ´",
  cactus: "ğŸŒµ",
  ear_of_rice: "ğŸŒ¾",
  herb: "ğŸŒ¿",
  shamrock: "â˜˜ï¸",
  four_leaf_clover: "ğŸ€",
  maple_leaf: "ğŸ",
  fallen_leaf: "ğŸ‚",
  leaves: "ğŸƒ",
  empty_nest: "ğŸª¹",
  nest_with_eggs: "ğŸªº",
  mushroom: "ğŸ„",
  grapes: "ğŸ‡",
  melon: "ğŸˆ",
  watermelon: "ğŸ‰",
  tangerine: "ğŸŠ",
  orange: "ğŸŠ",
  mandarin: "ğŸŠ",
  lemon: "ğŸ‹",
  banana: "ğŸŒ",
  pineapple: "ğŸ",
  mango: "ğŸ¥­",
  apple: "ğŸ",
  green_apple: "ğŸ",
  pear: "ğŸ",
  peach: "ğŸ‘",
  cherries: "ğŸ’",
  strawberry: "ğŸ“",
  blueberries: "ğŸ«",
  kiwi_fruit: "ğŸ¥",
  tomato: "ğŸ…",
  olive: "ğŸ«’",
  coconut: "ğŸ¥¥",
  avocado: "ğŸ¥‘",
  eggplant: "ğŸ†",
  potato: "ğŸ¥”",
  carrot: "ğŸ¥•",
  corn: "ğŸŒ½",
  hot_pepper: "ğŸŒ¶ï¸",
  bell_pepper: "ğŸ«‘",
  cucumber: "ğŸ¥’",
  leafy_green: "ğŸ¥¬",
  broccoli: "ğŸ¥¦",
  garlic: "ğŸ§„",
  onion: "ğŸ§…",
  peanuts: "ğŸ¥œ",
  beans: "ğŸ«˜",
  chestnut: "ğŸŒ°",
  ginger_root: "ğŸ«š",
  pea_pod: "ğŸ«›",
  bread: "ğŸ",
  croissant: "ğŸ¥",
  baguette_bread: "ğŸ¥–",
  flatbread: "ğŸ«“",
  pretzel: "ğŸ¥¨",
  bagel: "ğŸ¥¯",
  pancakes: "ğŸ¥",
  waffle: "ğŸ§‡",
  cheese: "ğŸ§€",
  meat_on_bone: "ğŸ–",
  poultry_leg: "ğŸ—",
  cut_of_meat: "ğŸ¥©",
  bacon: "ğŸ¥“",
  hamburger: "ğŸ”",
  fries: "ğŸŸ",
  pizza: "ğŸ•",
  hotdog: "ğŸŒ­",
  sandwich: "ğŸ¥ª",
  taco: "ğŸŒ®",
  burrito: "ğŸŒ¯",
  tamale: "ğŸ«”",
  stuffed_flatbread: "ğŸ¥™",
  falafel: "ğŸ§†",
  egg: "ğŸ¥š",
  fried_egg: "ğŸ³",
  shallow_pan_of_food: "ğŸ¥˜",
  stew: "ğŸ²",
  fondue: "ğŸ«•",
  bowl_with_spoon: "ğŸ¥£",
  green_salad: "ğŸ¥—",
  popcorn: "ğŸ¿",
  butter: "ğŸ§ˆ",
  salt: "ğŸ§‚",
  canned_food: "ğŸ¥«",
  bento: "ğŸ±",
  rice_cracker: "ğŸ˜",
  rice_ball: "ğŸ™",
  rice: "ğŸš",
  curry: "ğŸ›",
  ramen: "ğŸœ",
  spaghetti: "ğŸ",
  sweet_potato: "ğŸ ",
  oden: "ğŸ¢",
  sushi: "ğŸ£",
  fried_shrimp: "ğŸ¤",
  fish_cake: "ğŸ¥",
  moon_cake: "ğŸ¥®",
  dango: "ğŸ¡",
  dumpling: "ğŸ¥Ÿ",
  fortune_cookie: "ğŸ¥ ",
  takeout_box: "ğŸ¥¡",
  crab: "ğŸ¦€",
  lobster: "ğŸ¦",
  shrimp: "ğŸ¦",
  squid: "ğŸ¦‘",
  oyster: "ğŸ¦ª",
  icecream: "ğŸ¦",
  shaved_ice: "ğŸ§",
  ice_cream: "ğŸ¨",
  doughnut: "ğŸ©",
  cookie: "ğŸª",
  birthday: "ğŸ‚",
  cake: "ğŸ°",
  cupcake: "ğŸ§",
  pie: "ğŸ¥§",
  chocolate_bar: "ğŸ«",
  candy: "ğŸ¬",
  lollipop: "ğŸ­",
  custard: "ğŸ®",
  honey_pot: "ğŸ¯",
  baby_bottle: "ğŸ¼",
  milk_glass: "ğŸ¥›",
  coffee: "â˜•",
  teapot: "ğŸ«–",
  tea: "ğŸµ",
  sake: "ğŸ¶",
  champagne: "ğŸ¾",
  wine_glass: "ğŸ·",
  cocktail: "ğŸ¸",
  tropical_drink: "ğŸ¹",
  beer: "ğŸº",
  beers: "ğŸ»",
  clinking_glasses: "ğŸ¥‚",
  tumbler_glass: "ğŸ¥ƒ",
  pouring_liquid: "ğŸ«—",
  cup_with_straw: "ğŸ¥¤",
  bubble_tea: "ğŸ§‹",
  beverage_box: "ğŸ§ƒ",
  mate: "ğŸ§‰",
  ice_cube: "ğŸ§Š",
  chopsticks: "ğŸ¥¢",
  plate_with_cutlery: "ğŸ½ï¸",
  fork_and_knife: "ğŸ´",
  spoon: "ğŸ¥„",
  hocho: "ğŸ”ª",
  knife: "ğŸ”ª",
  jar: "ğŸ«™",
  amphora: "ğŸº",
  earth_africa: "ğŸŒ",
  earth_americas: "ğŸŒ",
  earth_asia: "ğŸŒ",
  globe_with_meridians: "ğŸŒ",
  world_map: "ğŸ—ºï¸",
  japan: "ğŸ—¾",
  compass: "ğŸ§­",
  mountain_snow: "ğŸ”ï¸",
  mountain: "â›°ï¸",
  volcano: "ğŸŒ‹",
  mount_fuji: "ğŸ—»",
  camping: "ğŸ•ï¸",
  beach_umbrella: "ğŸ–ï¸",
  desert: "ğŸœï¸",
  desert_island: "ğŸï¸",
  national_park: "ğŸï¸",
  stadium: "ğŸŸï¸",
  classical_building: "ğŸ›ï¸",
  building_construction: "ğŸ—ï¸",
  bricks: "ğŸ§±",
  rock: "ğŸª¨",
  wood: "ğŸªµ",
  hut: "ğŸ›–",
  houses: "ğŸ˜ï¸",
  derelict_house: "ğŸšï¸",
  house: "ğŸ ",
  house_with_garden: "ğŸ¡",
  office: "ğŸ¢",
  post_office: "ğŸ£",
  european_post_office: "ğŸ¤",
  hospital: "ğŸ¥",
  bank: "ğŸ¦",
  hotel: "ğŸ¨",
  love_hotel: "ğŸ©",
  convenience_store: "ğŸª",
  school: "ğŸ«",
  department_store: "ğŸ¬",
  factory: "ğŸ­",
  japanese_castle: "ğŸ¯",
  european_castle: "ğŸ°",
  wedding: "ğŸ’’",
  tokyo_tower: "ğŸ—¼",
  statue_of_liberty: "ğŸ—½",
  church: "â›ª",
  mosque: "ğŸ•Œ",
  hindu_temple: "ğŸ›•",
  synagogue: "ğŸ•",
  shinto_shrine: "â›©ï¸",
  kaaba: "ğŸ•‹",
  fountain: "â›²",
  tent: "â›º",
  foggy: "ğŸŒ",
  night_with_stars: "ğŸŒƒ",
  cityscape: "ğŸ™ï¸",
  sunrise_over_mountains: "ğŸŒ„",
  sunrise: "ğŸŒ…",
  city_sunset: "ğŸŒ†",
  city_sunrise: "ğŸŒ‡",
  bridge_at_night: "ğŸŒ‰",
  hotsprings: "â™¨ï¸",
  carousel_horse: "ğŸ ",
  playground_slide: "ğŸ›",
  ferris_wheel: "ğŸ¡",
  roller_coaster: "ğŸ¢",
  barber: "ğŸ’ˆ",
  circus_tent: "ğŸª",
  steam_locomotive: "ğŸš‚",
  railway_car: "ğŸšƒ",
  bullettrain_side: "ğŸš„",
  bullettrain_front: "ğŸš…",
  train2: "ğŸš†",
  metro: "ğŸš‡",
  light_rail: "ğŸšˆ",
  station: "ğŸš‰",
  tram: "ğŸšŠ",
  monorail: "ğŸš",
  mountain_railway: "ğŸš",
  train: "ğŸš‹",
  bus: "ğŸšŒ",
  oncoming_bus: "ğŸš",
  trolleybus: "ğŸš",
  minibus: "ğŸš",
  ambulance: "ğŸš‘",
  fire_engine: "ğŸš’",
  police_car: "ğŸš“",
  oncoming_police_car: "ğŸš”",
  taxi: "ğŸš•",
  oncoming_taxi: "ğŸš–",
  car: "ğŸš—",
  red_car: "ğŸš—",
  oncoming_automobile: "ğŸš˜",
  blue_car: "ğŸš™",
  pickup_truck: "ğŸ›»",
  truck: "ğŸšš",
  articulated_lorry: "ğŸš›",
  tractor: "ğŸšœ",
  racing_car: "ğŸï¸",
  motorcycle: "ğŸï¸",
  motor_scooter: "ğŸ›µ",
  manual_wheelchair: "ğŸ¦½",
  motorized_wheelchair: "ğŸ¦¼",
  auto_rickshaw: "ğŸ›º",
  bike: "ğŸš²",
  kick_scooter: "ğŸ›´",
  skateboard: "ğŸ›¹",
  roller_skate: "ğŸ›¼",
  busstop: "ğŸš",
  motorway: "ğŸ›£ï¸",
  railway_track: "ğŸ›¤ï¸",
  oil_drum: "ğŸ›¢ï¸",
  fuelpump: "â›½",
  wheel: "ğŸ›",
  rotating_light: "ğŸš¨",
  traffic_light: "ğŸš¥",
  vertical_traffic_light: "ğŸš¦",
  stop_sign: "ğŸ›‘",
  construction: "ğŸš§",
  anchor: "âš“",
  ring_buoy: "ğŸ›Ÿ",
  boat: "â›µ",
  sailboat: "â›µ",
  canoe: "ğŸ›¶",
  speedboat: "ğŸš¤",
  passenger_ship: "ğŸ›³ï¸",
  ferry: "â›´ï¸",
  motor_boat: "ğŸ›¥ï¸",
  ship: "ğŸš¢",
  airplane: "âœˆï¸",
  small_airplane: "ğŸ›©ï¸",
  flight_departure: "ğŸ›«",
  flight_arrival: "ğŸ›¬",
  parachute: "ğŸª‚",
  seat: "ğŸ’º",
  helicopter: "ğŸš",
  suspension_railway: "ğŸšŸ",
  mountain_cableway: "ğŸš ",
  aerial_tramway: "ğŸš¡",
  artificial_satellite: "ğŸ›°ï¸",
  rocket: "ğŸš€",
  flying_saucer: "ğŸ›¸",
  bellhop_bell: "ğŸ›ï¸",
  luggage: "ğŸ§³",
  hourglass: "âŒ›",
  hourglass_flowing_sand: "â³",
  watch: "âŒš",
  alarm_clock: "â°",
  stopwatch: "â±ï¸",
  timer_clock: "â²ï¸",
  mantelpiece_clock: "ğŸ•°ï¸",
  clock12: "ğŸ•›",
  clock1230: "ğŸ•§",
  clock1: "ğŸ•",
  clock130: "ğŸ•œ",
  clock2: "ğŸ•‘",
  clock230: "ğŸ•",
  clock3: "ğŸ•’",
  clock330: "ğŸ•",
  clock4: "ğŸ•“",
  clock430: "ğŸ•Ÿ",
  clock5: "ğŸ•”",
  clock530: "ğŸ• ",
  clock6: "ğŸ••",
  clock630: "ğŸ•¡",
  clock7: "ğŸ•–",
  clock730: "ğŸ•¢",
  clock8: "ğŸ•—",
  clock830: "ğŸ•£",
  clock9: "ğŸ•˜",
  clock930: "ğŸ•¤",
  clock10: "ğŸ•™",
  clock1030: "ğŸ•¥",
  clock11: "ğŸ•š",
  clock1130: "ğŸ•¦",
  new_moon: "ğŸŒ‘",
  waxing_crescent_moon: "ğŸŒ’",
  first_quarter_moon: "ğŸŒ“",
  moon: "ğŸŒ”",
  waxing_gibbous_moon: "ğŸŒ”",
  full_moon: "ğŸŒ•",
  waning_gibbous_moon: "ğŸŒ–",
  last_quarter_moon: "ğŸŒ—",
  waning_crescent_moon: "ğŸŒ˜",
  crescent_moon: "ğŸŒ™",
  new_moon_with_face: "ğŸŒš",
  first_quarter_moon_with_face: "ğŸŒ›",
  last_quarter_moon_with_face: "ğŸŒœ",
  thermometer: "ğŸŒ¡ï¸",
  sunny: "â˜€ï¸",
  full_moon_with_face: "ğŸŒ",
  sun_with_face: "ğŸŒ",
  ringed_planet: "ğŸª",
  star: "â­",
  star2: "ğŸŒŸ",
  stars: "ğŸŒ ",
  milky_way: "ğŸŒŒ",
  cloud: "â˜ï¸",
  partly_sunny: "â›…",
  cloud_with_lightning_and_rain: "â›ˆï¸",
  sun_behind_small_cloud: "ğŸŒ¤ï¸",
  sun_behind_large_cloud: "ğŸŒ¥ï¸",
  sun_behind_rain_cloud: "ğŸŒ¦ï¸",
  cloud_with_rain: "ğŸŒ§ï¸",
  cloud_with_snow: "ğŸŒ¨ï¸",
  cloud_with_lightning: "ğŸŒ©ï¸",
  tornado: "ğŸŒªï¸",
  fog: "ğŸŒ«ï¸",
  wind_face: "ğŸŒ¬ï¸",
  cyclone: "ğŸŒ€",
  rainbow: "ğŸŒˆ",
  closed_umbrella: "ğŸŒ‚",
  open_umbrella: "â˜‚ï¸",
  umbrella: "â˜”",
  parasol_on_ground: "â›±ï¸",
  zap: "âš¡",
  snowflake: "â„ï¸",
  snowman_with_snow: "â˜ƒï¸",
  snowman: "â›„",
  comet: "â˜„ï¸",
  fire: "ğŸ”¥",
  droplet: "ğŸ’§",
  ocean: "ğŸŒŠ",
  jack_o_lantern: "ğŸƒ",
  christmas_tree: "ğŸ„",
  fireworks: "ğŸ†",
  sparkler: "ğŸ‡",
  firecracker: "ğŸ§¨",
  sparkles: "âœ¨",
  balloon: "ğŸˆ",
  tada: "ğŸ‰",
  confetti_ball: "ğŸŠ",
  tanabata_tree: "ğŸ‹",
  bamboo: "ğŸ",
  dolls: "ğŸ",
  flags: "ğŸ",
  wind_chime: "ğŸ",
  rice_scene: "ğŸ‘",
  red_envelope: "ğŸ§§",
  ribbon: "ğŸ€",
  gift: "ğŸ",
  reminder_ribbon: "ğŸ—ï¸",
  tickets: "ğŸŸï¸",
  ticket: "ğŸ«",
  medal_military: "ğŸ–ï¸",
  trophy: "ğŸ†",
  medal_sports: "ğŸ…",
  "1st_place_medal": "ğŸ¥‡",
  "2nd_place_medal": "ğŸ¥ˆ",
  "3rd_place_medal": "ğŸ¥‰",
  soccer: "âš½",
  baseball: "âš¾",
  softball: "ğŸ¥",
  basketball: "ğŸ€",
  volleyball: "ğŸ",
  football: "ğŸˆ",
  rugby_football: "ğŸ‰",
  tennis: "ğŸ¾",
  flying_disc: "ğŸ¥",
  bowling: "ğŸ³",
  cricket_game: "ğŸ",
  field_hockey: "ğŸ‘",
  ice_hockey: "ğŸ’",
  lacrosse: "ğŸ¥",
  ping_pong: "ğŸ“",
  badminton: "ğŸ¸",
  boxing_glove: "ğŸ¥Š",
  martial_arts_uniform: "ğŸ¥‹",
  goal_net: "ğŸ¥…",
  golf: "â›³",
  ice_skate: "â›¸ï¸",
  fishing_pole_and_fish: "ğŸ£",
  diving_mask: "ğŸ¤¿",
  running_shirt_with_sash: "ğŸ½",
  ski: "ğŸ¿",
  sled: "ğŸ›·",
  curling_stone: "ğŸ¥Œ",
  dart: "ğŸ¯",
  yo_yo: "ğŸª€",
  kite: "ğŸª",
  gun: "ğŸ”«",
  "8ball": "ğŸ±",
  crystal_ball: "ğŸ”®",
  magic_wand: "ğŸª„",
  video_game: "ğŸ®",
  joystick: "ğŸ•¹ï¸",
  slot_machine: "ğŸ°",
  game_die: "ğŸ²",
  jigsaw: "ğŸ§©",
  teddy_bear: "ğŸ§¸",
  pinata: "ğŸª…",
  mirror_ball: "ğŸª©",
  nesting_dolls: "ğŸª†",
  spades: "â™ ï¸",
  hearts: "â™¥ï¸",
  diamonds: "â™¦ï¸",
  clubs: "â™£ï¸",
  chess_pawn: "â™Ÿï¸",
  black_joker: "ğŸƒ",
  mahjong: "ğŸ€„",
  flower_playing_cards: "ğŸ´",
  performing_arts: "ğŸ­",
  framed_picture: "ğŸ–¼ï¸",
  art: "ğŸ¨",
  thread: "ğŸ§µ",
  sewing_needle: "ğŸª¡",
  yarn: "ğŸ§¶",
  knot: "ğŸª¢",
  eyeglasses: "ğŸ‘“",
  dark_sunglasses: "ğŸ•¶ï¸",
  goggles: "ğŸ¥½",
  lab_coat: "ğŸ¥¼",
  safety_vest: "ğŸ¦º",
  necktie: "ğŸ‘”",
  shirt: "ğŸ‘•",
  tshirt: "ğŸ‘•",
  jeans: "ğŸ‘–",
  scarf: "ğŸ§£",
  gloves: "ğŸ§¤",
  coat: "ğŸ§¥",
  socks: "ğŸ§¦",
  dress: "ğŸ‘—",
  kimono: "ğŸ‘˜",
  sari: "ğŸ¥»",
  one_piece_swimsuit: "ğŸ©±",
  swim_brief: "ğŸ©²",
  shorts: "ğŸ©³",
  bikini: "ğŸ‘™",
  womans_clothes: "ğŸ‘š",
  folding_hand_fan: "ğŸª­",
  purse: "ğŸ‘›",
  handbag: "ğŸ‘œ",
  pouch: "ğŸ‘",
  shopping: "ğŸ›ï¸",
  school_satchel: "ğŸ’",
  thong_sandal: "ğŸ©´",
  mans_shoe: "ğŸ‘",
  shoe: "ğŸ‘",
  athletic_shoe: "ğŸ‘Ÿ",
  hiking_boot: "ğŸ¥¾",
  flat_shoe: "ğŸ¥¿",
  high_heel: "ğŸ‘ ",
  sandal: "ğŸ‘¡",
  ballet_shoes: "ğŸ©°",
  boot: "ğŸ‘¢",
  hair_pick: "ğŸª®",
  crown: "ğŸ‘‘",
  womans_hat: "ğŸ‘’",
  tophat: "ğŸ©",
  mortar_board: "ğŸ“",
  billed_cap: "ğŸ§¢",
  military_helmet: "ğŸª–",
  rescue_worker_helmet: "â›‘ï¸",
  prayer_beads: "ğŸ“¿",
  lipstick: "ğŸ’„",
  ring: "ğŸ’",
  gem: "ğŸ’",
  mute: "ğŸ”‡",
  speaker: "ğŸ”ˆ",
  sound: "ğŸ”‰",
  loud_sound: "ğŸ”Š",
  loudspeaker: "ğŸ“¢",
  mega: "ğŸ“£",
  postal_horn: "ğŸ“¯",
  bell: "ğŸ””",
  no_bell: "ğŸ”•",
  musical_score: "ğŸ¼",
  musical_note: "ğŸµ",
  notes: "ğŸ¶",
  studio_microphone: "ğŸ™ï¸",
  level_slider: "ğŸšï¸",
  control_knobs: "ğŸ›ï¸",
  microphone: "ğŸ¤",
  headphones: "ğŸ§",
  radio: "ğŸ“»",
  saxophone: "ğŸ·",
  accordion: "ğŸª—",
  guitar: "ğŸ¸",
  musical_keyboard: "ğŸ¹",
  trumpet: "ğŸº",
  violin: "ğŸ»",
  banjo: "ğŸª•",
  drum: "ğŸ¥",
  long_drum: "ğŸª˜",
  maracas: "ğŸª‡",
  flute: "ğŸªˆ",
  iphone: "ğŸ“±",
  calling: "ğŸ“²",
  phone: "â˜ï¸",
  telephone: "â˜ï¸",
  telephone_receiver: "ğŸ“",
  pager: "ğŸ“Ÿ",
  fax: "ğŸ“ ",
  battery: "ğŸ”‹",
  low_battery: "ğŸª«",
  electric_plug: "ğŸ”Œ",
  computer: "ğŸ’»",
  desktop_computer: "ğŸ–¥ï¸",
  printer: "ğŸ–¨ï¸",
  keyboard: "âŒ¨ï¸",
  computer_mouse: "ğŸ–±ï¸",
  trackball: "ğŸ–²ï¸",
  minidisc: "ğŸ’½",
  floppy_disk: "ğŸ’¾",
  cd: "ğŸ’¿",
  dvd: "ğŸ“€",
  abacus: "ğŸ§®",
  movie_camera: "ğŸ¥",
  film_strip: "ğŸï¸",
  film_projector: "ğŸ“½ï¸",
  clapper: "ğŸ¬",
  tv: "ğŸ“º",
  camera: "ğŸ“·",
  camera_flash: "ğŸ“¸",
  video_camera: "ğŸ“¹",
  vhs: "ğŸ“¼",
  mag: "ğŸ”",
  mag_right: "ğŸ”",
  candle: "ğŸ•¯ï¸",
  bulb: "ğŸ’¡",
  flashlight: "ğŸ”¦",
  izakaya_lantern: "ğŸ®",
  lantern: "ğŸ®",
  diya_lamp: "ğŸª”",
  notebook_with_decorative_cover: "ğŸ“”",
  closed_book: "ğŸ“•",
  book: "ğŸ“–",
  open_book: "ğŸ“–",
  green_book: "ğŸ“—",
  blue_book: "ğŸ“˜",
  orange_book: "ğŸ“™",
  books: "ğŸ“š",
  notebook: "ğŸ““",
  ledger: "ğŸ“’",
  page_with_curl: "ğŸ“ƒ",
  scroll: "ğŸ“œ",
  page_facing_up: "ğŸ“„",
  newspaper: "ğŸ“°",
  newspaper_roll: "ğŸ—ï¸",
  bookmark_tabs: "ğŸ“‘",
  bookmark: "ğŸ”–",
  label: "ğŸ·ï¸",
  moneybag: "ğŸ’°",
  coin: "ğŸª™",
  yen: "ğŸ’´",
  dollar: "ğŸ’µ",
  euro: "ğŸ’¶",
  pound: "ğŸ’·",
  money_with_wings: "ğŸ’¸",
  credit_card: "ğŸ’³",
  receipt: "ğŸ§¾",
  chart: "ğŸ’¹",
  envelope: "âœ‰ï¸",
  email: "ğŸ“§",
  "e-mail": "ğŸ“§",
  incoming_envelope: "ğŸ“¨",
  envelope_with_arrow: "ğŸ“©",
  outbox_tray: "ğŸ“¤",
  inbox_tray: "ğŸ“¥",
  package: "ğŸ“¦",
  mailbox: "ğŸ“«",
  mailbox_closed: "ğŸ“ª",
  mailbox_with_mail: "ğŸ“¬",
  mailbox_with_no_mail: "ğŸ“­",
  postbox: "ğŸ“®",
  ballot_box: "ğŸ—³ï¸",
  pencil2: "âœï¸",
  black_nib: "âœ’ï¸",
  fountain_pen: "ğŸ–‹ï¸",
  pen: "ğŸ–Šï¸",
  paintbrush: "ğŸ–Œï¸",
  crayon: "ğŸ–ï¸",
  memo: "ğŸ“",
  pencil: "ğŸ“",
  briefcase: "ğŸ’¼",
  file_folder: "ğŸ“",
  open_file_folder: "ğŸ“‚",
  card_index_dividers: "ğŸ—‚ï¸",
  date: "ğŸ“…",
  calendar: "ğŸ“†",
  spiral_notepad: "ğŸ—’ï¸",
  spiral_calendar: "ğŸ—“ï¸",
  card_index: "ğŸ“‡",
  chart_with_upwards_trend: "ğŸ“ˆ",
  chart_with_downwards_trend: "ğŸ“‰",
  bar_chart: "ğŸ“Š",
  clipboard: "ğŸ“‹",
  pushpin: "ğŸ“Œ",
  round_pushpin: "ğŸ“",
  paperclip: "ğŸ“",
  paperclips: "ğŸ–‡ï¸",
  straight_ruler: "ğŸ“",
  triangular_ruler: "ğŸ“",
  scissors: "âœ‚ï¸",
  card_file_box: "ğŸ—ƒï¸",
  file_cabinet: "ğŸ—„ï¸",
  wastebasket: "ğŸ—‘ï¸",
  lock: "ğŸ”’",
  unlock: "ğŸ”“",
  lock_with_ink_pen: "ğŸ”",
  closed_lock_with_key: "ğŸ”",
  key: "ğŸ”‘",
  old_key: "ğŸ—ï¸",
  hammer: "ğŸ”¨",
  axe: "ğŸª“",
  pick: "â›ï¸",
  hammer_and_pick: "âš’ï¸",
  hammer_and_wrench: "ğŸ› ï¸",
  dagger: "ğŸ—¡ï¸",
  crossed_swords: "âš”ï¸",
  bomb: "ğŸ’£",
  boomerang: "ğŸªƒ",
  bow_and_arrow: "ğŸ¹",
  shield: "ğŸ›¡ï¸",
  carpentry_saw: "ğŸªš",
  wrench: "ğŸ”§",
  screwdriver: "ğŸª›",
  nut_and_bolt: "ğŸ”©",
  gear: "âš™ï¸",
  clamp: "ğŸ—œï¸",
  balance_scale: "âš–ï¸",
  probing_cane: "ğŸ¦¯",
  link: "ğŸ”—",
  chains: "â›“ï¸",
  hook: "ğŸª",
  toolbox: "ğŸ§°",
  magnet: "ğŸ§²",
  ladder: "ğŸªœ",
  alembic: "âš—ï¸",
  test_tube: "ğŸ§ª",
  petri_dish: "ğŸ§«",
  dna: "ğŸ§¬",
  microscope: "ğŸ”¬",
  telescope: "ğŸ”­",
  satellite: "ğŸ“¡",
  syringe: "ğŸ’‰",
  drop_of_blood: "ğŸ©¸",
  pill: "ğŸ’Š",
  adhesive_bandage: "ğŸ©¹",
  crutch: "ğŸ©¼",
  stethoscope: "ğŸ©º",
  x_ray: "ğŸ©»",
  door: "ğŸšª",
  elevator: "ğŸ›—",
  mirror: "ğŸª",
  window: "ğŸªŸ",
  bed: "ğŸ›ï¸",
  couch_and_lamp: "ğŸ›‹ï¸",
  chair: "ğŸª‘",
  toilet: "ğŸš½",
  plunger: "ğŸª ",
  shower: "ğŸš¿",
  bathtub: "ğŸ›",
  mouse_trap: "ğŸª¤",
  razor: "ğŸª’",
  lotion_bottle: "ğŸ§´",
  safety_pin: "ğŸ§·",
  broom: "ğŸ§¹",
  basket: "ğŸ§º",
  roll_of_paper: "ğŸ§»",
  bucket: "ğŸª£",
  soap: "ğŸ§¼",
  bubbles: "ğŸ«§",
  toothbrush: "ğŸª¥",
  sponge: "ğŸ§½",
  fire_extinguisher: "ğŸ§¯",
  shopping_cart: "ğŸ›’",
  smoking: "ğŸš¬",
  coffin: "âš°ï¸",
  headstone: "ğŸª¦",
  funeral_urn: "âš±ï¸",
  nazar_amulet: "ğŸ§¿",
  hamsa: "ğŸª¬",
  moyai: "ğŸ—¿",
  placard: "ğŸª§",
  identification_card: "ğŸªª",
  atm: "ğŸ§",
  put_litter_in_its_place: "ğŸš®",
  potable_water: "ğŸš°",
  wheelchair: "â™¿",
  mens: "ğŸš¹",
  womens: "ğŸšº",
  restroom: "ğŸš»",
  baby_symbol: "ğŸš¼",
  wc: "ğŸš¾",
  passport_control: "ğŸ›‚",
  customs: "ğŸ›ƒ",
  baggage_claim: "ğŸ›„",
  left_luggage: "ğŸ›…",
  warning: "âš ï¸",
  children_crossing: "ğŸš¸",
  no_entry: "â›”",
  no_entry_sign: "ğŸš«",
  no_bicycles: "ğŸš³",
  no_smoking: "ğŸš­",
  do_not_litter: "ğŸš¯",
  "non-potable_water": "ğŸš±",
  no_pedestrians: "ğŸš·",
  no_mobile_phones: "ğŸ“µ",
  underage: "ğŸ”",
  radioactive: "â˜¢ï¸",
  biohazard: "â˜£ï¸",
  arrow_up: "â¬†ï¸",
  arrow_upper_right: "â†—ï¸",
  arrow_right: "â¡ï¸",
  arrow_lower_right: "â†˜ï¸",
  arrow_down: "â¬‡ï¸",
  arrow_lower_left: "â†™ï¸",
  arrow_left: "â¬…ï¸",
  arrow_upper_left: "â†–ï¸",
  arrow_up_down: "â†•ï¸",
  left_right_arrow: "â†”ï¸",
  leftwards_arrow_with_hook: "â†©ï¸",
  arrow_right_hook: "â†ªï¸",
  arrow_heading_up: "â¤´ï¸",
  arrow_heading_down: "â¤µï¸",
  arrows_clockwise: "ğŸ”ƒ",
  arrows_counterclockwise: "ğŸ”„",
  back: "ğŸ”™",
  end: "ğŸ”š",
  on: "ğŸ”›",
  soon: "ğŸ”œ",
  top: "ğŸ”",
  place_of_worship: "ğŸ›",
  atom_symbol: "âš›ï¸",
  om: "ğŸ•‰ï¸",
  star_of_david: "âœ¡ï¸",
  wheel_of_dharma: "â˜¸ï¸",
  yin_yang: "â˜¯ï¸",
  latin_cross: "âœï¸",
  orthodox_cross: "â˜¦ï¸",
  star_and_crescent: "â˜ªï¸",
  peace_symbol: "â˜®ï¸",
  menorah: "ğŸ•",
  six_pointed_star: "ğŸ”¯",
  khanda: "ğŸª¯",
  aries: "â™ˆ",
  taurus: "â™‰",
  gemini: "â™Š",
  cancer: "â™‹",
  leo: "â™Œ",
  virgo: "â™",
  libra: "â™",
  scorpius: "â™",
  sagittarius: "â™",
  capricorn: "â™‘",
  aquarius: "â™’",
  pisces: "â™“",
  ophiuchus: "â›",
  twisted_rightwards_arrows: "ğŸ”€",
  repeat: "ğŸ”",
  repeat_one: "ğŸ”‚",
  arrow_forward: "â–¶ï¸",
  fast_forward: "â©",
  next_track_button: "â­ï¸",
  play_or_pause_button: "â¯ï¸",
  arrow_backward: "â—€ï¸",
  rewind: "âª",
  previous_track_button: "â®ï¸",
  arrow_up_small: "ğŸ”¼",
  arrow_double_up: "â«",
  arrow_down_small: "ğŸ”½",
  arrow_double_down: "â¬",
  pause_button: "â¸ï¸",
  stop_button: "â¹ï¸",
  record_button: "âºï¸",
  eject_button: "âï¸",
  cinema: "ğŸ¦",
  low_brightness: "ğŸ”…",
  high_brightness: "ğŸ”†",
  signal_strength: "ğŸ“¶",
  wireless: "ğŸ›œ",
  vibration_mode: "ğŸ“³",
  mobile_phone_off: "ğŸ“´",
  female_sign: "â™€ï¸",
  male_sign: "â™‚ï¸",
  transgender_symbol: "âš§ï¸",
  heavy_multiplication_x: "âœ–ï¸",
  heavy_plus_sign: "â•",
  heavy_minus_sign: "â–",
  heavy_division_sign: "â—",
  heavy_equals_sign: "ğŸŸ°",
  infinity: "â™¾ï¸",
  bangbang: "â€¼ï¸",
  interrobang: "â‰ï¸",
  question: "â“",
  grey_question: "â”",
  grey_exclamation: "â•",
  exclamation: "â—",
  heavy_exclamation_mark: "â—",
  wavy_dash: "ã€°ï¸",
  currency_exchange: "ğŸ’±",
  heavy_dollar_sign: "ğŸ’²",
  medical_symbol: "âš•ï¸",
  recycle: "â™»ï¸",
  fleur_de_lis: "âšœï¸",
  trident: "ğŸ”±",
  name_badge: "ğŸ“›",
  beginner: "ğŸ”°",
  o: "â­•",
  white_check_mark: "âœ…",
  ballot_box_with_check: "â˜‘ï¸",
  heavy_check_mark: "âœ”ï¸",
  x: "âŒ",
  negative_squared_cross_mark: "â",
  curly_loop: "â°",
  loop: "â¿",
  part_alternation_mark: "ã€½ï¸",
  eight_spoked_asterisk: "âœ³ï¸",
  eight_pointed_black_star: "âœ´ï¸",
  sparkle: "â‡ï¸",
  copyright: "Â©ï¸",
  registered: "Â®ï¸",
  tm: "â„¢ï¸",
  hash: "#ï¸âƒ£",
  asterisk: "*ï¸âƒ£",
  zero: "0ï¸âƒ£",
  one: "1ï¸âƒ£",
  two: "2ï¸âƒ£",
  three: "3ï¸âƒ£",
  four: "4ï¸âƒ£",
  five: "5ï¸âƒ£",
  six: "6ï¸âƒ£",
  seven: "7ï¸âƒ£",
  eight: "8ï¸âƒ£",
  nine: "9ï¸âƒ£",
  keycap_ten: "ğŸ”Ÿ",
  capital_abcd: "ğŸ” ",
  abcd: "ğŸ”¡",
  symbols: "ğŸ”£",
  abc: "ğŸ”¤",
  a: "ğŸ…°ï¸",
  ab: "ğŸ†",
  b: "ğŸ…±ï¸",
  cl: "ğŸ†‘",
  cool: "ğŸ†’",
  free: "ğŸ†“",
  information_source: "â„¹ï¸",
  id: "ğŸ†”",
  m: "â“‚ï¸",
  new: "ğŸ†•",
  ng: "ğŸ†–",
  o2: "ğŸ…¾ï¸",
  ok: "ğŸ†—",
  parking: "ğŸ…¿ï¸",
  sos: "ğŸ†˜",
  up: "ğŸ†™",
  vs: "ğŸ†š",
  koko: "ğŸˆ",
  sa: "ğŸˆ‚ï¸",
  ideograph_advantage: "ğŸ‰",
  accept: "ğŸ‰‘",
  congratulations: "ãŠ—ï¸",
  secret: "ãŠ™ï¸",
  u6e80: "ğŸˆµ",
  red_circle: "ğŸ”´",
  orange_circle: "ğŸŸ ",
  yellow_circle: "ğŸŸ¡",
  green_circle: "ğŸŸ¢",
  large_blue_circle: "ğŸ”µ",
  purple_circle: "ğŸŸ£",
  brown_circle: "ğŸŸ¤",
  black_circle: "âš«",
  white_circle: "âšª",
  red_square: "ğŸŸ¥",
  orange_square: "ğŸŸ§",
  yellow_square: "ğŸŸ¨",
  green_square: "ğŸŸ©",
  blue_square: "ğŸŸ¦",
  purple_square: "ğŸŸª",
  brown_square: "ğŸŸ«",
  black_large_square: "â¬›",
  white_large_square: "â¬œ",
  black_medium_square: "â—¼ï¸",
  white_medium_square: "â—»ï¸",
  black_medium_small_square: "â—¾",
  white_medium_small_square: "â—½",
  black_small_square: "â–ªï¸",
  white_small_square: "â–«ï¸",
  large_orange_diamond: "ğŸ”¶",
  large_blue_diamond: "ğŸ”·",
  small_orange_diamond: "ğŸ”¸",
  small_blue_diamond: "ğŸ”¹",
  small_red_triangle: "ğŸ”º",
  small_red_triangle_down: "ğŸ”»",
  diamond_shape_with_a_dot_inside: "ğŸ’ ",
  radio_button: "ğŸ”˜",
  white_square_button: "ğŸ”³",
  black_square_button: "ğŸ”²",
  checkered_flag: "ğŸ",
  triangular_flag_on_post: "ğŸš©",
  crossed_flags: "ğŸŒ",
  black_flag: "ğŸ´",
  white_flag: "ğŸ³ï¸",
  rainbow_flag: "ğŸ³ï¸â€ğŸŒˆ",
  transgender_flag: "ğŸ³ï¸â€âš§ï¸",
  pirate_flag: "ğŸ´â€â˜ ï¸",
  ascension_island: "ğŸ‡¦ğŸ‡¨",
  andorra: "ğŸ‡¦ğŸ‡©",
  united_arab_emirates: "ğŸ‡¦ğŸ‡ª",
  afghanistan: "ğŸ‡¦ğŸ‡«",
  antigua_barbuda: "ğŸ‡¦ğŸ‡¬",
  anguilla: "ğŸ‡¦ğŸ‡®",
  albania: "ğŸ‡¦ğŸ‡±",
  armenia: "ğŸ‡¦ğŸ‡²",
  angola: "ğŸ‡¦ğŸ‡´",
  antarctica: "ğŸ‡¦ğŸ‡¶",
  argentina: "ğŸ‡¦ğŸ‡·",
  american_samoa: "ğŸ‡¦ğŸ‡¸",
  austria: "ğŸ‡¦ğŸ‡¹",
  australia: "ğŸ‡¦ğŸ‡º",
  aruba: "ğŸ‡¦ğŸ‡¼",
  aland_islands: "ğŸ‡¦ğŸ‡½",
  azerbaijan: "ğŸ‡¦ğŸ‡¿",
  bosnia_herzegovina: "ğŸ‡§ğŸ‡¦",
  barbados: "ğŸ‡§ğŸ‡§",
  bangladesh: "ğŸ‡§ğŸ‡©",
  belgium: "ğŸ‡§ğŸ‡ª",
  burkina_faso: "ğŸ‡§ğŸ‡«",
  bulgaria: "ğŸ‡§ğŸ‡¬",
  bahrain: "ğŸ‡§ğŸ‡­",
  burundi: "ğŸ‡§ğŸ‡®",
  benin: "ğŸ‡§ğŸ‡¯",
  st_barthelemy: "ğŸ‡§ğŸ‡±",
  bermuda: "ğŸ‡§ğŸ‡²",
  brunei: "ğŸ‡§ğŸ‡³",
  bolivia: "ğŸ‡§ğŸ‡´",
  caribbean_netherlands: "ğŸ‡§ğŸ‡¶",
  brazil: "ğŸ‡§ğŸ‡·",
  bahamas: "ğŸ‡§ğŸ‡¸",
  bhutan: "ğŸ‡§ğŸ‡¹",
  bouvet_island: "ğŸ‡§ğŸ‡»",
  botswana: "ğŸ‡§ğŸ‡¼",
  belarus: "ğŸ‡§ğŸ‡¾",
  belize: "ğŸ‡§ğŸ‡¿",
  canada: "ğŸ‡¨ğŸ‡¦",
  cocos_islands: "ğŸ‡¨ğŸ‡¨",
  congo_kinshasa: "ğŸ‡¨ğŸ‡©",
  central_african_republic: "ğŸ‡¨ğŸ‡«",
  congo_brazzaville: "ğŸ‡¨ğŸ‡¬",
  switzerland: "ğŸ‡¨ğŸ‡­",
  cote_divoire: "ğŸ‡¨ğŸ‡®",
  cook_islands: "ğŸ‡¨ğŸ‡°",
  chile: "ğŸ‡¨ğŸ‡±",
  cameroon: "ğŸ‡¨ğŸ‡²",
  cn: "ğŸ‡¨ğŸ‡³",
  colombia: "ğŸ‡¨ğŸ‡´",
  clipperton_island: "ğŸ‡¨ğŸ‡µ",
  costa_rica: "ğŸ‡¨ğŸ‡·",
  cuba: "ğŸ‡¨ğŸ‡º",
  cape_verde: "ğŸ‡¨ğŸ‡»",
  curacao: "ğŸ‡¨ğŸ‡¼",
  christmas_island: "ğŸ‡¨ğŸ‡½",
  cyprus: "ğŸ‡¨ğŸ‡¾",
  czech_republic: "ğŸ‡¨ğŸ‡¿",
  de: "ğŸ‡©ğŸ‡ª",
  diego_garcia: "ğŸ‡©ğŸ‡¬",
  djibouti: "ğŸ‡©ğŸ‡¯",
  denmark: "ğŸ‡©ğŸ‡°",
  dominica: "ğŸ‡©ğŸ‡²",
  dominican_republic: "ğŸ‡©ğŸ‡´",
  algeria: "ğŸ‡©ğŸ‡¿",
  ceuta_melilla: "ğŸ‡ªğŸ‡¦",
  ecuador: "ğŸ‡ªğŸ‡¨",
  estonia: "ğŸ‡ªğŸ‡ª",
  egypt: "ğŸ‡ªğŸ‡¬",
  western_sahara: "ğŸ‡ªğŸ‡­",
  eritrea: "ğŸ‡ªğŸ‡·",
  es: "ğŸ‡ªğŸ‡¸",
  ethiopia: "ğŸ‡ªğŸ‡¹",
  eu: "ğŸ‡ªğŸ‡º",
  european_union: "ğŸ‡ªğŸ‡º",
  finland: "ğŸ‡«ğŸ‡®",
  fiji: "ğŸ‡«ğŸ‡¯",
  falkland_islands: "ğŸ‡«ğŸ‡°",
  micronesia: "ğŸ‡«ğŸ‡²",
  faroe_islands: "ğŸ‡«ğŸ‡´",
  fr: "ğŸ‡«ğŸ‡·",
  gabon: "ğŸ‡¬ğŸ‡¦",
  gb: "ğŸ‡¬ğŸ‡§",
  uk: "ğŸ‡¬ğŸ‡§",
  grenada: "ğŸ‡¬ğŸ‡©",
  georgia: "ğŸ‡¬ğŸ‡ª",
  french_guiana: "ğŸ‡¬ğŸ‡«",
  guernsey: "ğŸ‡¬ğŸ‡¬",
  ghana: "ğŸ‡¬ğŸ‡­",
  gibraltar: "ğŸ‡¬ğŸ‡®",
  greenland: "ğŸ‡¬ğŸ‡±",
  gambia: "ğŸ‡¬ğŸ‡²",
  guinea: "ğŸ‡¬ğŸ‡³",
  guadeloupe: "ğŸ‡¬ğŸ‡µ",
  equatorial_guinea: "ğŸ‡¬ğŸ‡¶",
  greece: "ğŸ‡¬ğŸ‡·",
  south_georgia_south_sandwich_islands: "ğŸ‡¬ğŸ‡¸",
  guatemala: "ğŸ‡¬ğŸ‡¹",
  guam: "ğŸ‡¬ğŸ‡º",
  guinea_bissau: "ğŸ‡¬ğŸ‡¼",
  guyana: "ğŸ‡¬ğŸ‡¾",
  hong_kong: "ğŸ‡­ğŸ‡°",
  heard_mcdonald_islands: "ğŸ‡­ğŸ‡²",
  honduras: "ğŸ‡­ğŸ‡³",
  croatia: "ğŸ‡­ğŸ‡·",
  haiti: "ğŸ‡­ğŸ‡¹",
  hungary: "ğŸ‡­ğŸ‡º",
  canary_islands: "ğŸ‡®ğŸ‡¨",
  indonesia: "ğŸ‡®ğŸ‡©",
  ireland: "ğŸ‡®ğŸ‡ª",
  israel: "ğŸ‡®ğŸ‡±",
  isle_of_man: "ğŸ‡®ğŸ‡²",
  india: "ğŸ‡®ğŸ‡³",
  british_indian_ocean_territory: "ğŸ‡®ğŸ‡´",
  iraq: "ğŸ‡®ğŸ‡¶",
  iran: "ğŸ‡®ğŸ‡·",
  iceland: "ğŸ‡®ğŸ‡¸",
  it: "ğŸ‡®ğŸ‡¹",
  jersey: "ğŸ‡¯ğŸ‡ª",
  jamaica: "ğŸ‡¯ğŸ‡²",
  jordan: "ğŸ‡¯ğŸ‡´",
  jp: "ğŸ‡¯ğŸ‡µ",
  kenya: "ğŸ‡°ğŸ‡ª",
  kyrgyzstan: "ğŸ‡°ğŸ‡¬",
  cambodia: "ğŸ‡°ğŸ‡­",
  kiribati: "ğŸ‡°ğŸ‡®",
  comoros: "ğŸ‡°ğŸ‡²",
  st_kitts_nevis: "ğŸ‡°ğŸ‡³",
  north_korea: "ğŸ‡°ğŸ‡µ",
  kr: "ğŸ‡°ğŸ‡·",
  kuwait: "ğŸ‡°ğŸ‡¼",
  cayman_islands: "ğŸ‡°ğŸ‡¾",
  kazakhstan: "ğŸ‡°ğŸ‡¿",
  laos: "ğŸ‡±ğŸ‡¦",
  lebanon: "ğŸ‡±ğŸ‡§",
  st_lucia: "ğŸ‡±ğŸ‡¨",
  liechtenstein: "ğŸ‡±ğŸ‡®",
  sri_lanka: "ğŸ‡±ğŸ‡°",
  liberia: "ğŸ‡±ğŸ‡·",
  lesotho: "ğŸ‡±ğŸ‡¸",
  lithuania: "ğŸ‡±ğŸ‡¹",
  luxembourg: "ğŸ‡±ğŸ‡º",
  latvia: "ğŸ‡±ğŸ‡»",
  libya: "ğŸ‡±ğŸ‡¾",
  morocco: "ğŸ‡²ğŸ‡¦",
  monaco: "ğŸ‡²ğŸ‡¨",
  moldova: "ğŸ‡²ğŸ‡©",
  montenegro: "ğŸ‡²ğŸ‡ª",
  st_martin: "ğŸ‡²ğŸ‡«",
  madagascar: "ğŸ‡²ğŸ‡¬",
  marshall_islands: "ğŸ‡²ğŸ‡­",
  macedonia: "ğŸ‡²ğŸ‡°",
  mali: "ğŸ‡²ğŸ‡±",
  myanmar: "ğŸ‡²ğŸ‡²",
  mongolia: "ğŸ‡²ğŸ‡³",
  macau: "ğŸ‡²ğŸ‡´",
  northern_mariana_islands: "ğŸ‡²ğŸ‡µ",
  martinique: "ğŸ‡²ğŸ‡¶",
  mauritania: "ğŸ‡²ğŸ‡·",
  montserrat: "ğŸ‡²ğŸ‡¸",
  malta: "ğŸ‡²ğŸ‡¹",
  mauritius: "ğŸ‡²ğŸ‡º",
  maldives: "ğŸ‡²ğŸ‡»",
  malawi: "ğŸ‡²ğŸ‡¼",
  mexico: "ğŸ‡²ğŸ‡½",
  malaysia: "ğŸ‡²ğŸ‡¾",
  mozambique: "ğŸ‡²ğŸ‡¿",
  namibia: "ğŸ‡³ğŸ‡¦",
  new_caledonia: "ğŸ‡³ğŸ‡¨",
  niger: "ğŸ‡³ğŸ‡ª",
  norfolk_island: "ğŸ‡³ğŸ‡«",
  nigeria: "ğŸ‡³ğŸ‡¬",
  nicaragua: "ğŸ‡³ğŸ‡®",
  netherlands: "ğŸ‡³ğŸ‡±",
  norway: "ğŸ‡³ğŸ‡´",
  nepal: "ğŸ‡³ğŸ‡µ",
  nauru: "ğŸ‡³ğŸ‡·",
  niue: "ğŸ‡³ğŸ‡º",
  new_zealand: "ğŸ‡³ğŸ‡¿",
  oman: "ğŸ‡´ğŸ‡²",
  panama: "ğŸ‡µğŸ‡¦",
  peru: "ğŸ‡µğŸ‡ª",
  french_polynesia: "ğŸ‡µğŸ‡«",
  papua_new_guinea: "ğŸ‡µğŸ‡¬",
  philippines: "ğŸ‡µğŸ‡­",
  pakistan: "ğŸ‡µğŸ‡°",
  poland: "ğŸ‡µğŸ‡±",
  st_pierre_miquelon: "ğŸ‡µğŸ‡²",
  pitcairn_islands: "ğŸ‡µğŸ‡³",
  puerto_rico: "ğŸ‡µğŸ‡·",
  palestinian_territories: "ğŸ‡µğŸ‡¸",
  portugal: "ğŸ‡µğŸ‡¹",
  palau: "ğŸ‡µğŸ‡¼",
  paraguay: "ğŸ‡µğŸ‡¾",
  qatar: "ğŸ‡¶ğŸ‡¦",
  reunion: "ğŸ‡·ğŸ‡ª",
  romania: "ğŸ‡·ğŸ‡´",
  serbia: "ğŸ‡·ğŸ‡¸",
  ru: "ğŸ‡·ğŸ‡º",
  rwanda: "ğŸ‡·ğŸ‡¼",
  saudi_arabia: "ğŸ‡¸ğŸ‡¦",
  solomon_islands: "ğŸ‡¸ğŸ‡§",
  seychelles: "ğŸ‡¸ğŸ‡¨",
  sudan: "ğŸ‡¸ğŸ‡©",
  sweden: "ğŸ‡¸ğŸ‡ª",
  singapore: "ğŸ‡¸ğŸ‡¬",
  st_helena: "ğŸ‡¸ğŸ‡­",
  slovenia: "ğŸ‡¸ğŸ‡®",
  svalbard_jan_mayen: "ğŸ‡¸ğŸ‡¯",
  slovakia: "ğŸ‡¸ğŸ‡°",
  sierra_leone: "ğŸ‡¸ğŸ‡±",
  san_marino: "ğŸ‡¸ğŸ‡²",
  senegal: "ğŸ‡¸ğŸ‡³",
  somalia: "ğŸ‡¸ğŸ‡´",
  suriname: "ğŸ‡¸ğŸ‡·",
  south_sudan: "ğŸ‡¸ğŸ‡¸",
  sao_tome_principe: "ğŸ‡¸ğŸ‡¹",
  el_salvador: "ğŸ‡¸ğŸ‡»",
  sint_maarten: "ğŸ‡¸ğŸ‡½",
  syria: "ğŸ‡¸ğŸ‡¾",
  swaziland: "ğŸ‡¸ğŸ‡¿",
  tristan_da_cunha: "ğŸ‡¹ğŸ‡¦",
  turks_caicos_islands: "ğŸ‡¹ğŸ‡¨",
  chad: "ğŸ‡¹ğŸ‡©",
  french_southern_territories: "ğŸ‡¹ğŸ‡«",
  togo: "ğŸ‡¹ğŸ‡¬",
  thailand: "ğŸ‡¹ğŸ‡­",
  tajikistan: "ğŸ‡¹ğŸ‡¯",
  tokelau: "ğŸ‡¹ğŸ‡°",
  timor_leste: "ğŸ‡¹ğŸ‡±",
  turkmenistan: "ğŸ‡¹ğŸ‡²",
  tunisia: "ğŸ‡¹ğŸ‡³",
  tonga: "ğŸ‡¹ğŸ‡´",
  tr: "ğŸ‡¹ğŸ‡·",
  trinidad_tobago: "ğŸ‡¹ğŸ‡¹",
  tuvalu: "ğŸ‡¹ğŸ‡»",
  taiwan: "ğŸ‡¹ğŸ‡¼",
  tanzania: "ğŸ‡¹ğŸ‡¿",
  ukraine: "ğŸ‡ºğŸ‡¦",
  uganda: "ğŸ‡ºğŸ‡¬",
  us_outlying_islands: "ğŸ‡ºğŸ‡²",
  united_nations: "ğŸ‡ºğŸ‡³",
  us: "ğŸ‡ºğŸ‡¸",
  uruguay: "ğŸ‡ºğŸ‡¾",
  uzbekistan: "ğŸ‡ºğŸ‡¿",
  vatican_city: "ğŸ‡»ğŸ‡¦",
  st_vincent_grenadines: "ğŸ‡»ğŸ‡¨",
  venezuela: "ğŸ‡»ğŸ‡ª",
  british_virgin_islands: "ğŸ‡»ğŸ‡¬",
  us_virgin_islands: "ğŸ‡»ğŸ‡®",
  vietnam: "ğŸ‡»ğŸ‡³",
  vanuatu: "ğŸ‡»ğŸ‡º",
  wallis_futuna: "ğŸ‡¼ğŸ‡«",
  samoa: "ğŸ‡¼ğŸ‡¸",
  kosovo: "ğŸ‡½ğŸ‡°",
  yemen: "ğŸ‡¾ğŸ‡ª",
  mayotte: "ğŸ‡¾ğŸ‡¹",
  south_africa: "ğŸ‡¿ğŸ‡¦",
  zambia: "ğŸ‡¿ğŸ‡²",
  zimbabwe: "ğŸ‡¿ğŸ‡¼",
  england: "ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿",
  scotland: "ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿",
  wales: "ğŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿"
};
function vs(e, t) {
  const n = {
    defs: Cs,
    shortcuts: ws,
    enabled: []
  }, u = e.utils.assign({}, n, t || {});
  xs(e, u);
}
function pt(e, t, n) {
  function u(f) {
    return f.trim().split(" ", 2)[0] === t;
  }
  function r(f, p, h, g, m) {
    return f[p].nesting === 1 && f[p].attrJoin("class", t), m.renderToken(f, p, h, g, m);
  }
  n = n || {};
  const i = 3, a = n.marker || ":", o = a.charCodeAt(0), s = a.length, l = n.validate || u, c = n.render || r;
  function d(f, p, h, g) {
    let m, b = !1, _ = f.bMarks[p] + f.tShift[p], y = f.eMarks[p];
    if (o !== f.src.charCodeAt(_))
      return !1;
    for (m = _ + 1; m <= y && a[(m - _) % s] === f.src[m]; m++)
      ;
    const x = Math.floor((m - _) / s);
    if (x < i)
      return !1;
    m -= (m - _) % s;
    const C = f.src.slice(_, m), v = f.src.slice(m, y);
    if (!l(v, C))
      return !1;
    if (g)
      return !0;
    let A = p;
    for (; A++, !(A >= h || (_ = f.bMarks[A] + f.tShift[A], y = f.eMarks[A], _ < y && f.sCount[A] < f.blkIndent)); )
      if (o === f.src.charCodeAt(_) && !(f.sCount[A] - f.blkIndent >= 4)) {
        for (m = _ + 1; m <= y && a[(m - _) % s] === f.src[m]; m++)
          ;
        if (!(Math.floor((m - _) / s) < x) && (m -= (m - _) % s, m = f.skipSpaces(m), !(m < y))) {
          b = !0;
          break;
        }
      }
    const S = f.parentType, L = f.lineMax;
    f.parentType = "container", f.lineMax = A;
    const M = f.push("container_" + t + "_open", "div", 1);
    M.markup = C, M.block = !0, M.info = v, M.map = [p, A], f.md.block.tokenize(f, p + 1, A);
    const Z = f.push("container_" + t + "_close", "div", -1);
    return Z.markup = f.src.slice(_, m), Z.block = !0, f.parentType = S, f.lineMax = L, f.line = A + (b ? 1 : 0), !0;
  }
  e.block.ruler.before("fence", "container_" + t, d, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  }), e.renderer.rules["container_" + t + "_open"] = c, e.renderer.rules["container_" + t + "_close"] = c;
}
let As = (e) => crypto.getRandomValues(new Uint8Array(e)), Es = (e, t, n) => {
  let u = (2 << Math.log(e.length - 1) / Math.LN2) - 1, r = -~(1.6 * u * t / e.length);
  return (i = t) => {
    let a = "";
    for (; ; ) {
      let o = n(r), s = r | 0;
      for (; s--; )
        if (a += e[o[s] & u] || "", a.length === i) return a;
    }
  };
}, Ss = (e, t = 21) => Es(e, t, As), fu = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += "-" : t += "_", t), "");
const ln = /^[a-z]+:/i, Ds = /^pathname:\/\//, Tn = Symbol("vue-md-shiki-component"), Fs = () => [
  "abap",
  "actionscript-3",
  "ada",
  "apache",
  "apex",
  "apl",
  "applescript",
  "ara",
  "asm",
  "astro",
  "awk",
  "ballerina",
  "bat",
  "batch",
  "berry",
  "be",
  "bibtex",
  "bicep",
  "blade",
  "c",
  "cadence",
  "cdc",
  "clarity",
  "clojure",
  "clj",
  "cmake",
  "cobol",
  "codeql",
  "ql",
  "coffee",
  "cpp",
  "c++",
  "crystal",
  "csharp",
  "c#",
  "cs",
  "css",
  "cue",
  "d",
  "dart",
  "dax",
  "diff",
  "docker",
  "dockerfile",
  "dream-maker",
  "elixir",
  "elm",
  "erb",
  "erlang",
  "erl",
  "fish",
  "fsharp",
  "f#",
  "fs",
  "gdresource",
  "gdscript",
  "gdshader",
  "gherkin",
  "git-commit",
  "git-rebase",
  "glsl",
  "gnuplot",
  "go",
  "golang",
  "graphql",
  "groovy",
  "hack",
  "haml",
  "handlebars",
  "hbs",
  "haskell",
  "hs",
  "hcl",
  "hlsl",
  "html",
  "http",
  "imba",
  "ini",
  "properties",
  "java",
  "javascript",
  "js",
  "jinja-html",
  "jison",
  "json",
  "json5",
  "jsonc",
  "jsonnet",
  "jssm",
  "fsl",
  "jsx",
  "julia",
  "kotlin",
  "kusto",
  "kql",
  "latex",
  "less",
  "liquid",
  "lisp",
  "logo",
  "lua",
  "make",
  "makefile",
  "markdown",
  "md",
  "marko",
  "matlab",
  "mdx",
  "mermaid",
  "nginx",
  "nim",
  "nix",
  "objective-c",
  "objc",
  "objective-cpp",
  "ocaml",
  "pascal",
  "perl",
  "php",
  "plsql",
  "postcss",
  "powerquery",
  "powershell",
  "ps",
  "ps1",
  "prisma",
  "prolog",
  "proto",
  "pug",
  "jade",
  "puppet",
  "purescript",
  "python",
  "py",
  "r",
  "raku",
  "perl6",
  "razor",
  "reg",
  "rel",
  "riscv",
  "rst",
  "ruby",
  "rb",
  "rust",
  "rs",
  "sas",
  "sass",
  "scala",
  "scheme",
  "scss",
  "shaderlab",
  "shader",
  "shellscript",
  "bash",
  "console",
  "sh",
  "shell",
  "zsh",
  "smalltalk",
  "solidity",
  "sparql",
  "sql",
  "ssh-config",
  "stata",
  "stylus",
  "styl",
  "svelte",
  "swift",
  "system-verilog",
  "tasl",
  "tcl",
  "tex",
  "toml",
  "tsx",
  "turtle",
  "twig",
  "typescript",
  "ts",
  "v",
  "vb",
  "cmd",
  "verilog",
  "vhdl",
  "viml",
  "vim",
  "vimscript",
  "vue-html",
  "vue",
  "wasm",
  "wenyan",
  "æ–‡è¨€",
  "wgsl",
  "xml",
  "xsl",
  "yaml",
  "yml",
  "zenscript",
  ...Object.keys(dr)
], dr = {
  "c++": "cpp",
  "c#": "csharp",
  cs: "csharp",
  golang: "go"
};
function Ts(e) {
  const t = e.renderer.rules.fence;
  e.renderer.rules.fence = (...n) => {
    const [u, r] = n, i = u[r];
    i.info = i.info.replace(/\[.*\]/, "");
    let a = fr(i.info);
    Fs().includes(a) || (a = "plainText");
    const s = t(...n);
    return `<div class="language-${a}">${s}</div>`;
  };
}
function Rs(e) {
  var t;
  return ((t = e.match(/\[(.*)\]/)) == null ? void 0 : t[1]) || fr(e) || "txt";
}
const fr = (e) => e.trim().replace(/:(no-)?line-numbers({| |$).*/, "").replace(/(-vue|{| ).*$/, "").replace(/^vue-html$/, "template"), Ls = (e) => {
  e.use(...Me("tip", "TIP", e)).use(...Me("info", "INFO", e)).use(...Me("warning", "WARNING", e)).use(...Me("danger", "DANGER", e)).use(...Me("details", "Details", e)).use(pt, "v-pre", {
    render: (t, n) => t[n].nesting === 1 ? `<div v-pre>
` : `</div>
`
  }).use(pt, "raw", {
    render: (t, n) => t[n].nesting === 1 ? `<div class="vp-raw">
` : `</div>
`
  }).use(...Ps());
};
function Me(e, t, n) {
  return [
    pt,
    e,
    {
      render(u, r) {
        const i = u[r], a = i.info.trim().slice(e.length).trim();
        if (i.nesting === 1) {
          const o = n.renderInline(a || t);
          return e === "details" ? `<details class="${e} custom-block"><summary>${o}</summary>
` : `<div class="${e} custom-block"><p class="custom-block-title">${o}</p>
`;
        } else
          return e === "details" ? `</details>
` : `</div>
`;
      }
    }
  ];
}
function Ps() {
  return [
    pt,
    "code-group",
    {
      render(e, t) {
        if (e[t].nesting === 1) {
          const n = fu(5);
          let u = "", r = 'checked="checked"';
          for (let i = t + 1; !(e[i].nesting === -1 && e[i].type === "container_code-group_close"); ++i)
            if (e[i].type === "fence" && e[i].tag === "code") {
              const a = Rs(e[i].info), o = fu(7);
              u += `<input type="radio" name="group-${n}" id="tab-${o}" ${r}><label for="tab-${o}">${a}</label>`, r && (e[i].info += " active", r = "");
            }
          return `<div class="vp-code-group"><div class="tabs">${u}</div><div class="blocks">
`;
        }
        return `</div></div>
`;
      }
    }
  ];
}
const Rt = (e, t) => (n) => {
  const u = [], { code: r } = n;
  return {
    code: r,
    options: {
      transformLines: u,
      ...t || {}
    }
  };
};
function He(e, t, n) {
  const u = new RegExp(`<${n}[^>]*class="([\\w+-:;\\/* ]*)"`);
  return t = Array.isArray(t) ? t : [t], e.replace(u, (r, i) => r.replace(i, `${i} ${t}`));
}
function Ns(e = {}) {
  const t = e.commonDiffClass ?? "diff", n = e.removedLinesClasses ?? ["remove"], u = e.addedLinesClasses ?? ["add"], r = e.removeLineTag ?? "--", i = e.addLineTag ?? "++", a = e.hasDiffClass ?? "has-diff";
  return {
    name: "diff",
    handler: Rt(
      {
        [r]: [t, ...n],
        [i]: [t, ...u]
      },
      e
    ),
    postProcess: ({ code: o }) => o.includes(t) ? He(o, a, "pre") : o
  };
}
function Is(e = {}) {
  const t = e.hasFocusClass ?? "has-focus", n = e.hasFocusedLinesClass ?? "has-focused-lines";
  return e.focusTag, {
    name: "focus",
    handler: Rt(
      {},
      e
    ),
    postProcess: ({ code: u }) => u.includes(t) ? He(u, n, "pre") : u
  };
}
function Ms(e = {}) {
  const t = e.hasHighlightClass ?? "has-highlight", n = e.hasHighlightedLinesClass ?? "has-highlighted-lines";
  return e.highlightTag, {
    name: "highlight",
    handler: Rt({}, e),
    postProcess: ({ code: u }) => u.includes(t) ? He(u, n, "pre") : u
  };
}
function Os(e, t, n, u = {}) {
  const r = [], i = {
    code: t,
    language: n,
    options: u
  };
  for (const s of e)
    if (s.handler) {
      const l = s.handler(i);
      l && (Array.isArray(l) ? r.push(...l) : r.push(l));
    }
  let a = t, o = [];
  for (const s of r)
    if (s.code !== void 0 && (a = s.code), s.options && s.options.transformLines) {
      const l = s.options.transformLines;
      o = [...o, ...l];
    }
  return {
    code: a,
    lineOptions: o
  };
}
function Bs(e, t, n) {
  let u = t;
  for (const r of e)
    if (r.transformer) {
      const i = r.transformer(u, n, {});
      i && i.code && (u = i.code);
    }
  return u;
}
let j = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
function js(e) {
  return Rn(e);
}
function Rn(e) {
  return Array.isArray(e) ? zs(e) : e instanceof RegExp ? e : typeof e == "object" ? $s(e) : e;
}
function zs(e) {
  let t = [];
  for (let n = 0, u = e.length; n < u; n++)
    t[n] = Rn(e[n]);
  return t;
}
function $s(e) {
  let t = {};
  for (let n in e)
    t[n] = Rn(e[n]);
  return t;
}
function hr(e, ...t) {
  return t.forEach((n) => {
    for (let u in n)
      e[u] = n[u];
  }), e;
}
function pr(e) {
  const t = ~e.lastIndexOf("/") || ~e.lastIndexOf("\\");
  return t === 0 ? e : ~t === e.length - 1 ? pr(e.substring(0, e.length - 1)) : e.substr(~t + 1);
}
var Wt = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, ut = class {
  static hasCaptures(e) {
    return e === null ? !1 : (Wt.lastIndex = 0, Wt.test(e));
  }
  static replaceCaptures(e, t, n) {
    return e.replace(Wt, (u, r, i, a) => {
      let o = n[parseInt(r || i, 10)];
      if (o) {
        let s = t.substring(o.start, o.end);
        for (; s[0] === "."; )
          s = s.substring(1);
        switch (a) {
          case "downcase":
            return s.toLowerCase();
          case "upcase":
            return s.toUpperCase();
          default:
            return s;
        }
      } else
        return u;
    });
  }
};
function mr(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
function gr(e, t) {
  if (e === null && t === null)
    return 0;
  if (!e)
    return -1;
  if (!t)
    return 1;
  let n = e.length, u = t.length;
  if (n === u) {
    for (let r = 0; r < n; r++) {
      let i = mr(e[r], t[r]);
      if (i !== 0)
        return i;
    }
    return 0;
  }
  return n - u;
}
function hu(e) {
  return !!(/^#[0-9a-f]{6}$/i.test(e) || /^#[0-9a-f]{8}$/i.test(e) || /^#[0-9a-f]{3}$/i.test(e) || /^#[0-9a-f]{4}$/i.test(e));
}
function _r(e) {
  return e.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var br = class {
  constructor(e) {
    k(this, "cache", /* @__PURE__ */ new Map());
    this.fn = e;
  }
  get(e) {
    if (this.cache.has(e))
      return this.cache.get(e);
    const t = this.fn(e);
    return this.cache.set(e, t), t;
  }
}, mt = class {
  constructor(e, t, n) {
    k(this, "_cachedMatchRoot", new br(
      (e) => this._root.match(e)
    ));
    this._colorMap = e, this._defaults = t, this._root = n;
  }
  static createFromRawTheme(e, t) {
    return this.createFromParsedTheme(Hs(e), t);
  }
  static createFromParsedTheme(e, t) {
    return Ws(e, t);
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(e) {
    if (e === null)
      return this._defaults;
    const t = e.scopeName, u = this._cachedMatchRoot.get(t).find(
      (r) => qs(e.parent, r.parentScopes)
    );
    return u ? new yr(
      u.fontStyle,
      u.foreground,
      u.background
    ) : null;
  }
}, Vt = class ot {
  constructor(t, n) {
    this.parent = t, this.scopeName = n;
  }
  static push(t, n) {
    for (const u of n)
      t = new ot(t, u);
    return t;
  }
  static from(...t) {
    let n = null;
    for (let u = 0; u < t.length; u++)
      n = new ot(n, t[u]);
    return n;
  }
  push(t) {
    return new ot(this, t);
  }
  getSegments() {
    let t = this;
    const n = [];
    for (; t; )
      n.push(t.scopeName), t = t.parent;
    return n.reverse(), n;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(t) {
    return this === t ? !0 : this.parent === null ? !1 : this.parent.extends(t);
  }
  getExtensionIfDefined(t) {
    const n = [];
    let u = this;
    for (; u && u !== t; )
      n.push(u.scopeName), u = u.parent;
    return u === t ? n.reverse() : void 0;
  }
};
function qs(e, t) {
  if (t.length === 0)
    return !0;
  for (let n = 0; n < t.length; n++) {
    let u = t[n], r = !1;
    if (u === ">") {
      if (n === t.length - 1)
        return !1;
      u = t[++n], r = !0;
    }
    for (; e && !Gs(e.scopeName, u); ) {
      if (r)
        return !1;
      e = e.parent;
    }
    if (!e)
      return !1;
    e = e.parent;
  }
  return !0;
}
function Gs(e, t) {
  return t === e || e.startsWith(t) && e[t.length] === ".";
}
var yr = class {
  constructor(e, t, n) {
    this.fontStyle = e, this.foregroundId = t, this.backgroundId = n;
  }
};
function Hs(e) {
  if (!e)
    return [];
  if (!e.settings || !Array.isArray(e.settings))
    return [];
  let t = e.settings, n = [], u = 0;
  for (let r = 0, i = t.length; r < i; r++) {
    let a = t[r];
    if (!a.settings)
      continue;
    let o;
    if (typeof a.scope == "string") {
      let d = a.scope;
      d = d.replace(/^[,]+/, ""), d = d.replace(/[,]+$/, ""), o = d.split(",");
    } else Array.isArray(a.scope) ? o = a.scope : o = [""];
    let s = -1;
    if (typeof a.settings.fontStyle == "string") {
      s = 0;
      let d = a.settings.fontStyle.split(" ");
      for (let f = 0, p = d.length; f < p; f++)
        switch (d[f]) {
          case "italic":
            s = s | 1;
            break;
          case "bold":
            s = s | 2;
            break;
          case "underline":
            s = s | 4;
            break;
          case "strikethrough":
            s = s | 8;
            break;
        }
    }
    let l = null;
    typeof a.settings.foreground == "string" && hu(a.settings.foreground) && (l = a.settings.foreground);
    let c = null;
    typeof a.settings.background == "string" && hu(a.settings.background) && (c = a.settings.background);
    for (let d = 0, f = o.length; d < f; d++) {
      let h = o[d].trim().split(" "), g = h[h.length - 1], m = null;
      h.length > 1 && (m = h.slice(0, h.length - 1), m.reverse()), n[u++] = new Us(
        g,
        m,
        r,
        s,
        l,
        c
      );
    }
  }
  return n;
}
var Us = class {
  constructor(e, t, n, u, r, i) {
    this.scope = e, this.parentScopes = t, this.index = n, this.fontStyle = u, this.foreground = r, this.background = i;
  }
}, ce = /* @__PURE__ */ ((e) => (e[e.NotSet = -1] = "NotSet", e[e.None = 0] = "None", e[e.Italic = 1] = "Italic", e[e.Bold = 2] = "Bold", e[e.Underline = 4] = "Underline", e[e.Strikethrough = 8] = "Strikethrough", e))(ce || {});
function Ws(e, t) {
  e.sort((s, l) => {
    let c = mr(s.scope, l.scope);
    return c !== 0 || (c = gr(s.parentScopes, l.parentScopes), c !== 0) ? c : s.index - l.index;
  });
  let n = 0, u = "#000000", r = "#ffffff";
  for (; e.length >= 1 && e[0].scope === ""; ) {
    let s = e.shift();
    s.fontStyle !== -1 && (n = s.fontStyle), s.foreground !== null && (u = s.foreground), s.background !== null && (r = s.background);
  }
  let i = new Vs(t), a = new yr(n, i.getId(u), i.getId(r)), o = new Js(new cn(0, null, -1, 0, 0), []);
  for (let s = 0, l = e.length; s < l; s++) {
    let c = e[s];
    o.insert(0, c.scope, c.parentScopes, c.fontStyle, i.getId(c.foreground), i.getId(c.background));
  }
  return new mt(i, a, o);
}
var Vs = class {
  constructor(e) {
    k(this, "_isFrozen");
    k(this, "_lastColorId");
    k(this, "_id2color");
    k(this, "_color2id");
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(e)) {
      this._isFrozen = !0;
      for (let t = 0, n = e.length; t < n; t++)
        this._color2id[e[t]] = t, this._id2color[t] = e[t];
    } else
      this._isFrozen = !1;
  }
  getId(e) {
    if (e === null)
      return 0;
    e = e.toUpperCase();
    let t = this._color2id[e];
    if (t)
      return t;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${e}`);
    return t = ++this._lastColorId, this._color2id[e] = t, this._id2color[t] = e, t;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, Zs = Object.freeze([]), cn = class kr {
  constructor(t, n, u, r, i) {
    k(this, "scopeDepth");
    k(this, "parentScopes");
    k(this, "fontStyle");
    k(this, "foreground");
    k(this, "background");
    this.scopeDepth = t, this.parentScopes = n || Zs, this.fontStyle = u, this.foreground = r, this.background = i;
  }
  clone() {
    return new kr(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(t) {
    let n = [];
    for (let u = 0, r = t.length; u < r; u++)
      n[u] = t[u].clone();
    return n;
  }
  acceptOverwrite(t, n, u, r) {
    this.scopeDepth > t ? console.log("how did this happen?") : this.scopeDepth = t, n !== -1 && (this.fontStyle = n), u !== 0 && (this.foreground = u), r !== 0 && (this.background = r);
  }
}, Js = class dn {
  constructor(t, n = [], u = {}) {
    k(this, "_rulesWithParentScopes");
    this._mainRule = t, this._children = u, this._rulesWithParentScopes = n;
  }
  static _cmpBySpecificity(t, n) {
    if (t.scopeDepth !== n.scopeDepth)
      return n.scopeDepth - t.scopeDepth;
    let u = 0, r = 0;
    for (; t.parentScopes[u] === ">" && u++, n.parentScopes[r] === ">" && r++, !(u >= t.parentScopes.length || r >= n.parentScopes.length); ) {
      const i = n.parentScopes[r].length - t.parentScopes[u].length;
      if (i !== 0)
        return i;
      u++, r++;
    }
    return n.parentScopes.length - t.parentScopes.length;
  }
  match(t) {
    if (t !== "") {
      let u = t.indexOf("."), r, i;
      if (u === -1 ? (r = t, i = "") : (r = t.substring(0, u), i = t.substring(u + 1)), this._children.hasOwnProperty(r))
        return this._children[r].match(i);
    }
    const n = this._rulesWithParentScopes.concat(this._mainRule);
    return n.sort(dn._cmpBySpecificity), n;
  }
  insert(t, n, u, r, i, a) {
    if (n === "") {
      this._doInsertHere(t, u, r, i, a);
      return;
    }
    let o = n.indexOf("."), s, l;
    o === -1 ? (s = n, l = "") : (s = n.substring(0, o), l = n.substring(o + 1));
    let c;
    this._children.hasOwnProperty(s) ? c = this._children[s] : (c = new dn(this._mainRule.clone(), cn.cloneArr(this._rulesWithParentScopes)), this._children[s] = c), c.insert(t + 1, l, u, r, i, a);
  }
  _doInsertHere(t, n, u, r, i) {
    if (n === null) {
      this._mainRule.acceptOverwrite(t, u, r, i);
      return;
    }
    for (let a = 0, o = this._rulesWithParentScopes.length; a < o; a++) {
      let s = this._rulesWithParentScopes[a];
      if (gr(s.parentScopes, n) === 0) {
        s.acceptOverwrite(t, u, r, i);
        return;
      }
    }
    u === -1 && (u = this._mainRule.fontStyle), r === 0 && (r = this._mainRule.foreground), i === 0 && (i = this._mainRule.background), this._rulesWithParentScopes.push(new cn(t, n, u, r, i));
  }
}, Re = class J {
  static toBinaryStr(t) {
    return t.toString(2).padStart(32, "0");
  }
  static print(t) {
    const n = J.getLanguageId(t), u = J.getTokenType(t), r = J.getFontStyle(t), i = J.getForeground(t), a = J.getBackground(t);
    console.log({
      languageId: n,
      tokenType: u,
      fontStyle: r,
      foreground: i,
      background: a
    });
  }
  static getLanguageId(t) {
    return (t & 255) >>> 0;
  }
  static getTokenType(t) {
    return (t & 768) >>> 8;
  }
  static containsBalancedBrackets(t) {
    return (t & 1024) !== 0;
  }
  static getFontStyle(t) {
    return (t & 30720) >>> 11;
  }
  static getForeground(t) {
    return (t & 16744448) >>> 15;
  }
  static getBackground(t) {
    return (t & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(t, n, u, r, i, a, o) {
    let s = J.getLanguageId(t), l = J.getTokenType(t), c = J.containsBalancedBrackets(t) ? 1 : 0, d = J.getFontStyle(t), f = J.getForeground(t), p = J.getBackground(t);
    return n !== 0 && (s = n), u !== 8 && (l = u), r !== null && (c = r ? 1 : 0), i !== -1 && (d = i), a !== 0 && (f = a), o !== 0 && (p = o), (s << 0 | l << 8 | c << 10 | d << 11 | f << 15 | p << 24) >>> 0;
  }
};
function gt(e, t) {
  const n = [], u = Ks(e);
  let r = u.next();
  for (; r !== null; ) {
    let s = 0;
    if (r.length === 2 && r.charAt(1) === ":") {
      switch (r.charAt(0)) {
        case "R":
          s = 1;
          break;
        case "L":
          s = -1;
          break;
        default:
          console.log(`Unknown priority ${r} in scope selector`);
      }
      r = u.next();
    }
    let l = a();
    if (n.push({ matcher: l, priority: s }), r !== ",")
      break;
    r = u.next();
  }
  return n;
  function i() {
    if (r === "-") {
      r = u.next();
      const s = i();
      return (l) => !!s && !s(l);
    }
    if (r === "(") {
      r = u.next();
      const s = o();
      return r === ")" && (r = u.next()), s;
    }
    if (pu(r)) {
      const s = [];
      do
        s.push(r), r = u.next();
      while (pu(r));
      return (l) => t(s, l);
    }
    return null;
  }
  function a() {
    const s = [];
    let l = i();
    for (; l; )
      s.push(l), l = i();
    return (c) => s.every((d) => d(c));
  }
  function o() {
    const s = [];
    let l = a();
    for (; l && (s.push(l), r === "|" || r === ","); ) {
      do
        r = u.next();
      while (r === "|" || r === ",");
      l = a();
    }
    return (c) => s.some((d) => d(c));
  }
}
function pu(e) {
  return !!e && !!e.match(/[\w\.:]+/);
}
function Ks(e) {
  let t = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, n = t.exec(e);
  return {
    next: () => {
      if (!n)
        return null;
      const u = n[0];
      return n = t.exec(e), u;
    }
  };
}
function xr(e) {
  typeof e.dispose == "function" && e.dispose();
}
var Ue = class {
  constructor(e) {
    this.scopeName = e;
  }
  toKey() {
    return this.scopeName;
  }
}, Qs = class {
  constructor(e, t) {
    this.scopeName = e, this.ruleName = t;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, Xs = class {
  constructor() {
    k(this, "_references", []);
    k(this, "_seenReferenceKeys", /* @__PURE__ */ new Set());
    k(this, "visitedRule", /* @__PURE__ */ new Set());
  }
  get references() {
    return this._references;
  }
  add(e) {
    const t = e.toKey();
    this._seenReferenceKeys.has(t) || (this._seenReferenceKeys.add(t), this._references.push(e));
  }
}, Ys = class {
  constructor(e, t) {
    k(this, "seenFullScopeRequests", /* @__PURE__ */ new Set());
    k(this, "seenPartialScopeRequests", /* @__PURE__ */ new Set());
    k(this, "Q");
    this.repo = e, this.initialScopeName = t, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new Ue(this.initialScopeName)];
  }
  processQueue() {
    const e = this.Q;
    this.Q = [];
    const t = new Xs();
    for (const n of e)
      el(n, this.initialScopeName, this.repo, t);
    for (const n of t.references)
      if (n instanceof Ue) {
        if (this.seenFullScopeRequests.has(n.scopeName))
          continue;
        this.seenFullScopeRequests.add(n.scopeName), this.Q.push(n);
      } else {
        if (this.seenFullScopeRequests.has(n.scopeName) || this.seenPartialScopeRequests.has(n.toKey()))
          continue;
        this.seenPartialScopeRequests.add(n.toKey()), this.Q.push(n);
      }
  }
};
function el(e, t, n, u) {
  const r = n.lookup(e.scopeName);
  if (!r) {
    if (e.scopeName === t)
      throw new Error(`No grammar provided for <${t}>`);
    return;
  }
  const i = n.lookup(t);
  e instanceof Ue ? st({ baseGrammar: i, selfGrammar: r }, u) : fn(
    e.ruleName,
    { baseGrammar: i, selfGrammar: r, repository: r.repository },
    u
  );
  const a = n.injections(e.scopeName);
  if (a)
    for (const o of a)
      u.add(new Ue(o));
}
function fn(e, t, n) {
  if (t.repository && t.repository[e]) {
    const u = t.repository[e];
    _t([u], t, n);
  }
}
function st(e, t) {
  e.selfGrammar.patterns && Array.isArray(e.selfGrammar.patterns) && _t(
    e.selfGrammar.patterns,
    { ...e, repository: e.selfGrammar.repository },
    t
  ), e.selfGrammar.injections && _t(
    Object.values(e.selfGrammar.injections),
    { ...e, repository: e.selfGrammar.repository },
    t
  );
}
function _t(e, t, n) {
  for (const u of e) {
    if (n.visitedRule.has(u))
      continue;
    n.visitedRule.add(u);
    const r = u.repository ? hr({}, t.repository, u.repository) : t.repository;
    Array.isArray(u.patterns) && _t(u.patterns, { ...t, repository: r }, n);
    const i = u.include;
    if (!i)
      continue;
    const a = wr(i);
    switch (a.kind) {
      case 0:
        st({ ...t, selfGrammar: t.baseGrammar }, n);
        break;
      case 1:
        st(t, n);
        break;
      case 2:
        fn(a.ruleName, { ...t, repository: r }, n);
        break;
      case 3:
      case 4:
        const o = a.scopeName === t.selfGrammar.scopeName ? t.selfGrammar : a.scopeName === t.baseGrammar.scopeName ? t.baseGrammar : void 0;
        if (o) {
          const s = { baseGrammar: t.baseGrammar, selfGrammar: o, repository: r };
          a.kind === 4 ? fn(a.ruleName, s, n) : st(s, n);
        } else
          a.kind === 4 ? n.add(new Qs(a.scopeName, a.ruleName)) : n.add(new Ue(a.scopeName));
        break;
    }
  }
}
var tl = class {
  constructor() {
    k(this, "kind", 0);
  }
}, nl = class {
  constructor() {
    k(this, "kind", 1);
  }
}, ul = class {
  constructor(e) {
    k(this, "kind", 2);
    this.ruleName = e;
  }
}, rl = class {
  constructor(e) {
    k(this, "kind", 3);
    this.scopeName = e;
  }
}, il = class {
  constructor(e, t) {
    k(this, "kind", 4);
    this.scopeName = e, this.ruleName = t;
  }
};
function wr(e) {
  if (e === "$base")
    return new tl();
  if (e === "$self")
    return new nl();
  const t = e.indexOf("#");
  if (t === -1)
    return new rl(e);
  if (t === 0)
    return new ul(e.substring(1));
  {
    const n = e.substring(0, t), u = e.substring(t + 1);
    return new il(n, u);
  }
}
var al = /\\(\d+)/, mu = /\\(\d+)/g, ol = -1, Cr = -2;
var Ye = class {
  constructor(e, t, n, u) {
    k(this, "$location");
    k(this, "id");
    k(this, "_nameIsCapturing");
    k(this, "_name");
    k(this, "_contentNameIsCapturing");
    k(this, "_contentName");
    this.$location = e, this.id = t, this._name = n || null, this._nameIsCapturing = ut.hasCaptures(this._name), this._contentName = u || null, this._contentNameIsCapturing = ut.hasCaptures(this._contentName);
  }
  get debugName() {
    const e = this.$location ? `${pr(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${e}`;
  }
  getName(e, t) {
    return !this._nameIsCapturing || this._name === null || e === null || t === null ? this._name : ut.replaceCaptures(this._name, e, t);
  }
  getContentName(e, t) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : ut.replaceCaptures(this._contentName, e, t);
  }
}, sl = class extends Ye {
  constructor(t, n, u, r, i) {
    super(t, n, u, r);
    k(this, "retokenizeCapturedWithRuleId");
    this.retokenizeCapturedWithRuleId = i;
  }
  dispose() {
  }
  collectPatterns(t, n) {
    throw new Error("Not supported!");
  }
  compile(t, n) {
    throw new Error("Not supported!");
  }
  compileAG(t, n, u, r) {
    throw new Error("Not supported!");
  }
}, ll = class extends Ye {
  constructor(t, n, u, r, i) {
    super(t, n, u, null);
    k(this, "_match");
    k(this, "captures");
    k(this, "_cachedCompiledPatterns");
    this._match = new We(r, this.id), this.captures = i, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(t, n) {
    n.push(this._match);
  }
  compile(t, n) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, n, u, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, u, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Ve(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, gu = class extends Ye {
  constructor(t, n, u, r, i) {
    super(t, n, u, r);
    k(this, "hasMissingPatterns");
    k(this, "patterns");
    k(this, "_cachedCompiledPatterns");
    this.patterns = i.patterns, this.hasMissingPatterns = i.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(t, n) {
    for (const u of this.patterns)
      t.getRule(u).collectPatterns(t, n);
  }
  compile(t, n) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, n, u, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, u, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new Ve(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, hn = class extends Ye {
  constructor(t, n, u, r, i, a, o, s, l, c) {
    super(t, n, u, r);
    k(this, "_begin");
    k(this, "beginCaptures");
    k(this, "_end");
    k(this, "endHasBackReferences");
    k(this, "endCaptures");
    k(this, "applyEndPatternLast");
    k(this, "hasMissingPatterns");
    k(this, "patterns");
    k(this, "_cachedCompiledPatterns");
    this._begin = new We(i, this.id), this.beginCaptures = a, this._end = new We(o || "ï¿¿", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = s, this.applyEndPatternLast = l || !1, this.patterns = c.patterns, this.hasMissingPatterns = c.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(t, n) {
    return this._end.resolveBackReferences(t, n);
  }
  collectPatterns(t, n) {
    n.push(this._begin);
  }
  compile(t, n) {
    return this._getCachedCompiledPatterns(t, n).compile(t);
  }
  compileAG(t, n, u, r) {
    return this._getCachedCompiledPatterns(t, n).compileAG(t, u, r);
  }
  _getCachedCompiledPatterns(t, n) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Ve();
      for (const u of this.patterns)
        t.getRule(u).collectPatterns(t, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, n) : this._cachedCompiledPatterns.setSource(0, n)), this._cachedCompiledPatterns;
  }
}, bt = class extends Ye {
  constructor(t, n, u, r, i, a, o, s, l) {
    super(t, n, u, r);
    k(this, "_begin");
    k(this, "beginCaptures");
    k(this, "whileCaptures");
    k(this, "_while");
    k(this, "whileHasBackReferences");
    k(this, "hasMissingPatterns");
    k(this, "patterns");
    k(this, "_cachedCompiledPatterns");
    k(this, "_cachedCompiledWhilePatterns");
    this._begin = new We(i, this.id), this.beginCaptures = a, this.whileCaptures = s, this._while = new We(o, Cr), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = l.patterns, this.hasMissingPatterns = l.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(t, n) {
    return this._while.resolveBackReferences(t, n);
  }
  collectPatterns(t, n) {
    n.push(this._begin);
  }
  compile(t, n) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, n, u, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, u, r);
  }
  _getCachedCompiledPatterns(t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new Ve();
      for (const n of this.patterns)
        t.getRule(n).collectPatterns(t, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(t, n) {
    return this._getCachedCompiledWhilePatterns(t, n).compile(t);
  }
  compileWhileAG(t, n, u, r) {
    return this._getCachedCompiledWhilePatterns(t, n).compileAG(t, u, r);
  }
  _getCachedCompiledWhilePatterns(t, n) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new Ve(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, n || "ï¿¿"), this._cachedCompiledWhilePatterns;
  }
}, vr = class q {
  static createCaptureRule(t, n, u, r, i) {
    return t.registerRule((a) => new sl(n, a, u, r, i));
  }
  static getCompiledRuleId(t, n, u) {
    return t.id || n.registerRule((r) => {
      if (t.id = r, t.match)
        return new ll(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.match,
          q._compileCaptures(t.captures, n, u)
        );
      if (typeof t.begin > "u") {
        t.repository && (u = hr({}, u, t.repository));
        let i = t.patterns;
        return typeof i > "u" && t.include && (i = [{ include: t.include }]), new gu(
          t.$vscodeTextmateLocation,
          t.id,
          t.name,
          t.contentName,
          q._compilePatterns(i, n, u)
        );
      }
      return t.while ? new bt(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        q._compileCaptures(t.beginCaptures || t.captures, n, u),
        t.while,
        q._compileCaptures(t.whileCaptures || t.captures, n, u),
        q._compilePatterns(t.patterns, n, u)
      ) : new hn(
        t.$vscodeTextmateLocation,
        t.id,
        t.name,
        t.contentName,
        t.begin,
        q._compileCaptures(t.beginCaptures || t.captures, n, u),
        t.end,
        q._compileCaptures(t.endCaptures || t.captures, n, u),
        t.applyEndPatternLast,
        q._compilePatterns(t.patterns, n, u)
      );
    }), t.id;
  }
  static _compileCaptures(t, n, u) {
    let r = [];
    if (t) {
      let i = 0;
      for (const a in t) {
        if (a === "$vscodeTextmateLocation")
          continue;
        const o = parseInt(a, 10);
        o > i && (i = o);
      }
      for (let a = 0; a <= i; a++)
        r[a] = null;
      for (const a in t) {
        if (a === "$vscodeTextmateLocation")
          continue;
        const o = parseInt(a, 10);
        let s = 0;
        t[a].patterns && (s = q.getCompiledRuleId(t[a], n, u)), r[o] = q.createCaptureRule(n, t[a].$vscodeTextmateLocation, t[a].name, t[a].contentName, s);
      }
    }
    return r;
  }
  static _compilePatterns(t, n, u) {
    let r = [];
    if (t)
      for (let i = 0, a = t.length; i < a; i++) {
        const o = t[i];
        let s = -1;
        if (o.include) {
          const l = wr(o.include);
          switch (l.kind) {
            case 0:
            case 1:
              s = q.getCompiledRuleId(u[o.include], n, u);
              break;
            case 2:
              let c = u[l.ruleName];
              c && (s = q.getCompiledRuleId(c, n, u));
              break;
            case 3:
            case 4:
              const d = l.scopeName, f = l.kind === 4 ? l.ruleName : null, p = n.getExternalGrammar(d, u);
              if (p)
                if (f) {
                  let h = p.repository[f];
                  h && (s = q.getCompiledRuleId(h, n, p.repository));
                } else
                  s = q.getCompiledRuleId(p.repository.$self, n, p.repository);
              break;
          }
        } else
          s = q.getCompiledRuleId(o, n, u);
        if (s !== -1) {
          const l = n.getRule(s);
          let c = !1;
          if ((l instanceof gu || l instanceof hn || l instanceof bt) && l.hasMissingPatterns && l.patterns.length === 0 && (c = !0), c)
            continue;
          r.push(s);
        }
      }
    return {
      patterns: r,
      hasMissingPatterns: (t ? t.length : 0) !== r.length
    };
  }
}, We = class Ar {
  constructor(t, n) {
    k(this, "source");
    k(this, "ruleId");
    k(this, "hasAnchor");
    k(this, "hasBackReferences");
    k(this, "_anchorCache");
    if (t && typeof t == "string") {
      const u = t.length;
      let r = 0, i = [], a = !1;
      for (let o = 0; o < u; o++)
        if (t.charAt(o) === "\\" && o + 1 < u) {
          const l = t.charAt(o + 1);
          l === "z" ? (i.push(t.substring(r, o)), i.push("$(?!\\n)(?<!\\n)"), r = o + 2) : (l === "A" || l === "G") && (a = !0), o++;
        }
      this.hasAnchor = a, r === 0 ? this.source = t : (i.push(t.substring(r, u)), this.source = i.join(""));
    } else
      this.hasAnchor = !1, this.source = t;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = n, typeof this.source == "string" ? this.hasBackReferences = al.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new Ar(this.source, this.ruleId);
  }
  setSource(t) {
    this.source !== t && (this.source = t, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(t, n) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let u = n.map((r) => t.substring(r.start, r.end));
    return mu.lastIndex = 0, this.source.replace(mu, (r, i) => _r(u[parseInt(i, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let t = [], n = [], u = [], r = [], i, a, o, s;
    for (i = 0, a = this.source.length; i < a; i++)
      o = this.source.charAt(i), t[i] = o, n[i] = o, u[i] = o, r[i] = o, o === "\\" && i + 1 < a && (s = this.source.charAt(i + 1), s === "A" ? (t[i + 1] = "ï¿¿", n[i + 1] = "ï¿¿", u[i + 1] = "A", r[i + 1] = "A") : s === "G" ? (t[i + 1] = "ï¿¿", n[i + 1] = "G", u[i + 1] = "ï¿¿", r[i + 1] = "G") : (t[i + 1] = s, n[i + 1] = s, u[i + 1] = s, r[i + 1] = s), i++);
    return {
      A0_G0: t.join(""),
      A0_G1: n.join(""),
      A1_G0: u.join(""),
      A1_G1: r.join("")
    };
  }
  resolveAnchors(t, n) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : t ? n ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : n ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, Ve = class {
  constructor() {
    k(this, "_items");
    k(this, "_hasAnchors");
    k(this, "_cached");
    k(this, "_anchorCache");
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(e) {
    this._items.push(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  unshift(e) {
    this._items.unshift(e), this._hasAnchors = this._hasAnchors || e.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(e, t) {
    this._items[e].source !== t && (this._disposeCaches(), this._items[e].setSource(t));
  }
  compile(e) {
    if (!this._cached) {
      let t = this._items.map((n) => n.source);
      this._cached = new _u(e, t, this._items.map((n) => n.ruleId));
    }
    return this._cached;
  }
  compileAG(e, t, n) {
    return this._hasAnchors ? t ? n ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A1_G0) : n ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(e, t, n)), this._anchorCache.A0_G0) : this.compile(e);
  }
  _resolveAnchors(e, t, n) {
    let u = this._items.map((r) => r.resolveAnchors(t, n));
    return new _u(e, u, this._items.map((r) => r.ruleId));
  }
}, _u = class {
  constructor(e, t, n) {
    k(this, "scanner");
    this.regExps = t, this.rules = n, this.scanner = e.createOnigScanner(t);
  }
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const e = [];
    for (let t = 0, n = this.rules.length; t < n; t++)
      e.push("   - " + this.rules[t] + ": " + this.regExps[t]);
    return e.join(`
`);
  }
  findNextMatchSync(e, t, n) {
    const u = this.scanner.findNextMatchSync(e, t, n);
    return u ? {
      ruleId: this.rules[u.index],
      captureIndices: u.captureIndices
    } : null;
  }
}, Zt = class {
  constructor(e, t) {
    this.languageId = e, this.tokenType = t;
  }
}, le, cl = (le = class {
  constructor(t, n) {
    k(this, "_defaultAttributes");
    k(this, "_embeddedLanguagesMatcher");
    k(this, "_getBasicScopeAttributes", new br((t) => {
      const n = this._scopeToLanguage(t), u = this._toStandardTokenType(t);
      return new Zt(n, u);
    }));
    this._defaultAttributes = new Zt(
      t,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new dl(Object.entries(n || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(t) {
    return t === null ? le._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(t);
  }
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(t) {
    return this._embeddedLanguagesMatcher.match(t) || 0;
  }
  _toStandardTokenType(t) {
    const n = t.match(le.STANDARD_TOKEN_TYPE_REGEXP);
    if (!n)
      return 8;
    switch (n[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
}, k(le, "_NULL_SCOPE_METADATA", new Zt(0, 0)), k(le, "STANDARD_TOKEN_TYPE_REGEXP", /\b(comment|string|regex|meta\.embedded)\b/), le), dl = class {
  constructor(e) {
    k(this, "values");
    k(this, "scopesRegExp");
    if (e.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(e);
      const t = e.map(
        ([n, u]) => _r(n)
      );
      t.sort(), t.reverse(), this.scopesRegExp = new RegExp(
        `^((${t.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(e) {
    if (!this.scopesRegExp)
      return;
    const t = e.match(this.scopesRegExp);
    if (t)
      return this.values.get(t[1]);
  }
};
typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;
var bu = class {
  constructor(e, t) {
    this.stack = e, this.stoppedEarly = t;
  }
};
function Er(e, t, n, u, r, i, a, o) {
  const s = t.content.length;
  let l = !1, c = -1;
  if (a) {
    const p = fl(
      e,
      t,
      n,
      u,
      r,
      i
    );
    r = p.stack, u = p.linePos, n = p.isFirstLine, c = p.anchorPosition;
  }
  const d = Date.now();
  for (; !l; ) {
    if (o !== 0 && Date.now() - d > o)
      return new bu(r, !0);
    f();
  }
  return new bu(r, !1);
  function f() {
    const p = hl(
      e,
      t,
      n,
      u,
      r,
      c
    );
    if (!p) {
      i.produce(r, s), l = !0;
      return;
    }
    const h = p.captureIndices, g = p.matchedRuleId, m = h && h.length > 0 ? h[0].end > u : !1;
    if (g === ol) {
      const b = r.getRule(e);
      i.produce(r, h[0].start), r = r.withContentNameScopesList(r.nameScopesList), Be(
        e,
        t,
        n,
        r,
        i,
        b.endCaptures,
        h
      ), i.produce(r, h[0].end);
      const _ = r;
      if (r = r.parent, c = _.getAnchorPos(), !m && _.getEnterPos() === u) {
        r = _, i.produce(r, s), l = !0;
        return;
      }
    } else {
      const b = e.getRule(g);
      i.produce(r, h[0].start);
      const _ = r, y = b.getName(t.content, h), x = r.contentNameScopesList.pushAttributed(
        y,
        e
      );
      if (r = r.push(
        g,
        u,
        c,
        h[0].end === s,
        null,
        x,
        x
      ), b instanceof hn) {
        const C = b;
        Be(
          e,
          t,
          n,
          r,
          i,
          C.beginCaptures,
          h
        ), i.produce(r, h[0].end), c = h[0].end;
        const v = C.getContentName(
          t.content,
          h
        ), A = x.pushAttributed(
          v,
          e
        );
        if (r = r.withContentNameScopesList(A), C.endHasBackReferences && (r = r.withEndRule(
          C.getEndWithResolvedBackReferences(
            t.content,
            h
          )
        )), !m && _.hasSameRuleAs(r)) {
          r = r.pop(), i.produce(r, s), l = !0;
          return;
        }
      } else if (b instanceof bt) {
        const C = b;
        Be(
          e,
          t,
          n,
          r,
          i,
          C.beginCaptures,
          h
        ), i.produce(r, h[0].end), c = h[0].end;
        const v = C.getContentName(
          t.content,
          h
        ), A = x.pushAttributed(
          v,
          e
        );
        if (r = r.withContentNameScopesList(A), C.whileHasBackReferences && (r = r.withEndRule(
          C.getWhileWithResolvedBackReferences(
            t.content,
            h
          )
        )), !m && _.hasSameRuleAs(r)) {
          r = r.pop(), i.produce(r, s), l = !0;
          return;
        }
      } else if (Be(
        e,
        t,
        n,
        r,
        i,
        b.captures,
        h
      ), i.produce(r, h[0].end), r = r.pop(), !m) {
        r = r.safePop(), i.produce(r, s), l = !0;
        return;
      }
    }
    h[0].end > u && (u = h[0].end, n = !1);
  }
}
function fl(e, t, n, u, r, i) {
  let a = r.beginRuleCapturedEOL ? 0 : -1;
  const o = [];
  for (let s = r; s; s = s.pop()) {
    const l = s.getRule(e);
    l instanceof bt && o.push({
      rule: l,
      stack: s
    });
  }
  for (let s = o.pop(); s; s = o.pop()) {
    const { ruleScanner: l, findOptions: c } = gl(s.rule, e, s.stack.endRule, n, u === a), d = l.findNextMatchSync(t, u, c);
    if (d) {
      if (d.ruleId !== Cr) {
        r = s.stack.pop();
        break;
      }
      d.captureIndices && d.captureIndices.length && (i.produce(s.stack, d.captureIndices[0].start), Be(e, t, n, s.stack, i, s.rule.whileCaptures, d.captureIndices), i.produce(s.stack, d.captureIndices[0].end), a = d.captureIndices[0].end, d.captureIndices[0].end > u && (u = d.captureIndices[0].end, n = !1));
    } else {
      r = s.stack.pop();
      break;
    }
  }
  return { stack: r, linePos: u, anchorPosition: a, isFirstLine: n };
}
function hl(e, t, n, u, r, i) {
  const a = pl(e, t, n, u, r, i), o = e.getInjections();
  if (o.length === 0)
    return a;
  const s = ml(o, e, t, n, u, r, i);
  if (!s)
    return a;
  if (!a)
    return s;
  const l = a.captureIndices[0].start, c = s.captureIndices[0].start;
  return c < l || s.priorityMatch && c === l ? s : a;
}
function pl(e, t, n, u, r, i) {
  const a = r.getRule(e), { ruleScanner: o, findOptions: s } = Sr(a, e, r.endRule, n, u === i), l = o.findNextMatchSync(t, u, s);
  return l ? {
    captureIndices: l.captureIndices,
    matchedRuleId: l.ruleId
  } : null;
}
function ml(e, t, n, u, r, i, a) {
  let o = Number.MAX_VALUE, s = null, l, c = 0;
  const d = i.contentNameScopesList.getScopeNames();
  for (let f = 0, p = e.length; f < p; f++) {
    const h = e[f];
    if (!h.matcher(d))
      continue;
    const g = t.getRule(h.ruleId), { ruleScanner: m, findOptions: b } = Sr(g, t, null, u, r === a), _ = m.findNextMatchSync(n, r, b);
    if (!_)
      continue;
    const y = _.captureIndices[0].start;
    if (!(y >= o) && (o = y, s = _.captureIndices, l = _.ruleId, c = h.priority, o === r))
      break;
  }
  return s ? {
    priorityMatch: c === -1,
    captureIndices: s,
    matchedRuleId: l
  } : null;
}
function Sr(e, t, n, u, r) {
  return {
    ruleScanner: e.compileAG(t, n, u, r),
    findOptions: 0
    /* None */
  };
}
function gl(e, t, n, u, r) {
  return {
    ruleScanner: e.compileWhileAG(t, n, u, r),
    findOptions: 0
    /* None */
  };
}
function Be(e, t, n, u, r, i, a) {
  if (i.length === 0)
    return;
  const o = t.content, s = Math.min(i.length, a.length), l = [], c = a[0].end;
  for (let d = 0; d < s; d++) {
    const f = i[d];
    if (f === null)
      continue;
    const p = a[d];
    if (p.length === 0)
      continue;
    if (p.start > c)
      break;
    for (; l.length > 0 && l[l.length - 1].endPos <= p.start; )
      r.produceFromScopes(l[l.length - 1].scopes, l[l.length - 1].endPos), l.pop();
    if (l.length > 0 ? r.produceFromScopes(l[l.length - 1].scopes, p.start) : r.produce(u, p.start), f.retokenizeCapturedWithRuleId) {
      const g = f.getName(o, a), m = u.contentNameScopesList.pushAttributed(g, e), b = f.getContentName(o, a), _ = m.pushAttributed(b, e), y = u.push(f.retokenizeCapturedWithRuleId, p.start, -1, !1, null, m, _), x = e.createOnigString(o.substring(0, p.end));
      Er(
        e,
        x,
        n && p.start === 0,
        p.start,
        y,
        r,
        !1,
        /* no time limit */
        0
      ), xr(x);
      continue;
    }
    const h = f.getName(o, a);
    if (h !== null) {
      const m = (l.length > 0 ? l[l.length - 1].scopes : u.contentNameScopesList).pushAttributed(h, e);
      l.push(new _l(m, p.end));
    }
  }
  for (; l.length > 0; )
    r.produceFromScopes(l[l.length - 1].scopes, l[l.length - 1].endPos), l.pop();
}
var _l = class {
  constructor(e, t) {
    k(this, "scopes");
    k(this, "endPos");
    this.scopes = e, this.endPos = t;
  }
};
function bl(e, t, n, u, r, i, a, o) {
  return new kl(
    e,
    t,
    n,
    u,
    r,
    i,
    a,
    o
  );
}
function yu(e, t, n, u, r) {
  const i = gt(t, yt), a = vr.getCompiledRuleId(n, u, r.repository);
  for (const o of i)
    e.push({
      debugSelector: t,
      matcher: o.matcher,
      ruleId: a,
      grammar: r,
      priority: o.priority
    });
}
function yt(e, t) {
  if (t.length < e.length)
    return !1;
  let n = 0;
  return e.every((u) => {
    for (let r = n; r < t.length; r++)
      if (yl(t[r], u))
        return n = r + 1, !0;
    return !1;
  });
}
function yl(e, t) {
  if (!e)
    return !1;
  if (e === t)
    return !0;
  const n = t.length;
  return e.length > n && e.substr(0, n) === t && e[n] === ".";
}
var kl = class {
  constructor(e, t, n, u, r, i, a, o) {
    k(this, "_rootId");
    k(this, "_lastRuleId");
    k(this, "_ruleId2desc");
    k(this, "_includedGrammars");
    k(this, "_grammarRepository");
    k(this, "_grammar");
    k(this, "_injections");
    k(this, "_basicScopeAttributesProvider");
    k(this, "_tokenTypeMatchers");
    if (this._rootScopeName = e, this.balancedBracketSelectors = i, this._onigLib = o, this._basicScopeAttributesProvider = new cl(
      n,
      u
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = a, this._grammar = ku(t, null), this._injections = null, this._tokenTypeMatchers = [], r)
      for (const s of Object.keys(r)) {
        const l = gt(s, yt);
        for (const c of l)
          this._tokenTypeMatchers.push({
            matcher: c.matcher,
            type: r[s]
          });
      }
  }
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const e of this._ruleId2desc)
      e && e.dispose();
  }
  createOnigScanner(e) {
    return this._onigLib.createOnigScanner(e);
  }
  createOnigString(e) {
    return this._onigLib.createOnigString(e);
  }
  getMetadataForScope(e) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(e);
  }
  _collectInjections() {
    const e = {
      lookup: (r) => r === this._rootScopeName ? this._grammar : this.getExternalGrammar(r),
      injections: (r) => this._grammarRepository.injections(r)
    }, t = [], n = this._rootScopeName, u = e.lookup(n);
    if (u) {
      const r = u.injections;
      if (r)
        for (let a in r)
          yu(
            t,
            a,
            r[a],
            this,
            u
          );
      const i = this._grammarRepository.injections(n);
      i && i.forEach((a) => {
        const o = this.getExternalGrammar(a);
        if (o) {
          const s = o.injectionSelector;
          s && yu(
            t,
            s,
            o,
            this,
            o
          );
        }
      });
    }
    return t.sort((r, i) => r.priority - i.priority), t;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(e) {
    const t = ++this._lastRuleId, n = e(t);
    return this._ruleId2desc[t] = n, n;
  }
  getRule(e) {
    return this._ruleId2desc[e];
  }
  getExternalGrammar(e, t) {
    if (this._includedGrammars[e])
      return this._includedGrammars[e];
    if (this._grammarRepository) {
      const n = this._grammarRepository.lookup(e);
      if (n)
        return this._includedGrammars[e] = ku(
          n,
          t && t.$base
        ), this._includedGrammars[e];
    }
  }
  tokenizeLine(e, t, n = 0) {
    const u = this._tokenize(e, t, !1, n);
    return {
      tokens: u.lineTokens.getResult(u.ruleStack, u.lineLength),
      ruleStack: u.ruleStack,
      stoppedEarly: u.stoppedEarly
    };
  }
  tokenizeLine2(e, t, n = 0) {
    const u = this._tokenize(e, t, !0, n);
    return {
      tokens: u.lineTokens.getBinaryResult(u.ruleStack, u.lineLength),
      ruleStack: u.ruleStack,
      stoppedEarly: u.stoppedEarly
    };
  }
  _tokenize(e, t, n, u) {
    this._rootId === -1 && (this._rootId = vr.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let r;
    if (!t || t === pn.NULL) {
      r = !0;
      const l = this._basicScopeAttributesProvider.getDefaultAttributes(), c = this.themeProvider.getDefaults(), d = Re.set(
        0,
        l.languageId,
        l.tokenType,
        null,
        c.fontStyle,
        c.foregroundId,
        c.backgroundId
      ), f = this.getRule(this._rootId).getName(
        null,
        null
      );
      let p;
      f ? p = je.createRootAndLookUpScopeName(
        f,
        d,
        this
      ) : p = je.createRoot(
        "unknown",
        d
      ), t = new pn(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        p,
        p
      );
    } else
      r = !1, t.reset();
    e = e + `
`;
    const i = this.createOnigString(e), a = i.content.length, o = new wl(
      n,
      e,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), s = Er(
      this,
      i,
      r,
      0,
      t,
      o,
      !0,
      u
    );
    return xr(i), {
      lineLength: a,
      lineTokens: o,
      ruleStack: s.stack,
      stoppedEarly: s.stoppedEarly
    };
  }
};
function ku(e, t) {
  return e = js(e), e.repository = e.repository || {}, e.repository.$self = {
    $vscodeTextmateLocation: e.$vscodeTextmateLocation,
    patterns: e.patterns,
    name: e.scopeName
  }, e.repository.$base = t || e.repository.$self, e;
}
var je = class ee {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, u) {
    this.parent = t, this.scopePath = n, this.tokenAttributes = u;
  }
  static fromExtension(t, n) {
    let u = t, r = (t == null ? void 0 : t.scopePath) ?? null;
    for (const i of n)
      r = Vt.push(r, i.scopeNames), u = new ee(u, r, i.encodedTokenAttributes);
    return u;
  }
  static createRoot(t, n) {
    return new ee(null, new Vt(null, t), n);
  }
  static createRootAndLookUpScopeName(t, n, u) {
    const r = u.getMetadataForScope(t), i = new Vt(null, t), a = u.themeProvider.themeMatch(i), o = ee.mergeAttributes(
      n,
      r,
      a
    );
    return new ee(null, i, o);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(t) {
    return ee.equals(this, t);
  }
  static equals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.scopeName !== n.scopeName || t.tokenAttributes !== n.tokenAttributes)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  static mergeAttributes(t, n, u) {
    let r = -1, i = 0, a = 0;
    return u !== null && (r = u.fontStyle, i = u.foregroundId, a = u.backgroundId), Re.set(
      t,
      n.languageId,
      n.tokenType,
      null,
      r,
      i,
      a
    );
  }
  pushAttributed(t, n) {
    if (t === null)
      return this;
    if (t.indexOf(" ") === -1)
      return ee._pushAttributed(this, t, n);
    const u = t.split(/ /g);
    let r = this;
    for (const i of u)
      r = ee._pushAttributed(r, i, n);
    return r;
  }
  static _pushAttributed(t, n, u) {
    const r = u.getMetadataForScope(n), i = t.scopePath.push(n), a = u.themeProvider.themeMatch(i), o = ee.mergeAttributes(
      t.tokenAttributes,
      r,
      a
    );
    return new ee(t, i, o);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(t) {
    var r;
    const n = [];
    let u = this;
    for (; u && u !== t; )
      n.push({
        encodedTokenAttributes: u.tokenAttributes,
        scopeNames: u.scopePath.getExtensionIfDefined(((r = u.parent) == null ? void 0 : r.scopePath) ?? null)
      }), u = u.parent;
    return u === t ? n.reverse() : void 0;
  }
}, K, pn = (K = class {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(t, n, u, r, i, a, o, s) {
    k(this, "_stackElementBrand");
    /**
     * The position on the current line where this state was pushed.
     * This is relevant only while tokenizing a line, to detect endless loops.
     * Its value is meaningless across lines.
     */
    k(this, "_enterPos");
    /**
     * The captured anchor position when this stack element was pushed.
     * This is relevant only while tokenizing a line, to restore the anchor position when popping.
     * Its value is meaningless across lines.
     */
    k(this, "_anchorPos");
    /**
     * The depth of the stack.
     */
    k(this, "depth");
    this.parent = t, this.ruleId = n, this.beginRuleCapturedEOL = i, this.endRule = a, this.nameScopesList = o, this.contentNameScopesList = s, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = u, this._anchorPos = r;
  }
  equals(t) {
    return t === null ? !1 : K._equals(this, t);
  }
  static _equals(t, n) {
    return t === n ? !0 : this._structuralEquals(t, n) ? je.equals(t.contentNameScopesList, n.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(t, n) {
    do {
      if (t === n || !t && !n)
        return !0;
      if (!t || !n || t.depth !== n.depth || t.ruleId !== n.ruleId || t.endRule !== n.endRule)
        return !1;
      t = t.parent, n = n.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(t) {
    for (; t; )
      t._enterPos = -1, t._anchorPos = -1, t = t.parent;
  }
  reset() {
    K._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(t, n, u, r, i, a, o) {
    return new K(
      this,
      t,
      n,
      u,
      r,
      i,
      a,
      o
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(t) {
    return t.getRule(this.ruleId);
  }
  toString() {
    const t = [];
    return this._writeString(t, 0), "[" + t.join(",") + "]";
  }
  _writeString(t, n) {
    var u, r;
    return this.parent && (n = this.parent._writeString(t, n)), t[n++] = `(${this.ruleId}, ${(u = this.nameScopesList) == null ? void 0 : u.toString()}, ${(r = this.contentNameScopesList) == null ? void 0 : r.toString()})`, n;
  }
  withContentNameScopesList(t) {
    return this.contentNameScopesList === t ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      t
    );
  }
  withEndRule(t) {
    return this.endRule === t ? this : new K(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      t,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(t) {
    let n = this;
    for (; n && n._enterPos === t._enterPos; ) {
      if (n.ruleId === t.ruleId)
        return !0;
      n = n.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    var t, n, u;
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: ((n = this.nameScopesList) == null ? void 0 : n.getExtensionIfDefined(((t = this.parent) == null ? void 0 : t.nameScopesList) ?? null)) ?? [],
      contentNameScopesList: ((u = this.contentNameScopesList) == null ? void 0 : u.getExtensionIfDefined(this.nameScopesList)) ?? []
    };
  }
  static pushFrame(t, n) {
    const u = je.fromExtension((t == null ? void 0 : t.nameScopesList) ?? null, n.nameScopesList);
    return new K(
      t,
      n.ruleId,
      n.enterPos ?? -1,
      n.anchorPos ?? -1,
      n.beginRuleCapturedEOL,
      n.endRule,
      u,
      je.fromExtension(u, n.contentNameScopesList)
    );
  }
}, // TODO remove me
k(K, "NULL", new K(
  null,
  0,
  0,
  0,
  !1,
  null,
  null,
  null
)), K), xl = class {
  constructor(e, t) {
    k(this, "balancedBracketScopes");
    k(this, "unbalancedBracketScopes");
    k(this, "allowAny", !1);
    this.balancedBracketScopes = e.flatMap(
      (n) => n === "*" ? (this.allowAny = !0, []) : gt(n, yt).map((u) => u.matcher)
    ), this.unbalancedBracketScopes = t.flatMap(
      (n) => gt(n, yt).map((u) => u.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(e) {
    for (const t of this.unbalancedBracketScopes)
      if (t(e))
        return !1;
    for (const t of this.balancedBracketScopes)
      if (t(e))
        return !0;
    return this.allowAny;
  }
}, wl = class {
  constructor(e, t, n, u) {
    k(this, "_emitBinaryTokens");
    /**
     * defined only if `false`.
     */
    k(this, "_lineText");
    /**
     * used only if `_emitBinaryTokens` is false.
     */
    k(this, "_tokens");
    /**
     * used only if `_emitBinaryTokens` is true.
     */
    k(this, "_binaryTokens");
    k(this, "_lastTokenEndIndex");
    k(this, "_tokenTypeOverrides");
    this.balancedBracketSelectors = u, this._emitBinaryTokens = e, this._tokenTypeOverrides = n, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  produce(e, t) {
    this.produceFromScopes(e.contentNameScopesList, t);
  }
  produceFromScopes(e, t) {
    var u;
    if (this._lastTokenEndIndex >= t)
      return;
    if (this._emitBinaryTokens) {
      let r = (e == null ? void 0 : e.tokenAttributes) ?? 0, i = !1;
      if ((u = this.balancedBracketSelectors) != null && u.matchesAlways && (i = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const a = (e == null ? void 0 : e.getScopeNames()) ?? [];
        for (const o of this._tokenTypeOverrides)
          o.matcher(a) && (r = Re.set(
            r,
            0,
            o.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (i = this.balancedBracketSelectors.match(a));
      }
      if (i && (r = Re.set(
        r,
        0,
        8,
        i,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === r) {
        this._lastTokenEndIndex = t;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(r), this._lastTokenEndIndex = t;
      return;
    }
    const n = (e == null ? void 0 : e.getScopeNames()) ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: t,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: n
    }), this._lastTokenEndIndex = t;
  }
  getResult(e, t) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === t - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(e, t) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === t - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(e, t), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const n = new Uint32Array(this._binaryTokens.length);
    for (let u = 0, r = this._binaryTokens.length; u < r; u++)
      n[u] = this._binaryTokens[u];
    return n;
  }
}, Cl = class {
  constructor(e, t) {
    k(this, "_grammars", /* @__PURE__ */ new Map());
    k(this, "_rawGrammars", /* @__PURE__ */ new Map());
    k(this, "_injectionGrammars", /* @__PURE__ */ new Map());
    k(this, "_theme");
    this._onigLib = t, this._theme = e;
  }
  dispose() {
    for (const e of this._grammars.values())
      e.dispose();
  }
  setTheme(e) {
    this._theme = e;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(e, t) {
    this._rawGrammars.set(e.scopeName, e), t && this._injectionGrammars.set(e.scopeName, t);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(e) {
    return this._rawGrammars.get(e);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(e) {
    return this._injectionGrammars.get(e);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(e) {
    return this._theme.match(e);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(e, t, n, u, r) {
    if (!this._grammars.has(e)) {
      let i = this._rawGrammars.get(e);
      if (!i)
        return null;
      this._grammars.set(e, bl(
        e,
        i,
        t,
        n,
        u,
        r,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(e);
  }
}, vl = class {
  constructor(t) {
    k(this, "_options");
    k(this, "_syncRegistry");
    k(this, "_ensureGrammarCache");
    this._options = t, this._syncRegistry = new Cl(
      mt.createFromRawTheme(t.theme, t.colorMap),
      t.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(t, n) {
    this._syncRegistry.setTheme(mt.createFromRawTheme(t, n));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(t, n, u) {
    return this.loadGrammarWithConfiguration(t, n, { embeddedLanguages: u });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(t, n, u) {
    return this._loadGrammar(
      t,
      n,
      u.embeddedLanguages,
      u.tokenTypes,
      new xl(
        u.balancedBracketSelectors || [],
        u.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(t) {
    return this._loadGrammar(t, 0, null, null, null);
  }
  _loadGrammar(t, n, u, r, i) {
    const a = new Ys(this._syncRegistry, t);
    for (; a.Q.length > 0; )
      a.Q.map((o) => this._loadSingleGrammar(o.scopeName)), a.processQueue();
    return this._grammarForScopeName(
      t,
      n,
      u,
      r,
      i
    );
  }
  _loadSingleGrammar(t) {
    this._ensureGrammarCache.has(t) || (this._doLoadSingleGrammar(t), this._ensureGrammarCache.set(t, !0));
  }
  _doLoadSingleGrammar(t) {
    const n = this._options.loadGrammar(t);
    if (n) {
      const u = typeof this._options.getInjections == "function" ? this._options.getInjections(t) : void 0;
      this._syncRegistry.addGrammar(n, u);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(t, n = [], u = 0, r = null) {
    return this._syncRegistry.addGrammar(t, n), this._grammarForScopeName(t.scopeName, u, r);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(t, n = 0, u = null, r = null, i = null) {
    return this._syncRegistry.grammarForScopeName(
      t,
      n,
      u,
      r,
      i
    );
  }
}, mn = pn.NULL;
const Al = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
class et {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, u) {
    this.normal = n, this.property = t, u && (this.space = u);
  }
}
et.prototype.normal = {};
et.prototype.property = {};
et.prototype.space = void 0;
function Dr(e, t) {
  const n = {}, u = {};
  for (const r of e)
    Object.assign(n, r.property), Object.assign(u, r.normal);
  return new et(n, u, t);
}
function gn(e) {
  return e.toLowerCase();
}
class U {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
U.prototype.attribute = "";
U.prototype.booleanish = !1;
U.prototype.boolean = !1;
U.prototype.commaOrSpaceSeparated = !1;
U.prototype.commaSeparated = !1;
U.prototype.defined = !1;
U.prototype.mustUseProperty = !1;
U.prototype.number = !1;
U.prototype.overloadedBoolean = !1;
U.prototype.property = "";
U.prototype.spaceSeparated = !1;
U.prototype.space = void 0;
let El = 0;
const E = ke(), R = ke(), Fr = ke(), w = ke(), F = ke(), Ee = ke(), W = ke();
function ke() {
  return 2 ** ++El;
}
const _n = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: E,
  booleanish: R,
  commaOrSpaceSeparated: W,
  commaSeparated: Ee,
  number: w,
  overloadedBoolean: Fr,
  spaceSeparated: F
}, Symbol.toStringTag, { value: "Module" })), Jt = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(_n)
);
class Ln extends U {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, u, r) {
    let i = -1;
    if (super(t, n), xu(this, "space", r), typeof u == "number")
      for (; ++i < Jt.length; ) {
        const a = Jt[i];
        xu(this, Jt[i], (u & _n[a]) === _n[a]);
      }
  }
}
Ln.prototype.defined = !0;
function xu(e, t, n) {
  n && (e[t] = n);
}
function Pe(e) {
  const t = {}, n = {};
  for (const [u, r] of Object.entries(e.properties)) {
    const i = new Ln(
      u,
      e.transform(e.attributes || {}, u),
      r,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(u) && (i.mustUseProperty = !0), t[u] = i, n[gn(u)] = u, n[gn(i.attribute)] = u;
  }
  return new et(t, n, e.space);
}
const Tr = Pe({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: R,
    ariaAutoComplete: null,
    ariaBusy: R,
    ariaChecked: R,
    ariaColCount: w,
    ariaColIndex: w,
    ariaColSpan: w,
    ariaControls: F,
    ariaCurrent: null,
    ariaDescribedBy: F,
    ariaDetails: null,
    ariaDisabled: R,
    ariaDropEffect: F,
    ariaErrorMessage: null,
    ariaExpanded: R,
    ariaFlowTo: F,
    ariaGrabbed: R,
    ariaHasPopup: null,
    ariaHidden: R,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: F,
    ariaLevel: w,
    ariaLive: null,
    ariaModal: R,
    ariaMultiLine: R,
    ariaMultiSelectable: R,
    ariaOrientation: null,
    ariaOwns: F,
    ariaPlaceholder: null,
    ariaPosInSet: w,
    ariaPressed: R,
    ariaReadOnly: R,
    ariaRelevant: null,
    ariaRequired: R,
    ariaRoleDescription: F,
    ariaRowCount: w,
    ariaRowIndex: w,
    ariaRowSpan: w,
    ariaSelected: R,
    ariaSetSize: w,
    ariaSort: null,
    ariaValueMax: w,
    ariaValueMin: w,
    ariaValueNow: w,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function Rr(e, t) {
  return t in e ? e[t] : t;
}
function Lr(e, t) {
  return Rr(e, t.toLowerCase());
}
const Sl = Pe({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Ee,
    acceptCharset: F,
    accessKey: F,
    action: null,
    allow: null,
    allowFullScreen: E,
    allowPaymentRequest: E,
    allowUserMedia: E,
    alt: null,
    as: null,
    async: E,
    autoCapitalize: null,
    autoComplete: F,
    autoFocus: E,
    autoPlay: E,
    blocking: F,
    capture: null,
    charSet: null,
    checked: E,
    cite: null,
    className: F,
    cols: w,
    colSpan: null,
    content: null,
    contentEditable: R,
    controls: E,
    controlsList: F,
    coords: w | Ee,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: E,
    defer: E,
    dir: null,
    dirName: null,
    disabled: E,
    download: Fr,
    draggable: R,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: E,
    formTarget: null,
    headers: F,
    height: w,
    hidden: E,
    high: w,
    href: null,
    hrefLang: null,
    htmlFor: F,
    httpEquiv: F,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: E,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: E,
    itemId: null,
    itemProp: F,
    itemRef: F,
    itemScope: E,
    itemType: F,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: E,
    low: w,
    manifest: null,
    max: null,
    maxLength: w,
    media: null,
    method: null,
    min: null,
    minLength: w,
    multiple: E,
    muted: E,
    name: null,
    nonce: null,
    noModule: E,
    noValidate: E,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: E,
    optimum: w,
    pattern: null,
    ping: F,
    placeholder: null,
    playsInline: E,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: E,
    referrerPolicy: null,
    rel: F,
    required: E,
    reversed: E,
    rows: w,
    rowSpan: w,
    sandbox: F,
    scope: null,
    scoped: E,
    seamless: E,
    selected: E,
    shadowRootClonable: E,
    shadowRootDelegatesFocus: E,
    shadowRootMode: null,
    shape: null,
    size: w,
    sizes: null,
    slot: null,
    span: w,
    spellCheck: R,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: w,
    step: null,
    style: null,
    tabIndex: w,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: E,
    useMap: null,
    value: R,
    width: w,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: F,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: w,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: w,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: E,
    // Lists. Use CSS to reduce space between items instead
    declare: E,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: w,
    // `<img>` and `<object>`
    leftMargin: w,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: w,
    // `<body>`
    marginWidth: w,
    // `<body>`
    noResize: E,
    // `<frame>`
    noHref: E,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: E,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: E,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: w,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: R,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: w,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: w,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: E,
    disableRemotePlayback: E,
    prefix: null,
    property: null,
    results: w,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: Lr
}), Dl = Pe({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: W,
    accentHeight: w,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: w,
    amplitude: w,
    arabicForm: null,
    ascent: w,
    attributeName: null,
    attributeType: null,
    azimuth: w,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: w,
    by: null,
    calcMode: null,
    capHeight: w,
    className: F,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: w,
    diffuseConstant: w,
    direction: null,
    display: null,
    dur: null,
    divisor: w,
    dominantBaseline: null,
    download: E,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: w,
    enableBackground: null,
    end: null,
    event: null,
    exponent: w,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: w,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Ee,
    g2: Ee,
    glyphName: Ee,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: w,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: w,
    horizOriginX: w,
    horizOriginY: w,
    id: null,
    ideographic: w,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: w,
    k: w,
    k1: w,
    k2: w,
    k3: w,
    k4: w,
    kernelMatrix: W,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: w,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: w,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: w,
    overlineThickness: w,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: w,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: F,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: w,
    pointsAtY: w,
    pointsAtZ: w,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: W,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: W,
    rev: W,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: W,
    requiredFeatures: W,
    requiredFonts: W,
    requiredFormats: W,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: w,
    specularExponent: w,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: w,
    strikethroughThickness: w,
    string: null,
    stroke: null,
    strokeDashArray: W,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: w,
    strokeOpacity: w,
    strokeWidth: null,
    style: null,
    surfaceScale: w,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: W,
    tabIndex: w,
    tableValues: null,
    target: null,
    targetX: w,
    targetY: w,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: W,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: w,
    underlineThickness: w,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: w,
    values: null,
    vAlphabetic: w,
    vMathematical: w,
    vectorEffect: null,
    vHanging: w,
    vIdeographic: w,
    version: null,
    vertAdvY: w,
    vertOriginX: w,
    vertOriginY: w,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: w,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: Rr
}), Pr = Pe({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), Nr = Pe({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: Lr
}), Ir = Pe({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), Fl = /[A-Z]/g, wu = /-[a-z]/g, Tl = /^data[-\w.:]+$/i;
function Rl(e, t) {
  const n = gn(t);
  let u = t, r = U;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Tl.test(t)) {
    if (t.charAt(4) === "-") {
      const i = t.slice(5).replace(wu, Pl);
      u = "data" + i.charAt(0).toUpperCase() + i.slice(1);
    } else {
      const i = t.slice(4);
      if (!wu.test(i)) {
        let a = i.replace(Fl, Ll);
        a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
      }
    }
    r = Ln;
  }
  return new r(u, t);
}
function Ll(e) {
  return "-" + e.toLowerCase();
}
function Pl(e) {
  return e.charAt(1).toUpperCase();
}
const Nl = Dr([Tr, Sl, Pr, Nr, Ir], "html"), Mr = Dr([Tr, Dl, Pr, Nr, Ir], "svg"), Cu = {}.hasOwnProperty;
function Il(e, t) {
  const n = t || {};
  function u(r, ...i) {
    let a = u.invalid;
    const o = u.handlers;
    if (r && Cu.call(r, e)) {
      const s = String(r[e]);
      a = Cu.call(o, s) ? o[s] : u.unknown;
    }
    if (a)
      return a.call(this, r, ...i);
  }
  return u.handlers = n.handlers || {}, u.invalid = n.invalid, u.unknown = n.unknown, u;
}
const Ml = /["&'<>`]/g, Ol = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, Bl = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), jl = /[|\\{}()[\]^$+*?.]/g, vu = /* @__PURE__ */ new WeakMap();
function zl(e, t) {
  if (e = e.replace(
    t.subset ? $l(t.subset) : Ml,
    u
  ), t.subset || t.escapeOnly)
    return e;
  return e.replace(Ol, n).replace(Bl, u);
  function n(r, i, a) {
    return t.format(
      (r.charCodeAt(0) - 55296) * 1024 + r.charCodeAt(1) - 56320 + 65536,
      a.charCodeAt(i + 2),
      t
    );
  }
  function u(r, i, a) {
    return t.format(
      r.charCodeAt(0),
      a.charCodeAt(i + 1),
      t
    );
  }
}
function $l(e) {
  let t = vu.get(e);
  return t || (t = ql(e), vu.set(e, t)), t;
}
function ql(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t.push(e[n].replace(jl, "\\$&"));
  return new RegExp("(?:" + t.join("|") + ")", "g");
}
const Gl = /[\dA-Fa-f]/;
function Hl(e, t, n) {
  const u = "&#x" + e.toString(16).toUpperCase();
  return n && t && !Gl.test(String.fromCharCode(t)) ? u : u + ";";
}
const Ul = /\d/;
function Wl(e, t, n) {
  const u = "&#" + String(e);
  return n && t && !Ul.test(String.fromCharCode(t)) ? u : u + ";";
}
const Vl = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], Kt = {
  nbsp: "Â ",
  iexcl: "Â¡",
  cent: "Â¢",
  pound: "Â£",
  curren: "Â¤",
  yen: "Â¥",
  brvbar: "Â¦",
  sect: "Â§",
  uml: "Â¨",
  copy: "Â©",
  ordf: "Âª",
  laquo: "Â«",
  not: "Â¬",
  shy: "Â­",
  reg: "Â®",
  macr: "Â¯",
  deg: "Â°",
  plusmn: "Â±",
  sup2: "Â²",
  sup3: "Â³",
  acute: "Â´",
  micro: "Âµ",
  para: "Â¶",
  middot: "Â·",
  cedil: "Â¸",
  sup1: "Â¹",
  ordm: "Âº",
  raquo: "Â»",
  frac14: "Â¼",
  frac12: "Â½",
  frac34: "Â¾",
  iquest: "Â¿",
  Agrave: "Ã€",
  Aacute: "Ã",
  Acirc: "Ã‚",
  Atilde: "Ãƒ",
  Auml: "Ã„",
  Aring: "Ã…",
  AElig: "Ã†",
  Ccedil: "Ã‡",
  Egrave: "Ãˆ",
  Eacute: "Ã‰",
  Ecirc: "ÃŠ",
  Euml: "Ã‹",
  Igrave: "ÃŒ",
  Iacute: "Ã",
  Icirc: "Ã",
  Iuml: "Ã",
  ETH: "Ã",
  Ntilde: "Ã‘",
  Ograve: "Ã’",
  Oacute: "Ã“",
  Ocirc: "Ã”",
  Otilde: "Ã•",
  Ouml: "Ã–",
  times: "Ã—",
  Oslash: "Ã˜",
  Ugrave: "Ã™",
  Uacute: "Ãš",
  Ucirc: "Ã›",
  Uuml: "Ãœ",
  Yacute: "Ã",
  THORN: "Ã",
  szlig: "ÃŸ",
  agrave: "Ã ",
  aacute: "Ã¡",
  acirc: "Ã¢",
  atilde: "Ã£",
  auml: "Ã¤",
  aring: "Ã¥",
  aelig: "Ã¦",
  ccedil: "Ã§",
  egrave: "Ã¨",
  eacute: "Ã©",
  ecirc: "Ãª",
  euml: "Ã«",
  igrave: "Ã¬",
  iacute: "Ã­",
  icirc: "Ã®",
  iuml: "Ã¯",
  eth: "Ã°",
  ntilde: "Ã±",
  ograve: "Ã²",
  oacute: "Ã³",
  ocirc: "Ã´",
  otilde: "Ãµ",
  ouml: "Ã¶",
  divide: "Ã·",
  oslash: "Ã¸",
  ugrave: "Ã¹",
  uacute: "Ãº",
  ucirc: "Ã»",
  uuml: "Ã¼",
  yacute: "Ã½",
  thorn: "Ã¾",
  yuml: "Ã¿",
  fnof: "Æ’",
  Alpha: "Î‘",
  Beta: "Î’",
  Gamma: "Î“",
  Delta: "Î”",
  Epsilon: "Î•",
  Zeta: "Î–",
  Eta: "Î—",
  Theta: "Î˜",
  Iota: "Î™",
  Kappa: "Îš",
  Lambda: "Î›",
  Mu: "Îœ",
  Nu: "Î",
  Xi: "Î",
  Omicron: "ÎŸ",
  Pi: "Î ",
  Rho: "Î¡",
  Sigma: "Î£",
  Tau: "Î¤",
  Upsilon: "Î¥",
  Phi: "Î¦",
  Chi: "Î§",
  Psi: "Î¨",
  Omega: "Î©",
  alpha: "Î±",
  beta: "Î²",
  gamma: "Î³",
  delta: "Î´",
  epsilon: "Îµ",
  zeta: "Î¶",
  eta: "Î·",
  theta: "Î¸",
  iota: "Î¹",
  kappa: "Îº",
  lambda: "Î»",
  mu: "Î¼",
  nu: "Î½",
  xi: "Î¾",
  omicron: "Î¿",
  pi: "Ï€",
  rho: "Ï",
  sigmaf: "Ï‚",
  sigma: "Ïƒ",
  tau: "Ï„",
  upsilon: "Ï…",
  phi: "Ï†",
  chi: "Ï‡",
  psi: "Ïˆ",
  omega: "Ï‰",
  thetasym: "Ï‘",
  upsih: "Ï’",
  piv: "Ï–",
  bull: "â€¢",
  hellip: "â€¦",
  prime: "â€²",
  Prime: "â€³",
  oline: "â€¾",
  frasl: "â„",
  weierp: "â„˜",
  image: "â„‘",
  real: "â„œ",
  trade: "â„¢",
  alefsym: "â„µ",
  larr: "â†",
  uarr: "â†‘",
  rarr: "â†’",
  darr: "â†“",
  harr: "â†”",
  crarr: "â†µ",
  lArr: "â‡",
  uArr: "â‡‘",
  rArr: "â‡’",
  dArr: "â‡“",
  hArr: "â‡”",
  forall: "âˆ€",
  part: "âˆ‚",
  exist: "âˆƒ",
  empty: "âˆ…",
  nabla: "âˆ‡",
  isin: "âˆˆ",
  notin: "âˆ‰",
  ni: "âˆ‹",
  prod: "âˆ",
  sum: "âˆ‘",
  minus: "âˆ’",
  lowast: "âˆ—",
  radic: "âˆš",
  prop: "âˆ",
  infin: "âˆ",
  ang: "âˆ ",
  and: "âˆ§",
  or: "âˆ¨",
  cap: "âˆ©",
  cup: "âˆª",
  int: "âˆ«",
  there4: "âˆ´",
  sim: "âˆ¼",
  cong: "â‰…",
  asymp: "â‰ˆ",
  ne: "â‰ ",
  equiv: "â‰¡",
  le: "â‰¤",
  ge: "â‰¥",
  sub: "âŠ‚",
  sup: "âŠƒ",
  nsub: "âŠ„",
  sube: "âŠ†",
  supe: "âŠ‡",
  oplus: "âŠ•",
  otimes: "âŠ—",
  perp: "âŠ¥",
  sdot: "â‹…",
  lceil: "âŒˆ",
  rceil: "âŒ‰",
  lfloor: "âŒŠ",
  rfloor: "âŒ‹",
  lang: "âŒ©",
  rang: "âŒª",
  loz: "â—Š",
  spades: "â™ ",
  clubs: "â™£",
  hearts: "â™¥",
  diams: "â™¦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Å’",
  oelig: "Å“",
  Scaron: "Å ",
  scaron: "Å¡",
  Yuml: "Å¸",
  circ: "Ë†",
  tilde: "Ëœ",
  ensp: "â€‚",
  emsp: "â€ƒ",
  thinsp: "â€‰",
  zwnj: "â€Œ",
  zwj: "â€",
  lrm: "â€",
  rlm: "â€",
  ndash: "â€“",
  mdash: "â€”",
  lsquo: "â€˜",
  rsquo: "â€™",
  sbquo: "â€š",
  ldquo: "â€œ",
  rdquo: "â€",
  bdquo: "â€",
  dagger: "â€ ",
  Dagger: "â€¡",
  permil: "â€°",
  lsaquo: "â€¹",
  rsaquo: "â€º",
  euro: "â‚¬"
}, Zl = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], Or = {}.hasOwnProperty, bn = {};
let rt;
for (rt in Kt)
  Or.call(Kt, rt) && (bn[Kt[rt]] = rt);
const Jl = /[^\dA-Za-z]/;
function Kl(e, t, n, u) {
  const r = String.fromCharCode(e);
  if (Or.call(bn, r)) {
    const i = bn[r], a = "&" + i;
    return n && Vl.includes(i) && !Zl.includes(i) && (!u || t && t !== 61 && Jl.test(String.fromCharCode(t))) ? a : a + ";";
  }
  return "";
}
function Ql(e, t, n) {
  let u = Hl(e, t, n.omitOptionalSemicolons), r;
  if ((n.useNamedReferences || n.useShortestReferences) && (r = Kl(
    e,
    t,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !r) && n.useShortestReferences) {
    const i = Wl(e, t, n.omitOptionalSemicolons);
    i.length < u.length && (u = i);
  }
  return r && (!n.useShortestReferences || r.length < u.length) ? r : u;
}
function Se(e, t) {
  return zl(e, Object.assign({ format: Ql }, t));
}
const Xl = /^>|^->|<!--|-->|--!>|<!-$/g, Yl = [">"], ec = ["<", ">"];
function tc(e, t, n, u) {
  return u.settings.bogusComments ? "<?" + Se(
    e.value,
    Object.assign({}, u.settings.characterReferences, {
      subset: Yl
    })
  ) + ">" : "<!--" + e.value.replace(Xl, r) + "-->";
  function r(i) {
    return Se(
      i,
      Object.assign({}, u.settings.characterReferences, {
        subset: ec
      })
    );
  }
}
function nc(e, t, n, u) {
  return "<!" + (u.settings.upperDoctype ? "DOCTYPE" : "doctype") + (u.settings.tightDoctype ? "" : " ") + "html>";
}
function Au(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let u = 0, r = n.indexOf(t);
  for (; r !== -1; )
    u++, r = n.indexOf(t, r + t.length);
  return u;
}
function uc(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
function rc(e) {
  return e.join(" ").trim();
}
const ic = /[ \t\n\f\r]/g;
function Pn(e) {
  return typeof e == "object" ? e.type === "text" ? Eu(e.value) : !1 : Eu(e);
}
function Eu(e) {
  return e.replace(ic, "") === "";
}
const I = jr(1), Br = jr(-1), ac = [];
function jr(e) {
  return t;
  function t(n, u, r) {
    const i = n ? n.children : ac;
    let a = (u || 0) + e, o = i[a];
    if (!r)
      for (; o && Pn(o); )
        a += e, o = i[a];
    return o;
  }
}
const oc = {}.hasOwnProperty;
function zr(e) {
  return t;
  function t(n, u, r) {
    return oc.call(e, n.tagName) && e[n.tagName](n, u, r);
  }
}
const Nn = zr({
  body: lc,
  caption: Qt,
  colgroup: Qt,
  dd: hc,
  dt: fc,
  head: Qt,
  html: sc,
  li: dc,
  optgroup: pc,
  option: mc,
  p: cc,
  rp: Su,
  rt: Su,
  tbody: _c,
  td: Du,
  tfoot: bc,
  th: Du,
  thead: gc,
  tr: yc
});
function Qt(e, t, n) {
  const u = I(n, t, !0);
  return !u || u.type !== "comment" && !(u.type === "text" && Pn(u.value.charAt(0)));
}
function sc(e, t, n) {
  const u = I(n, t);
  return !u || u.type !== "comment";
}
function lc(e, t, n) {
  const u = I(n, t);
  return !u || u.type !== "comment";
}
function cc(e, t, n) {
  const u = I(n, t);
  return u ? u.type === "element" && (u.tagName === "address" || u.tagName === "article" || u.tagName === "aside" || u.tagName === "blockquote" || u.tagName === "details" || u.tagName === "div" || u.tagName === "dl" || u.tagName === "fieldset" || u.tagName === "figcaption" || u.tagName === "figure" || u.tagName === "footer" || u.tagName === "form" || u.tagName === "h1" || u.tagName === "h2" || u.tagName === "h3" || u.tagName === "h4" || u.tagName === "h5" || u.tagName === "h6" || u.tagName === "header" || u.tagName === "hgroup" || u.tagName === "hr" || u.tagName === "main" || u.tagName === "menu" || u.tagName === "nav" || u.tagName === "ol" || u.tagName === "p" || u.tagName === "pre" || u.tagName === "section" || u.tagName === "table" || u.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function dc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && u.tagName === "li";
}
function fc(e, t, n) {
  const u = I(n, t);
  return !!(u && u.type === "element" && (u.tagName === "dt" || u.tagName === "dd"));
}
function hc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "dt" || u.tagName === "dd");
}
function Su(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "rp" || u.tagName === "rt");
}
function pc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && u.tagName === "optgroup";
}
function mc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "option" || u.tagName === "optgroup");
}
function gc(e, t, n) {
  const u = I(n, t);
  return !!(u && u.type === "element" && (u.tagName === "tbody" || u.tagName === "tfoot"));
}
function _c(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "tbody" || u.tagName === "tfoot");
}
function bc(e, t, n) {
  return !I(n, t);
}
function yc(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && u.tagName === "tr";
}
function Du(e, t, n) {
  const u = I(n, t);
  return !u || u.type === "element" && (u.tagName === "td" || u.tagName === "th");
}
const kc = zr({
  body: Cc,
  colgroup: vc,
  head: wc,
  html: xc,
  tbody: Ac
});
function xc(e) {
  const t = I(e, -1);
  return !t || t.type !== "comment";
}
function wc(e) {
  const t = /* @__PURE__ */ new Set();
  for (const u of e.children)
    if (u.type === "element" && (u.tagName === "base" || u.tagName === "title")) {
      if (t.has(u.tagName)) return !1;
      t.add(u.tagName);
    }
  const n = e.children[0];
  return !n || n.type === "element";
}
function Cc(e) {
  const t = I(e, -1, !0);
  return !t || t.type !== "comment" && !(t.type === "text" && Pn(t.value.charAt(0))) && !(t.type === "element" && (t.tagName === "meta" || t.tagName === "link" || t.tagName === "script" || t.tagName === "style" || t.tagName === "template"));
}
function vc(e, t, n) {
  const u = Br(n, t), r = I(e, -1, !0);
  return n && u && u.type === "element" && u.tagName === "colgroup" && Nn(u, n.children.indexOf(u), n) ? !1 : !!(r && r.type === "element" && r.tagName === "col");
}
function Ac(e, t, n) {
  const u = Br(n, t), r = I(e, -1);
  return n && u && u.type === "element" && (u.tagName === "thead" || u.tagName === "tbody") && Nn(u, n.children.indexOf(u), n) ? !1 : !!(r && r.type === "element" && r.tagName === "tr");
}
const it = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function Ec(e, t, n, u) {
  const r = u.schema, i = r.space === "svg" ? !1 : u.settings.omitOptionalTags;
  let a = r.space === "svg" ? u.settings.closeEmptyElements : u.settings.voids.includes(e.tagName.toLowerCase());
  const o = [];
  let s;
  r.space === "html" && e.tagName === "svg" && (u.schema = Mr);
  const l = Sc(u, e.properties), c = u.all(
    r.space === "html" && e.tagName === "template" ? e.content : e
  );
  return u.schema = r, c && (a = !1), (l || !i || !kc(e, t, n)) && (o.push("<", e.tagName, l ? " " + l : ""), a && (r.space === "svg" || u.settings.closeSelfClosing) && (s = l.charAt(l.length - 1), (!u.settings.tightSelfClosing || s === "/" || s && s !== '"' && s !== "'") && o.push(" "), o.push("/")), o.push(">")), o.push(c), !a && (!i || !Nn(e, t, n)) && o.push("</" + e.tagName + ">"), o.join("");
}
function Sc(e, t) {
  const n = [];
  let u = -1, r;
  if (t) {
    for (r in t)
      if (t[r] !== null && t[r] !== void 0) {
        const i = Dc(e, r, t[r]);
        i && n.push(i);
      }
  }
  for (; ++u < n.length; ) {
    const i = e.settings.tightAttributes ? n[u].charAt(n[u].length - 1) : void 0;
    u !== n.length - 1 && i !== '"' && i !== "'" && (n[u] += " ");
  }
  return n.join("");
}
function Dc(e, t, n) {
  const u = Rl(e.schema, t), r = e.settings.allowParseErrors && e.schema.space === "html" ? 0 : 1, i = e.settings.allowDangerousCharacters ? 0 : 1;
  let a = e.quote, o;
  if (u.overloadedBoolean && (n === u.attribute || n === "") ? n = !0 : (u.boolean || u.overloadedBoolean) && (typeof n != "string" || n === u.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const s = Se(
    u.attribute,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: it.name[r][i]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (u.commaSeparated ? uc : rc)(n, {
    padLeft: !e.settings.tightCommaSeparatedLists
  }) : String(n), e.settings.collapseEmptyAttributes && !n) ? s : (e.settings.preferUnquoted && (o = Se(
    n,
    Object.assign({}, e.settings.characterReferences, {
      attribute: !0,
      subset: it.unquoted[r][i]
    })
  )), o !== n && (e.settings.quoteSmart && Au(n, a) > Au(n, e.alternative) && (a = e.alternative), o = a + Se(
    n,
    Object.assign({}, e.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (a === "'" ? it.single : it.double)[r][i],
      attribute: !0
    })
  ) + a), s + (o && "=" + o));
}
const Fc = ["<", "&"];
function $r(e, t, n, u) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? e.value : Se(
    e.value,
    Object.assign({}, u.settings.characterReferences, {
      subset: Fc
    })
  );
}
function Tc(e, t, n, u) {
  return u.settings.allowDangerousHtml ? e.value : $r(e, t, n, u);
}
function Rc(e, t, n, u) {
  return u.all(e);
}
const Lc = Il("type", {
  invalid: Pc,
  unknown: Nc,
  handlers: { comment: tc, doctype: nc, element: Ec, raw: Tc, root: Rc, text: $r }
});
function Pc(e) {
  throw new Error("Expected node, not `" + e + "`");
}
function Nc(e) {
  const t = (
    /** @type {Nodes} */
    e
  );
  throw new Error("Cannot compile unknown node `" + t.type + "`");
}
const Ic = {}, Mc = {}, Oc = [];
function Bc(e, t) {
  const n = t || Ic, u = n.quote || '"', r = u === '"' ? "'" : '"';
  if (u !== '"' && u !== "'")
    throw new Error("Invalid quote `" + u + "`, expected `'` or `\"`");
  return {
    one: jc,
    all: zc,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || Al,
      characterReferences: n.characterReferences || Mc,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? Mr : Nl,
    quote: u,
    alternative: r
  }.one(
    Array.isArray(e) ? { type: "root", children: e } : e,
    void 0,
    void 0
  );
}
function jc(e, t, n) {
  return Lc(e, t, n, this);
}
function zc(e) {
  const t = [], n = e && e.children || Oc;
  let u = -1;
  for (; ++u < n.length; )
    t[u] = this.one(n[u], u, e);
  return t.join("");
}
function kt(e, t) {
  const n = typeof e == "string" ? {} : { ...e.colorReplacements }, u = typeof e == "string" ? e : e.name;
  for (const [r, i] of Object.entries((t == null ? void 0 : t.colorReplacements) || {}))
    typeof i == "string" ? n[r] = i : r === u && Object.assign(n, i);
  return n;
}
function be(e, t) {
  return e && ((t == null ? void 0 : t[e == null ? void 0 : e.toLowerCase()]) || e);
}
function $c(e) {
  return Array.isArray(e) ? e : [e];
}
async function qr(e) {
  return Promise.resolve(typeof e == "function" ? e() : e).then((t) => t.default || t);
}
function In(e) {
  return !e || ["plaintext", "txt", "text", "plain"].includes(e);
}
function Gr(e) {
  return e === "ansi" || In(e);
}
function Mn(e) {
  return e === "none";
}
function Hr(e) {
  return Mn(e);
}
function Ur(e, t) {
  var u;
  if (!t)
    return e;
  e.properties || (e.properties = {}), (u = e.properties).class || (u.class = []), typeof e.properties.class == "string" && (e.properties.class = e.properties.class.split(/\s+/g)), Array.isArray(e.properties.class) || (e.properties.class = []);
  const n = Array.isArray(t) ? t : t.split(/\s+/g);
  for (const r of n)
    r && !e.properties.class.includes(r) && e.properties.class.push(r);
  return e;
}
function Lt(e, t = !1) {
  var i;
  const n = e.split(/(\r?\n)/g);
  let u = 0;
  const r = [];
  for (let a = 0; a < n.length; a += 2) {
    const o = t ? n[a] + (n[a + 1] || "") : n[a];
    r.push([o, u]), u += n[a].length, u += ((i = n[a + 1]) == null ? void 0 : i.length) || 0;
  }
  return r;
}
function qc(e) {
  const t = Lt(e, !0).map(([r]) => r);
  function n(r) {
    if (r === e.length)
      return {
        line: t.length - 1,
        character: t[t.length - 1].length
      };
    let i = r, a = 0;
    for (const o of t) {
      if (i < o.length)
        break;
      i -= o.length, a++;
    }
    return { line: a, character: i };
  }
  function u(r, i) {
    let a = 0;
    for (let o = 0; o < r; o++)
      a += t[o].length;
    return a += i, a;
  }
  return {
    lines: t,
    indexToPos: n,
    posToIndex: u
  };
}
function Gc(e, t) {
  let n = 0;
  const u = [];
  for (const r of t)
    r > n && u.push({
      ...e,
      content: e.content.slice(n, r),
      offset: e.offset + n
    }), n = r;
  return n < e.content.length && u.push({
    ...e,
    content: e.content.slice(n),
    offset: e.offset + n
  }), u;
}
function Hc(e, t) {
  const n = Array.from(t instanceof Set ? t : new Set(t)).sort((u, r) => u - r);
  return n.length ? e.map((u) => u.flatMap((r) => {
    const i = n.filter((a) => r.offset < a && a < r.offset + r.content.length).map((a) => a - r.offset).sort((a, o) => a - o);
    return i.length ? Gc(r, i) : r;
  })) : e;
}
function Uc(e, t, n, u) {
  const r = {
    content: e.content,
    explanation: e.explanation,
    offset: e.offset
  }, i = t.map((s) => Wr(e.variants[s])), a = new Set(i.flatMap((s) => Object.keys(s))), o = {};
  return i.forEach((s, l) => {
    for (const c of a) {
      const d = s[c] || "inherit";
      if (l === 0 && u)
        o[c] = d;
      else {
        const f = c === "color" ? "" : c === "background-color" ? "-bg" : `-${c}`, p = n + t[l] + (c === "color" ? "" : f);
        o[p] = d;
      }
    }
  }), r.htmlStyle = o, r;
}
function Wr(e) {
  const t = {};
  return e.color && (t.color = e.color), e.bgColor && (t["background-color"] = e.bgColor), e.fontStyle && (e.fontStyle & ce.Italic && (t["font-style"] = "italic"), e.fontStyle & ce.Bold && (t["font-weight"] = "bold"), e.fontStyle & ce.Underline && (t["text-decoration"] = "underline")), t;
}
function Wc(e) {
  return typeof e == "string" ? e : Object.entries(e).map(([t, n]) => `${t}:${n}`).join(";");
}
const Vr = /* @__PURE__ */ new WeakMap();
function Pt(e, t) {
  Vr.set(e, t);
}
function Ze(e) {
  return Vr.get(e);
}
class Ne {
  constructor(...t) {
    /**
     * Theme to Stack mapping
     */
    k(this, "_stacks", {});
    k(this, "lang");
    if (t.length === 2) {
      const [n, u] = t;
      this.lang = u, this._stacks = n;
    } else {
      const [n, u, r] = t;
      this.lang = u, this._stacks = { [r]: n };
    }
  }
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(t, n) {
    return new Ne(
      Object.fromEntries($c(n).map((u) => [u, mn])),
      t
    );
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(t = this.theme) {
    return this._stacks[t];
  }
  getScopes(t = this.theme) {
    return Vc(this._stacks[t]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.getScopes()
    };
  }
}
function Vc(e) {
  const t = [], n = /* @__PURE__ */ new Set();
  function u(r) {
    var a;
    if (n.has(r))
      return;
    n.add(r);
    const i = (a = r == null ? void 0 : r.nameScopesList) == null ? void 0 : a.scopeName;
    i && t.push(i), r.parent && u(r.parent);
  }
  return u(e), t;
}
function Zc(e, t) {
  if (!(e instanceof Ne))
    throw new j("Invalid grammar state");
  return e.getInternalStack(t);
}
function Jc() {
  const e = /* @__PURE__ */ new WeakMap();
  function t(n) {
    if (!e.has(n.meta)) {
      let u = function(a) {
        if (typeof a == "number") {
          if (a < 0 || a > n.source.length)
            throw new j(`Invalid decoration offset: ${a}. Code length: ${n.source.length}`);
          return {
            ...r.indexToPos(a),
            offset: a
          };
        } else {
          const o = r.lines[a.line];
          if (o === void 0)
            throw new j(`Invalid decoration position ${JSON.stringify(a)}. Lines length: ${r.lines.length}`);
          if (a.character < 0 || a.character > o.length)
            throw new j(`Invalid decoration position ${JSON.stringify(a)}. Line ${a.line} length: ${o.length}`);
          return {
            ...a,
            offset: r.posToIndex(a.line, a.character)
          };
        }
      };
      const r = qc(n.source), i = (n.options.decorations || []).map((a) => ({
        ...a,
        start: u(a.start),
        end: u(a.end)
      }));
      Kc(i), e.set(n.meta, {
        decorations: i,
        converter: r,
        source: n.source
      });
    }
    return e.get(n.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(n) {
      var a;
      if (!((a = this.options.decorations) != null && a.length))
        return;
      const r = t(this).decorations.flatMap((o) => [o.start.offset, o.end.offset]);
      return Hc(n, r);
    },
    code(n) {
      var c;
      if (!((c = this.options.decorations) != null && c.length))
        return;
      const u = t(this), r = Array.from(n.children).filter((d) => d.type === "element" && d.tagName === "span");
      if (r.length !== u.converter.lines.length)
        throw new j(`Number of lines in code element (${r.length}) does not match the number of lines in the source (${u.converter.lines.length}). Failed to apply decorations.`);
      function i(d, f, p, h) {
        const g = r[d];
        let m = "", b = -1, _ = -1;
        if (f === 0 && (b = 0), p === 0 && (_ = 0), p === Number.POSITIVE_INFINITY && (_ = g.children.length), b === -1 || _ === -1)
          for (let x = 0; x < g.children.length; x++)
            m += Zr(g.children[x]), b === -1 && m.length === f && (b = x + 1), _ === -1 && m.length === p && (_ = x + 1);
        if (b === -1)
          throw new j(`Failed to find start index for decoration ${JSON.stringify(h.start)}`);
        if (_ === -1)
          throw new j(`Failed to find end index for decoration ${JSON.stringify(h.end)}`);
        const y = g.children.slice(b, _);
        if (!h.alwaysWrap && y.length === g.children.length)
          o(g, h, "line");
        else if (!h.alwaysWrap && y.length === 1 && y[0].type === "element")
          o(y[0], h, "token");
        else {
          const x = {
            type: "element",
            tagName: "span",
            properties: {},
            children: y
          };
          o(x, h, "wrapper"), g.children.splice(b, y.length, x);
        }
      }
      function a(d, f) {
        r[d] = o(r[d], f, "line");
      }
      function o(d, f, p) {
        var m;
        const h = f.properties || {}, g = f.transform || ((b) => b);
        return d.tagName = f.tagName || "span", d.properties = {
          ...d.properties,
          ...h,
          class: d.properties.class
        }, (m = f.properties) != null && m.class && Ur(d, f.properties.class), d = g(d, p) || d, d;
      }
      const s = [], l = u.decorations.sort((d, f) => f.start.offset - d.start.offset || d.end.offset - f.end.offset);
      for (const d of l) {
        const { start: f, end: p } = d;
        if (f.line === p.line)
          i(f.line, f.character, p.character, d);
        else if (f.line < p.line) {
          i(f.line, f.character, Number.POSITIVE_INFINITY, d);
          for (let h = f.line + 1; h < p.line; h++)
            s.unshift(() => a(h, d));
          i(p.line, 0, p.character, d);
        }
      }
      s.forEach((d) => d());
    }
  };
}
function Kc(e) {
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    if (n.start.offset > n.end.offset)
      throw new j(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`);
    for (let u = t + 1; u < e.length; u++) {
      const r = e[u], i = n.start.offset <= r.start.offset && r.start.offset < n.end.offset, a = n.start.offset < r.end.offset && r.end.offset <= n.end.offset, o = r.start.offset <= n.start.offset && n.start.offset < r.end.offset, s = r.start.offset < n.end.offset && n.end.offset <= r.end.offset;
      if (i || a || o || s) {
        if (i && a || o && s)
          continue;
        throw new j(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(r.start)} intersect.`);
      }
    }
  }
}
function Zr(e) {
  return e.type === "text" ? e.value : e.type === "element" ? e.children.map(Zr).join("") : "";
}
const Qc = [
  /* @__PURE__ */ Jc()
];
function xt(e) {
  return [
    ...e.transformers || [],
    ...Qc
  ];
}
var ye = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], Xt = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  8: "hidden",
  9: "strikethrough"
};
function Xc(e, t) {
  const n = e.indexOf("\x1B", t);
  if (n !== -1 && e[n + 1] === "[") {
    const u = e.indexOf("m", n);
    if (u !== -1)
      return {
        sequence: e.substring(n + 2, u).split(";"),
        startPosition: n,
        position: u + 1
      };
  }
  return {
    position: e.length
  };
}
function Fu(e) {
  const t = e.shift();
  if (t === "2") {
    const n = e.splice(0, 3).map((u) => Number.parseInt(u));
    return n.length !== 3 || n.some((u) => Number.isNaN(u)) ? void 0 : {
      type: "rgb",
      rgb: n
    };
  } else if (t === "5") {
    const n = e.shift();
    if (n)
      return { type: "table", index: Number(n) };
  }
}
function Yc(e) {
  const t = [];
  for (; e.length > 0; ) {
    const n = e.shift();
    if (!n)
      continue;
    const u = Number.parseInt(n);
    if (!Number.isNaN(u))
      if (u === 0)
        t.push({ type: "resetAll" });
      else if (u <= 9)
        Xt[u] && t.push({
          type: "setDecoration",
          value: Xt[u]
        });
      else if (u <= 29) {
        const r = Xt[u - 20];
        r && (t.push({
          type: "resetDecoration",
          value: r
        }), r === "dim" && t.push({
          type: "resetDecoration",
          value: "bold"
        }));
      } else if (u <= 37)
        t.push({
          type: "setForegroundColor",
          value: { type: "named", name: ye[u - 30] }
        });
      else if (u === 38) {
        const r = Fu(e);
        r && t.push({
          type: "setForegroundColor",
          value: r
        });
      } else if (u === 39)
        t.push({
          type: "resetForegroundColor"
        });
      else if (u <= 47)
        t.push({
          type: "setBackgroundColor",
          value: { type: "named", name: ye[u - 40] }
        });
      else if (u === 48) {
        const r = Fu(e);
        r && t.push({
          type: "setBackgroundColor",
          value: r
        });
      } else u === 49 ? t.push({
        type: "resetBackgroundColor"
      }) : u === 53 ? t.push({
        type: "setDecoration",
        value: "overline"
      }) : u === 55 ? t.push({
        type: "resetDecoration",
        value: "overline"
      }) : u >= 90 && u <= 97 ? t.push({
        type: "setForegroundColor",
        value: { type: "named", name: ye[u - 90 + 8] }
      }) : u >= 100 && u <= 107 && t.push({
        type: "setBackgroundColor",
        value: { type: "named", name: ye[u - 100 + 8] }
      });
  }
  return t;
}
function e0() {
  let e = null, t = null, n = /* @__PURE__ */ new Set();
  return {
    parse(u) {
      const r = [];
      let i = 0;
      do {
        const a = Xc(u, i), o = a.sequence ? u.substring(i, a.startPosition) : u.substring(i);
        if (o.length > 0 && r.push({
          value: o,
          foreground: e,
          background: t,
          decorations: new Set(n)
        }), a.sequence) {
          const s = Yc(a.sequence);
          for (const l of s)
            l.type === "resetAll" ? (e = null, t = null, n.clear()) : l.type === "resetForegroundColor" ? e = null : l.type === "resetBackgroundColor" ? t = null : l.type === "resetDecoration" && n.delete(l.value);
          for (const l of s)
            l.type === "setForegroundColor" ? e = l.value : l.type === "setBackgroundColor" ? t = l.value : l.type === "setDecoration" && n.add(l.value);
        }
        i = a.position;
      } while (i < u.length);
      return r;
    }
  };
}
var t0 = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function n0(e = t0) {
  function t(o) {
    return e[o];
  }
  function n(o) {
    return `#${o.map((s) => Math.max(0, Math.min(s, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let u;
  function r() {
    if (u)
      return u;
    u = [];
    for (let l = 0; l < ye.length; l++)
      u.push(t(ye[l]));
    let o = [0, 95, 135, 175, 215, 255];
    for (let l = 0; l < 6; l++)
      for (let c = 0; c < 6; c++)
        for (let d = 0; d < 6; d++)
          u.push(n([o[l], o[c], o[d]]));
    let s = 8;
    for (let l = 0; l < 24; l++, s += 10)
      u.push(n([s, s, s]));
    return u;
  }
  function i(o) {
    return r()[o];
  }
  function a(o) {
    switch (o.type) {
      case "named":
        return t(o.name);
      case "rgb":
        return n(o.rgb);
      case "table":
        return i(o.index);
    }
  }
  return {
    value: a
  };
}
function u0(e, t, n) {
  const u = kt(e, n), r = Lt(t), i = n0(
    Object.fromEntries(
      ye.map((o) => {
        var s;
        return [
          o,
          (s = e.colors) == null ? void 0 : s[`terminal.ansi${o[0].toUpperCase()}${o.substring(1)}`]
        ];
      })
    )
  ), a = e0();
  return r.map(
    (o) => a.parse(o[0]).map((s) => {
      let l, c;
      s.decorations.has("reverse") ? (l = s.background ? i.value(s.background) : e.bg, c = s.foreground ? i.value(s.foreground) : e.fg) : (l = s.foreground ? i.value(s.foreground) : e.fg, c = s.background ? i.value(s.background) : void 0), l = be(l, u), c = be(c, u), s.decorations.has("dim") && (l = r0(l));
      let d = ce.None;
      return s.decorations.has("bold") && (d |= ce.Bold), s.decorations.has("italic") && (d |= ce.Italic), s.decorations.has("underline") && (d |= ce.Underline), {
        content: s.value,
        offset: o[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: l,
        bgColor: c,
        fontStyle: d
      };
    })
  );
}
function r0(e) {
  const t = e.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (t)
    if (t[3]) {
      const u = Math.round(Number.parseInt(t[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${t[1]}${t[2]}${u}`;
    } else return t[2] ? `#${t[1]}${t[2]}80` : `#${Array.from(t[1]).map((u) => `${u}${u}`).join("")}80`;
  const n = e.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return n ? `var(${n[1]}-dim)` : e;
}
function On(e, t, n = {}) {
  const {
    lang: u = "text",
    theme: r = e.getLoadedThemes()[0]
  } = n;
  if (In(u) || Mn(r))
    return Lt(t).map((s) => [{ content: s[0], offset: s[1] }]);
  const { theme: i, colorMap: a } = e.setTheme(r);
  if (u === "ansi")
    return u0(i, t, n);
  const o = e.getLanguage(u);
  if (n.grammarState) {
    if (n.grammarState.lang !== o.name)
      throw new j(`Grammar state language "${n.grammarState.lang}" does not match highlight language "${o.name}"`);
    if (!n.grammarState.themes.includes(i.name))
      throw new j(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${i.name}"`);
  }
  return a0(t, o, i, a, n);
}
function i0(...e) {
  if (e.length === 2)
    return Ze(e[1]);
  const [t, n, u = {}] = e, {
    lang: r = "text",
    theme: i = t.getLoadedThemes()[0]
  } = u;
  if (In(r) || Mn(i))
    throw new j("Plain language does not have grammar state");
  if (r === "ansi")
    throw new j("ANSI language does not have grammar state");
  const { theme: a, colorMap: o } = t.setTheme(i), s = t.getLanguage(r);
  return new Ne(
    wt(n, s, a, o, u).stateStack,
    s.name,
    a.name
  );
}
function a0(e, t, n, u, r) {
  const i = wt(e, t, n, u, r), a = new Ne(
    wt(e, t, n, u, r).stateStack,
    t.name,
    n.name
  );
  return Pt(i.tokens, a), i.tokens;
}
function wt(e, t, n, u, r) {
  const i = kt(n, r), {
    tokenizeMaxLineLength: a = 0,
    tokenizeTimeLimit: o = 500
  } = r, s = Lt(e);
  let l = r.grammarState ? Zc(r.grammarState, n.name) ?? mn : r.grammarContextCode != null ? wt(
    r.grammarContextCode,
    t,
    n,
    u,
    {
      ...r,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : mn, c = [];
  const d = [];
  for (let f = 0, p = s.length; f < p; f++) {
    const [h, g] = s[f];
    if (h === "") {
      c = [], d.push([]);
      continue;
    }
    if (a > 0 && h.length >= a) {
      c = [], d.push([{
        content: h,
        offset: g,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let m, b, _;
    r.includeExplanation && (m = t.tokenizeLine(h, l, o), b = m.tokens, _ = 0);
    const y = t.tokenizeLine2(h, l, o), x = y.tokens.length / 2;
    for (let C = 0; C < x; C++) {
      const v = y.tokens[2 * C], A = C + 1 < x ? y.tokens[2 * C + 2] : h.length;
      if (v === A)
        continue;
      const S = y.tokens[2 * C + 1], L = be(
        u[Re.getForeground(S)],
        i
      ), M = Re.getFontStyle(S), Z = {
        content: h.substring(v, A),
        offset: g + v,
        color: L,
        fontStyle: M
      };
      if (r.includeExplanation) {
        const P = [];
        if (r.includeExplanation !== "scopeName")
          for (const D of n.settings) {
            let G;
            switch (typeof D.scope) {
              case "string":
                G = D.scope.split(/,/).map((Ie) => Ie.trim());
                break;
              case "object":
                G = D.scope;
                break;
              default:
                continue;
            }
            P.push({
              settings: D,
              selectors: G.map((Ie) => Ie.split(/ /))
            });
          }
        Z.explanation = [];
        let $ = 0;
        for (; v + $ < A; ) {
          const D = b[_], G = h.substring(
            D.startIndex,
            D.endIndex
          );
          $ += G.length, Z.explanation.push({
            content: G,
            scopes: r.includeExplanation === "scopeName" ? o0(
              D.scopes
            ) : s0(
              P,
              D.scopes
            )
          }), _ += 1;
        }
      }
      c.push(Z);
    }
    d.push(c), c = [], l = y.ruleStack;
  }
  return {
    tokens: d,
    stateStack: l
  };
}
function o0(e) {
  return e.map((t) => ({ scopeName: t }));
}
function s0(e, t) {
  const n = [];
  for (let u = 0, r = t.length; u < r; u++) {
    const i = t[u];
    n[u] = {
      scopeName: i,
      themeMatches: c0(e, i, t.slice(0, u))
    };
  }
  return n;
}
function Tu(e, t) {
  return e === t || t.substring(0, e.length) === e && t[e.length] === ".";
}
function l0(e, t, n) {
  if (!Tu(e[e.length - 1], t))
    return !1;
  let u = e.length - 2, r = n.length - 1;
  for (; u >= 0 && r >= 0; )
    Tu(e[u], n[r]) && (u -= 1), r -= 1;
  return u === -1;
}
function c0(e, t, n) {
  const u = [];
  for (const { selectors: r, settings: i } of e)
    for (const a of r)
      if (l0(a, t, n)) {
        u.push(i);
        break;
      }
  return u;
}
function Jr(e, t, n) {
  const u = Object.entries(n.themes).filter((s) => s[1]).map((s) => ({ color: s[0], theme: s[1] })), r = u.map((s) => {
    const l = On(e, t, {
      ...n,
      theme: s.theme
    }), c = Ze(l), d = typeof s.theme == "string" ? s.theme : s.theme.name;
    return {
      tokens: l,
      state: c,
      theme: d
    };
  }), i = d0(
    ...r.map((s) => s.tokens)
  ), a = i[0].map(
    (s, l) => s.map((c, d) => {
      const f = {
        content: c.content,
        variants: {},
        offset: c.offset
      };
      return "includeExplanation" in n && n.includeExplanation && (f.explanation = c.explanation), i.forEach((p, h) => {
        const {
          content: g,
          explanation: m,
          offset: b,
          ..._
        } = p[l][d];
        f.variants[u[h].color] = _;
      }), f;
    })
  ), o = r[0].state ? new Ne(
    Object.fromEntries(r.map((s) => {
      var l;
      return [s.theme, (l = s.state) == null ? void 0 : l.getInternalStack(s.theme)];
    })),
    r[0].state.lang
  ) : void 0;
  return o && Pt(a, o), a;
}
function d0(...e) {
  const t = e.map(() => []), n = e.length;
  for (let u = 0; u < e[0].length; u++) {
    const r = e.map((s) => s[u]), i = t.map(() => []);
    t.forEach((s, l) => s.push(i[l]));
    const a = r.map(() => 0), o = r.map((s) => s[0]);
    for (; o.every((s) => s); ) {
      const s = Math.min(...o.map((l) => l.content.length));
      for (let l = 0; l < n; l++) {
        const c = o[l];
        c.content.length === s ? (i[l].push(c), a[l] += 1, o[l] = r[l][a[l]]) : (i[l].push({
          ...c,
          content: c.content.slice(0, s)
        }), o[l] = {
          ...c,
          content: c.content.slice(s),
          offset: c.offset + s
        });
      }
    }
  }
  return t;
}
function Ct(e, t, n) {
  let u, r, i, a, o, s;
  if ("themes" in n) {
    const {
      defaultColor: l = "light",
      cssVariablePrefix: c = "--shiki-"
    } = n, d = Object.entries(n.themes).filter((m) => m[1]).map((m) => ({ color: m[0], theme: m[1] })).sort((m, b) => m.color === l ? -1 : b.color === l ? 1 : 0);
    if (d.length === 0)
      throw new j("`themes` option must not be empty");
    const f = Jr(
      e,
      t,
      n
    );
    if (s = Ze(f), l && !d.find((m) => m.color === l))
      throw new j(`\`themes\` option must contain the defaultColor key \`${l}\``);
    const p = d.map((m) => e.getTheme(m.theme)), h = d.map((m) => m.color);
    i = f.map((m) => m.map((b) => Uc(b, h, c, l))), s && Pt(i, s);
    const g = d.map((m) => kt(m.theme, n));
    r = d.map((m, b) => (b === 0 && l ? "" : `${c + m.color}:`) + (be(p[b].fg, g[b]) || "inherit")).join(";"), u = d.map((m, b) => (b === 0 && l ? "" : `${c + m.color}-bg:`) + (be(p[b].bg, g[b]) || "inherit")).join(";"), a = `shiki-themes ${p.map((m) => m.name).join(" ")}`, o = l ? void 0 : [r, u].join(";");
  } else if ("theme" in n) {
    const l = kt(n.theme, n);
    i = On(
      e,
      t,
      n
    );
    const c = e.getTheme(n.theme);
    u = be(c.bg, l), r = be(c.fg, l), a = c.name, s = Ze(i);
  } else
    throw new j("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: i,
    fg: r,
    bg: u,
    themeName: a,
    rootStyle: o,
    grammarState: s
  };
}
function vt(e, t, n, u = {
  meta: {},
  options: n,
  codeToHast: (r, i) => vt(e, r, i),
  codeToTokens: (r, i) => Ct(e, r, i)
}) {
  var p, h;
  let r = t;
  for (const g of xt(n))
    r = ((p = g.preprocess) == null ? void 0 : p.call(u, r, n)) || r;
  let {
    tokens: i,
    fg: a,
    bg: o,
    themeName: s,
    rootStyle: l,
    grammarState: c
  } = Ct(e, r, n);
  const {
    mergeWhitespaces: d = !0
  } = n;
  d === !0 ? i = h0(i) : d === "never" && (i = p0(i));
  const f = {
    ...u,
    get source() {
      return r;
    }
  };
  for (const g of xt(n))
    i = ((h = g.tokens) == null ? void 0 : h.call(f, i)) || i;
  return f0(
    i,
    {
      ...n,
      fg: a,
      bg: o,
      themeName: s,
      rootStyle: l
    },
    f,
    c
  );
}
function f0(e, t, n, u = Ze(e)) {
  var h, g, m;
  const r = xt(t), i = [], a = {
    type: "root",
    children: []
  }, {
    structure: o = "classic",
    tabindex: s = "0"
  } = t;
  let l = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${t.themeName || ""}`,
      style: t.rootStyle || `background-color:${t.bg};color:${t.fg}`,
      ...s !== !1 && s != null ? {
        tabindex: s.toString()
      } : {},
      ...Object.fromEntries(
        Array.from(
          Object.entries(t.meta || {})
        ).filter(([b]) => !b.startsWith("_"))
      )
    },
    children: []
  }, c = {
    type: "element",
    tagName: "code",
    properties: {},
    children: i
  };
  const d = [], f = {
    ...n,
    structure: o,
    addClassToHast: Ur,
    get source() {
      return n.source;
    },
    get tokens() {
      return e;
    },
    get options() {
      return t;
    },
    get root() {
      return a;
    },
    get pre() {
      return l;
    },
    get code() {
      return c;
    },
    get lines() {
      return d;
    }
  };
  if (e.forEach((b, _) => {
    var C, v;
    _ && (o === "inline" ? a.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : o === "classic" && i.push({ type: "text", value: `
` }));
    let y = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, x = 0;
    for (const A of b) {
      let S = {
        type: "element",
        tagName: "span",
        properties: {
          ...A.htmlAttrs
        },
        children: [{ type: "text", value: A.content }]
      };
      const L = Wc(A.htmlStyle || Wr(A));
      L && (S.properties.style = L);
      for (const M of r)
        S = ((C = M == null ? void 0 : M.span) == null ? void 0 : C.call(f, S, _ + 1, x, y, A)) || S;
      o === "inline" ? a.children.push(S) : o === "classic" && y.children.push(S), x += A.content.length;
    }
    if (o === "classic") {
      for (const A of r)
        y = ((v = A == null ? void 0 : A.line) == null ? void 0 : v.call(f, y, _ + 1)) || y;
      d.push(y), i.push(y);
    }
  }), o === "classic") {
    for (const b of r)
      c = ((h = b == null ? void 0 : b.code) == null ? void 0 : h.call(f, c)) || c;
    l.children.push(c);
    for (const b of r)
      l = ((g = b == null ? void 0 : b.pre) == null ? void 0 : g.call(f, l)) || l;
    a.children.push(l);
  }
  let p = a;
  for (const b of r)
    p = ((m = b == null ? void 0 : b.root) == null ? void 0 : m.call(f, p)) || p;
  return u && Pt(p, u), p;
}
function h0(e) {
  return e.map((t) => {
    const n = [];
    let u = "", r = 0;
    return t.forEach((i, a) => {
      const s = !(i.fontStyle && i.fontStyle & ce.Underline);
      s && i.content.match(/^\s+$/) && t[a + 1] ? (r || (r = i.offset), u += i.content) : u ? (s ? n.push({
        ...i,
        offset: r,
        content: u + i.content
      }) : n.push(
        {
          content: u,
          offset: r
        },
        i
      ), r = 0, u = "") : n.push(i);
    }), n;
  });
}
function p0(e) {
  return e.map((t) => t.flatMap((n) => {
    if (n.content.match(/^\s+$/))
      return n;
    const u = n.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!u)
      return n;
    const [, r, i, a] = u;
    if (!r && !a)
      return n;
    const o = [{
      ...n,
      offset: n.offset + r.length,
      content: i
    }];
    return r && o.unshift({
      content: r,
      offset: n.offset
    }), a && o.push({
      content: a,
      offset: n.offset + r.length + i.length
    }), o;
  }));
}
const m0 = Bc;
function g0(e, t, n) {
  var i;
  const u = {
    meta: {},
    options: n,
    codeToHast: (a, o) => vt(e, a, o),
    codeToTokens: (a, o) => Ct(e, a, o)
  };
  let r = m0(vt(e, t, n, u));
  for (const a of xt(n))
    r = ((i = a.postprocess) == null ? void 0 : i.call(u, r, n)) || r;
  return r;
}
const Ru = { light: "#333333", dark: "#bbbbbb" }, Lu = { light: "#fffffe", dark: "#1e1e1e" }, Pu = "__shiki_resolved";
function Bn(e) {
  var o, s, l, c, d;
  if (e != null && e[Pu])
    return e;
  const t = {
    ...e
  };
  t.tokenColors && !t.settings && (t.settings = t.tokenColors, delete t.tokenColors), t.type || (t.type = "dark"), t.colorReplacements = { ...t.colorReplacements }, t.settings || (t.settings = []);
  let { bg: n, fg: u } = t;
  if (!n || !u) {
    const f = t.settings ? t.settings.find((p) => !p.name && !p.scope) : void 0;
    (o = f == null ? void 0 : f.settings) != null && o.foreground && (u = f.settings.foreground), (s = f == null ? void 0 : f.settings) != null && s.background && (n = f.settings.background), !u && ((l = t == null ? void 0 : t.colors) != null && l["editor.foreground"]) && (u = t.colors["editor.foreground"]), !n && ((c = t == null ? void 0 : t.colors) != null && c["editor.background"]) && (n = t.colors["editor.background"]), u || (u = t.type === "light" ? Ru.light : Ru.dark), n || (n = t.type === "light" ? Lu.light : Lu.dark), t.fg = u, t.bg = n;
  }
  t.settings[0] && t.settings[0].settings && !t.settings[0].scope || t.settings.unshift({
    settings: {
      foreground: t.fg,
      background: t.bg
    }
  });
  let r = 0;
  const i = /* @__PURE__ */ new Map();
  function a(f) {
    var h;
    if (i.has(f))
      return i.get(f);
    r += 1;
    const p = `#${r.toString(16).padStart(8, "0").toLowerCase()}`;
    return (h = t.colorReplacements) != null && h[`#${p}`] ? a(f) : (i.set(f, p), p);
  }
  t.settings = t.settings.map((f) => {
    var m, b;
    const p = ((m = f.settings) == null ? void 0 : m.foreground) && !f.settings.foreground.startsWith("#"), h = ((b = f.settings) == null ? void 0 : b.background) && !f.settings.background.startsWith("#");
    if (!p && !h)
      return f;
    const g = {
      ...f,
      settings: {
        ...f.settings
      }
    };
    if (p) {
      const _ = a(f.settings.foreground);
      t.colorReplacements[_] = f.settings.foreground, g.settings.foreground = _;
    }
    if (h) {
      const _ = a(f.settings.background);
      t.colorReplacements[_] = f.settings.background, g.settings.background = _;
    }
    return g;
  });
  for (const f of Object.keys(t.colors || {}))
    if ((f === "editor.foreground" || f === "editor.background" || f.startsWith("terminal.ansi")) && !((d = t.colors[f]) != null && d.startsWith("#"))) {
      const p = a(t.colors[f]);
      t.colorReplacements[p] = t.colors[f], t.colors[f] = p;
    }
  return Object.defineProperty(t, Pu, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), t;
}
async function Kr(e) {
  return Array.from(new Set((await Promise.all(
    e.filter((t) => !Gr(t)).map(async (t) => await qr(t).then((n) => Array.isArray(n) ? n : [n]))
  )).flat()));
}
async function Qr(e) {
  return (await Promise.all(
    e.map(
      async (n) => Hr(n) ? null : Bn(await qr(n))
    )
  )).filter((n) => !!n);
}
let _0 = 3;
function b0(e, t = 3) {
  t > _0 || console.trace(`[SHIKI DEPRECATE]: ${e}`);
}
let Ce = class extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
};
class y0 extends vl {
  constructor(n, u, r, i = {}) {
    super(n);
    k(this, "_resolvedThemes", /* @__PURE__ */ new Map());
    k(this, "_resolvedGrammars", /* @__PURE__ */ new Map());
    k(this, "_langMap", /* @__PURE__ */ new Map());
    k(this, "_langGraph", /* @__PURE__ */ new Map());
    k(this, "_textmateThemeCache", /* @__PURE__ */ new WeakMap());
    k(this, "_loadedThemesCache", null);
    k(this, "_loadedLanguagesCache", null);
    this._resolver = n, this._themes = u, this._langs = r, this._alias = i, this._themes.map((a) => this.loadTheme(a)), this.loadLanguages(this._langs);
  }
  getTheme(n) {
    return typeof n == "string" ? this._resolvedThemes.get(n) : this.loadTheme(n);
  }
  loadTheme(n) {
    const u = Bn(n);
    return u.name && (this._resolvedThemes.set(u.name, u), this._loadedThemesCache = null), u;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(n) {
    let u = this._textmateThemeCache.get(n);
    u || (u = mt.createFromRawTheme(n), this._textmateThemeCache.set(n, u)), this._syncRegistry.setTheme(u);
  }
  getGrammar(n) {
    if (this._alias[n]) {
      const u = /* @__PURE__ */ new Set([n]);
      for (; this._alias[n]; ) {
        if (n = this._alias[n], u.has(n))
          throw new Ce(`Circular alias \`${Array.from(u).join(" -> ")} -> ${n}\``);
        u.add(n);
      }
    }
    return this._resolvedGrammars.get(n);
  }
  loadLanguage(n) {
    var a, o, s, l;
    if (this.getGrammar(n.name))
      return;
    const u = new Set(
      [...this._langMap.values()].filter((c) => {
        var d;
        return (d = c.embeddedLangsLazy) == null ? void 0 : d.includes(n.name);
      })
    );
    this._resolver.addLanguage(n);
    const r = {
      balancedBracketSelectors: n.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: n.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(n.scopeName, n);
    const i = this.loadGrammarWithConfiguration(n.scopeName, 1, r);
    if (i.name = n.name, this._resolvedGrammars.set(n.name, i), n.aliases && n.aliases.forEach((c) => {
      this._alias[c] = n.name;
    }), this._loadedLanguagesCache = null, u.size)
      for (const c of u)
        this._resolvedGrammars.delete(c.name), this._loadedLanguagesCache = null, (o = (a = this._syncRegistry) == null ? void 0 : a._injectionGrammars) == null || o.delete(c.scopeName), (l = (s = this._syncRegistry) == null ? void 0 : s._grammars) == null || l.delete(c.scopeName), this.loadLanguage(this._langMap.get(c.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(n) {
    for (const i of n)
      this.resolveEmbeddedLanguages(i);
    const u = Array.from(this._langGraph.entries()), r = u.filter(([i, a]) => !a);
    if (r.length) {
      const i = u.filter(([a, o]) => {
        var s;
        return o && ((s = o.embeddedLangs) == null ? void 0 : s.some((l) => r.map(([c]) => c).includes(l)));
      }).filter((a) => !r.includes(a));
      throw new Ce(`Missing languages ${r.map(([a]) => `\`${a}\``).join(", ")}, required by ${i.map(([a]) => `\`${a}\``).join(", ")}`);
    }
    for (const [i, a] of u)
      this._resolver.addLanguage(a);
    for (const [i, a] of u)
      this.loadLanguage(a);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(n) {
    if (this._langMap.set(n.name, n), this._langGraph.set(n.name, n), n.embeddedLangs)
      for (const u of n.embeddedLangs)
        this._langGraph.set(u, this._langMap.get(u));
  }
}
class k0 {
  constructor(t, n) {
    k(this, "_langs", /* @__PURE__ */ new Map());
    k(this, "_scopeToLang", /* @__PURE__ */ new Map());
    k(this, "_injections", /* @__PURE__ */ new Map());
    k(this, "_onigLib");
    this._onigLib = {
      createOnigScanner: (u) => t.createScanner(u),
      createOnigString: (u) => t.createString(u)
    }, n.forEach((u) => this.addLanguage(u));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(t) {
    return this._langs.get(t);
  }
  loadGrammar(t) {
    return this._scopeToLang.get(t);
  }
  addLanguage(t) {
    this._langs.set(t.name, t), t.aliases && t.aliases.forEach((n) => {
      this._langs.set(n, t);
    }), this._scopeToLang.set(t.scopeName, t), t.injectTo && t.injectTo.forEach((n) => {
      this._injections.get(n) || this._injections.set(n, []), this._injections.get(n).push(t.scopeName);
    });
  }
  getInjections(t) {
    const n = t.split(".");
    let u = [];
    for (let r = 1; r <= n.length; r++) {
      const i = n.slice(0, r).join(".");
      u = [...u, ...this._injections.get(i) || []];
    }
    return u;
  }
}
let Oe = 0;
function x0(e) {
  Oe += 1, e.warnings !== !1 && Oe >= 10 && Oe % 10 === 0 && console.warn(`[Shiki] ${Oe} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let t = !1;
  if (!e.engine)
    throw new Ce("`engine` option is required for synchronous mode");
  const n = (e.langs || []).flat(1), u = (e.themes || []).flat(1).map(Bn), r = new k0(e.engine, n), i = new y0(r, u, n, e.langAlias);
  let a;
  function o(_) {
    m();
    const y = i.getGrammar(typeof _ == "string" ? _ : _.name);
    if (!y)
      throw new Ce(`Language \`${_}\` not found, you may need to load it first`);
    return y;
  }
  function s(_) {
    if (_ === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    m();
    const y = i.getTheme(_);
    if (!y)
      throw new Ce(`Theme \`${_}\` not found, you may need to load it first`);
    return y;
  }
  function l(_) {
    m();
    const y = s(_);
    a !== _ && (i.setTheme(y), a = _);
    const x = i.getColorMap();
    return {
      theme: y,
      colorMap: x
    };
  }
  function c() {
    return m(), i.getLoadedThemes();
  }
  function d() {
    return m(), i.getLoadedLanguages();
  }
  function f(..._) {
    m(), i.loadLanguages(_.flat(1));
  }
  async function p(..._) {
    return f(await Kr(_));
  }
  function h(..._) {
    m();
    for (const y of _.flat(1))
      i.loadTheme(y);
  }
  async function g(..._) {
    return m(), h(await Qr(_));
  }
  function m() {
    if (t)
      throw new Ce("Shiki instance has been disposed");
  }
  function b() {
    t || (t = !0, i.dispose(), Oe -= 1);
  }
  return {
    setTheme: l,
    getTheme: s,
    getLanguage: o,
    getLoadedThemes: c,
    getLoadedLanguages: d,
    loadLanguage: p,
    loadLanguageSync: f,
    loadTheme: g,
    loadThemeSync: h,
    dispose: b,
    [Symbol.dispose]: b
  };
}
async function w0(e) {
  e.engine || b0("`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.");
  const [
    t,
    n,
    u
  ] = await Promise.all([
    Qr(e.themes || []),
    Kr(e.langs || []),
    e.engine
  ]);
  return x0({
    ...e,
    themes: t,
    langs: n,
    engine: u
  });
}
async function C0(e) {
  const t = await w0(e);
  return {
    getLastGrammarState: (...n) => i0(t, ...n),
    codeToTokensBase: (n, u) => On(t, n, u),
    codeToTokensWithThemes: (n, u) => Jr(t, n, u),
    codeToTokens: (n, u) => Ct(t, n, u),
    codeToHast: (n, u) => vt(t, n, u),
    codeToHtml: (n, u) => g0(t, n, u),
    getBundledLanguages: () => ({}),
    getBundledThemes: () => ({}),
    ...t,
    getInternalContext: () => t
  };
}
function v0(e) {
  const t = e.langs, n = e.themes, u = e.engine;
  async function r(i) {
    function a(d) {
      if (typeof d == "string") {
        if (Gr(d))
          return [];
        const f = t[d];
        if (!f)
          throw new j(`Language \`${d}\` is not included in this bundle. You may want to load it from external source.`);
        return f;
      }
      return d;
    }
    function o(d) {
      if (Hr(d))
        return "none";
      if (typeof d == "string") {
        const f = n[d];
        if (!f)
          throw new j(`Theme \`${d}\` is not included in this bundle. You may want to load it from external source.`);
        return f;
      }
      return d;
    }
    const s = (i.themes ?? []).map((d) => o(d)), l = (i.langs ?? []).map((d) => a(d)), c = await C0({
      engine: i.engine ?? u(),
      ...i,
      themes: s,
      langs: l
    });
    return {
      ...c,
      loadLanguage(...d) {
        return c.loadLanguage(...d.map(a));
      },
      loadTheme(...d) {
        return c.loadTheme(...d.map(o));
      },
      getBundledLanguages() {
        return t;
      },
      getBundledThemes() {
        return n;
      }
    };
  }
  return r;
}
const Xr = [
  {
    id: "abap",
    name: "ABAP",
    import: () => import("./abap-BPxeDPn4.mjs")
  },
  {
    id: "actionscript-3",
    name: "ActionScript",
    import: () => import("./actionscript-3-Cjb604Dt.mjs")
  },
  {
    id: "ada",
    name: "Ada",
    import: () => import("./ada-BSgRrxrM.mjs")
  },
  {
    id: "angular-html",
    name: "Angular HTML",
    import: () => import("./angular-html-VH4Q9M3L.mjs").then((e) => e.f)
  },
  {
    id: "angular-ts",
    name: "Angular TypeScript",
    import: () => import("./angular-ts-RFL6RdQE.mjs")
  },
  {
    id: "apache",
    name: "Apache Conf",
    import: () => import("./apache-Cyj7Ib-S.mjs")
  },
  {
    id: "apex",
    name: "Apex",
    import: () => import("./apex-DAAiMqi-.mjs")
  },
  {
    id: "apl",
    name: "APL",
    import: () => import("./apl-Chb7kBJS.mjs")
  },
  {
    id: "applescript",
    name: "AppleScript",
    import: () => import("./applescript-CroEtIVQ.mjs")
  },
  {
    id: "ara",
    name: "Ara",
    import: () => import("./ara-9AczF2vY.mjs")
  },
  {
    id: "asciidoc",
    name: "AsciiDoc",
    aliases: [
      "adoc"
    ],
    import: () => import("./asciidoc-raFNDrGb.mjs")
  },
  {
    id: "asm",
    name: "Assembly",
    import: () => import("./asm-C8ld_M07.mjs")
  },
  {
    id: "astro",
    name: "Astro",
    import: () => import("./astro-C441rmT2.mjs")
  },
  {
    id: "awk",
    name: "AWK",
    import: () => import("./awk-gc4Y_RTq.mjs")
  },
  {
    id: "ballerina",
    name: "Ballerina",
    import: () => import("./ballerina-CML1q4Hw.mjs")
  },
  {
    id: "bat",
    name: "Batch File",
    aliases: [
      "batch"
    ],
    import: () => import("./bat-BVW1L4ug.mjs")
  },
  {
    id: "beancount",
    name: "Beancount",
    import: () => import("./beancount-DYEC72C_.mjs")
  },
  {
    id: "berry",
    name: "Berry",
    aliases: [
      "be"
    ],
    import: () => import("./berry-VTah6p7n.mjs")
  },
  {
    id: "bibtex",
    name: "BibTeX",
    import: () => import("./bibtex-Bqt_3AVI.mjs")
  },
  {
    id: "bicep",
    name: "Bicep",
    import: () => import("./bicep-DGk9_2l4.mjs")
  },
  {
    id: "blade",
    name: "Blade",
    import: () => import("./blade-CtIs8DKJ.mjs")
  },
  {
    id: "bsl",
    name: "1C (Enterprise)",
    aliases: [
      "1c"
    ],
    import: () => import("./bsl-CGvKUPBQ.mjs")
  },
  {
    id: "c",
    name: "C",
    import: () => import("./c-Cb-M0LQR.mjs")
  },
  {
    id: "cadence",
    name: "Cadence",
    aliases: [
      "cdc"
    ],
    import: () => import("./cadence-Di4VMBdJ.mjs")
  },
  {
    id: "cairo",
    name: "Cairo",
    import: () => import("./cairo-CAE0ZH8Z.mjs")
  },
  {
    id: "clarity",
    name: "Clarity",
    import: () => import("./clarity-WOA8trQj.mjs")
  },
  {
    id: "clojure",
    name: "Clojure",
    aliases: [
      "clj"
    ],
    import: () => import("./clojure-r3NcJ8yt.mjs")
  },
  {
    id: "cmake",
    name: "CMake",
    import: () => import("./cmake-CQmEhYbr.mjs")
  },
  {
    id: "cobol",
    name: "COBOL",
    import: () => import("./cobol-ptvo3qSX.mjs")
  },
  {
    id: "codeowners",
    name: "CODEOWNERS",
    import: () => import("./codeowners-Bt9yU6NX.mjs")
  },
  {
    id: "codeql",
    name: "CodeQL",
    aliases: [
      "ql"
    ],
    import: () => import("./codeql-2Dcm6WNF.mjs")
  },
  {
    id: "coffee",
    name: "CoffeeScript",
    aliases: [
      "coffeescript"
    ],
    import: () => import("./coffee-BaUVgbKr.mjs")
  },
  {
    id: "common-lisp",
    name: "Common Lisp",
    aliases: [
      "lisp"
    ],
    import: () => import("./common-lisp-DuX5KqId.mjs")
  },
  {
    id: "coq",
    name: "Coq",
    import: () => import("./coq-DboLktjX.mjs")
  },
  {
    id: "cpp",
    name: "C++",
    aliases: [
      "c++"
    ],
    import: () => import("./cpp-yY_3eVTX.mjs")
  },
  {
    id: "crystal",
    name: "Crystal",
    import: () => import("./crystal-DGmreRZE.mjs")
  },
  {
    id: "csharp",
    name: "C#",
    aliases: [
      "c#",
      "cs"
    ],
    import: () => import("./csharp-xQvxkZxj.mjs")
  },
  {
    id: "css",
    name: "CSS",
    import: () => import("./css-BnL1064W.mjs")
  },
  {
    id: "csv",
    name: "CSV",
    import: () => import("./csv-CmYOceLb.mjs")
  },
  {
    id: "cue",
    name: "CUE",
    import: () => import("./cue-ByErcpN2.mjs")
  },
  {
    id: "cypher",
    name: "Cypher",
    aliases: [
      "cql"
    ],
    import: () => import("./cypher-DEVyrV5b.mjs")
  },
  {
    id: "d",
    name: "D",
    import: () => import("./d-CBVqdj3C.mjs")
  },
  {
    id: "dart",
    name: "Dart",
    import: () => import("./dart-u2fD-sKr.mjs")
  },
  {
    id: "dax",
    name: "DAX",
    import: () => import("./dax-Crz9Wv4y.mjs")
  },
  {
    id: "desktop",
    name: "Desktop",
    import: () => import("./desktop-DNXSD5qJ.mjs")
  },
  {
    id: "diff",
    name: "Diff",
    import: () => import("./diff-DOdUfPSR.mjs")
  },
  {
    id: "docker",
    name: "Dockerfile",
    aliases: [
      "dockerfile"
    ],
    import: () => import("./docker-CsHqm9tx.mjs")
  },
  {
    id: "dotenv",
    name: "dotEnv",
    import: () => import("./dotenv-BYL4tpZA.mjs")
  },
  {
    id: "dream-maker",
    name: "Dream Maker",
    import: () => import("./dream-maker-kevRUHRs.mjs")
  },
  {
    id: "edge",
    name: "Edge",
    import: () => import("./edge-BCt2E0q_.mjs")
  },
  {
    id: "elixir",
    name: "Elixir",
    import: () => import("./elixir-BHm2glEy.mjs")
  },
  {
    id: "elm",
    name: "Elm",
    import: () => import("./elm-CTcFORmv.mjs")
  },
  {
    id: "emacs-lisp",
    name: "Emacs Lisp",
    aliases: [
      "elisp"
    ],
    import: () => import("./emacs-lisp-Bwasiep6.mjs")
  },
  {
    id: "erb",
    name: "ERB",
    import: () => import("./erb-XhwKqDS8.mjs")
  },
  {
    id: "erlang",
    name: "Erlang",
    aliases: [
      "erl"
    ],
    import: () => import("./erlang-CxpbZUOc.mjs")
  },
  {
    id: "fennel",
    name: "Fennel",
    import: () => import("./fennel-B1x5pKr1.mjs")
  },
  {
    id: "fish",
    name: "Fish",
    import: () => import("./fish-BjbXctXH.mjs")
  },
  {
    id: "fluent",
    name: "Fluent",
    aliases: [
      "ftl"
    ],
    import: () => import("./fluent-DCuHrNR-.mjs")
  },
  {
    id: "fortran-fixed-form",
    name: "Fortran (Fixed Form)",
    aliases: [
      "f",
      "for",
      "f77"
    ],
    import: () => import("./fortran-fixed-form-CeyvVuTY.mjs")
  },
  {
    id: "fortran-free-form",
    name: "Fortran (Free Form)",
    aliases: [
      "f90",
      "f95",
      "f03",
      "f08",
      "f18"
    ],
    import: () => import("./fortran-free-form-Db8k5H7x.mjs")
  },
  {
    id: "fsharp",
    name: "F#",
    aliases: [
      "f#",
      "fs"
    ],
    import: () => import("./fsharp-DEQhJMqK.mjs")
  },
  {
    id: "gdresource",
    name: "GDResource",
    import: () => import("./gdresource-BLJkA_Aj.mjs")
  },
  {
    id: "gdscript",
    name: "GDScript",
    import: () => import("./gdscript-C-C99PjI.mjs")
  },
  {
    id: "gdshader",
    name: "GDShader",
    import: () => import("./gdshader-0TihrSQl.mjs")
  },
  {
    id: "genie",
    name: "Genie",
    import: () => import("./genie-MtKmcmPo.mjs")
  },
  {
    id: "gherkin",
    name: "Gherkin",
    import: () => import("./gherkin-AzJBtK0J.mjs")
  },
  {
    id: "git-commit",
    name: "Git Commit Message",
    import: () => import("./git-commit-BrFRQx8-.mjs")
  },
  {
    id: "git-rebase",
    name: "Git Rebase Message",
    import: () => import("./git-rebase-wXBGezpo.mjs")
  },
  {
    id: "gleam",
    name: "Gleam",
    import: () => import("./gleam-BoJB89vF.mjs")
  },
  {
    id: "glimmer-js",
    name: "Glimmer JS",
    aliases: [
      "gjs"
    ],
    import: () => import("./glimmer-js-Dt04jn-S.mjs")
  },
  {
    id: "glimmer-ts",
    name: "Glimmer TS",
    aliases: [
      "gts"
    ],
    import: () => import("./glimmer-ts-CxE3Gx7t.mjs")
  },
  {
    id: "glsl",
    name: "GLSL",
    import: () => import("./glsl-DJI4XIlW.mjs")
  },
  {
    id: "gnuplot",
    name: "Gnuplot",
    import: () => import("./gnuplot-DgGnPAp8.mjs")
  },
  {
    id: "go",
    name: "Go",
    import: () => import("./go-Cw0OOp5U.mjs")
  },
  {
    id: "graphql",
    name: "GraphQL",
    aliases: [
      "gql"
    ],
    import: () => import("./graphql-BsgHRvna.mjs")
  },
  {
    id: "groovy",
    name: "Groovy",
    import: () => import("./groovy-45PuQEhl.mjs")
  },
  {
    id: "hack",
    name: "Hack",
    import: () => import("./hack-DqV8KpWq.mjs")
  },
  {
    id: "haml",
    name: "Ruby Haml",
    import: () => import("./haml-Az-UVpCq.mjs")
  },
  {
    id: "handlebars",
    name: "Handlebars",
    aliases: [
      "hbs"
    ],
    import: () => import("./handlebars-DZHTG-pY.mjs")
  },
  {
    id: "haskell",
    name: "Haskell",
    aliases: [
      "hs"
    ],
    import: () => import("./haskell-ClRE648j.mjs")
  },
  {
    id: "haxe",
    name: "Haxe",
    import: () => import("./haxe-CClgwBXY.mjs")
  },
  {
    id: "hcl",
    name: "HashiCorp HCL",
    import: () => import("./hcl-JJeBEFYE.mjs")
  },
  {
    id: "hjson",
    name: "Hjson",
    import: () => import("./hjson-BollGKL_.mjs")
  },
  {
    id: "hlsl",
    name: "HLSL",
    import: () => import("./hlsl-b3kI2reZ.mjs")
  },
  {
    id: "html",
    name: "HTML",
    import: () => import("./html-BVzRMMwO.mjs")
  },
  {
    id: "html-derivative",
    name: "HTML (Derivative)",
    import: () => import("./html-derivative-Bs5LtfVt.mjs")
  },
  {
    id: "http",
    name: "HTTP",
    import: () => import("./http-CmSPSQ8m.mjs")
  },
  {
    id: "hxml",
    name: "HXML",
    import: () => import("./hxml-CbNM5L_f.mjs")
  },
  {
    id: "hy",
    name: "Hy",
    import: () => import("./hy-S8dYOqS_.mjs")
  },
  {
    id: "imba",
    name: "Imba",
    import: () => import("./imba-DzSSVziz.mjs")
  },
  {
    id: "ini",
    name: "INI",
    aliases: [
      "properties"
    ],
    import: () => import("./ini-Cw62c0sR.mjs")
  },
  {
    id: "java",
    name: "Java",
    import: () => import("./java-DNw9zkk2.mjs")
  },
  {
    id: "javascript",
    name: "JavaScript",
    aliases: [
      "js"
    ],
    import: () => import("./javascript-CXHlxgtu.mjs")
  },
  {
    id: "jinja",
    name: "Jinja",
    import: () => import("./jinja-Cz5ys3c2.mjs")
  },
  {
    id: "jison",
    name: "Jison",
    import: () => import("./jison-vf0Z0jXp.mjs")
  },
  {
    id: "json",
    name: "JSON",
    import: () => import("./json-D4cXEhM0.mjs")
  },
  {
    id: "json5",
    name: "JSON5",
    import: () => import("./json5-QDX9y-Y9.mjs")
  },
  {
    id: "jsonc",
    name: "JSON with Comments",
    import: () => import("./jsonc-Bph7GQf8.mjs")
  },
  {
    id: "jsonl",
    name: "JSON Lines",
    import: () => import("./jsonl-CCrMgdQc.mjs")
  },
  {
    id: "jsonnet",
    name: "Jsonnet",
    import: () => import("./jsonnet-SAcLllmN.mjs")
  },
  {
    id: "jssm",
    name: "JSSM",
    aliases: [
      "fsl"
    ],
    import: () => import("./jssm-f8vsTkbr.mjs")
  },
  {
    id: "jsx",
    name: "JSX",
    import: () => import("./jsx-BYrS51r7.mjs")
  },
  {
    id: "julia",
    name: "Julia",
    aliases: [
      "jl"
    ],
    import: () => import("./julia-BFBGsm6d.mjs")
  },
  {
    id: "kotlin",
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    import: () => import("./kotlin-DZs3CUXT.mjs")
  },
  {
    id: "kusto",
    name: "Kusto",
    aliases: [
      "kql"
    ],
    import: () => import("./kusto-gqgW0Ct6.mjs")
  },
  {
    id: "latex",
    name: "LaTeX",
    import: () => import("./latex-CovCzr27.mjs")
  },
  {
    id: "lean",
    name: "Lean 4",
    aliases: [
      "lean4"
    ],
    import: () => import("./lean-DM2VgJqL.mjs")
  },
  {
    id: "less",
    name: "Less",
    import: () => import("./less-I_XXVOZl.mjs")
  },
  {
    id: "liquid",
    name: "Liquid",
    import: () => import("./liquid-B0utSgK4.mjs")
  },
  {
    id: "llvm",
    name: "LLVM IR",
    import: () => import("./llvm-D3Vjgx0u.mjs")
  },
  {
    id: "log",
    name: "Log file",
    import: () => import("./log-D-MzYv1Z.mjs")
  },
  {
    id: "logo",
    name: "Logo",
    import: () => import("./logo-D1k-IeHX.mjs")
  },
  {
    id: "lua",
    name: "Lua",
    import: () => import("./lua-6kxZcjr7.mjs")
  },
  {
    id: "luau",
    name: "Luau",
    import: () => import("./luau-B3dL2bb0.mjs")
  },
  {
    id: "make",
    name: "Makefile",
    aliases: [
      "makefile"
    ],
    import: () => import("./make-CR9bkdqJ.mjs")
  },
  {
    id: "markdown",
    name: "Markdown",
    aliases: [
      "md"
    ],
    import: () => import("./markdown-w3MmBOPg.mjs")
  },
  {
    id: "marko",
    name: "Marko",
    import: () => import("./marko-B-mS4lxx.mjs")
  },
  {
    id: "matlab",
    name: "MATLAB",
    import: () => import("./matlab-Dj6qX5si.mjs")
  },
  {
    id: "mdc",
    name: "MDC",
    import: () => import("./mdc-CKFBgyBp.mjs")
  },
  {
    id: "mdx",
    name: "MDX",
    import: () => import("./mdx-COYqLMfv.mjs")
  },
  {
    id: "mermaid",
    name: "Mermaid",
    aliases: [
      "mmd"
    ],
    import: () => import("./mermaid-qIAHIJes.mjs")
  },
  {
    id: "mipsasm",
    name: "MIPS Assembly",
    aliases: [
      "mips"
    ],
    import: () => import("./mipsasm-BJbuoeDX.mjs")
  },
  {
    id: "mojo",
    name: "Mojo",
    import: () => import("./mojo-BFkEE7I6.mjs")
  },
  {
    id: "move",
    name: "Move",
    import: () => import("./move-DhZIVzw9.mjs")
  },
  {
    id: "narrat",
    name: "Narrat Language",
    aliases: [
      "nar"
    ],
    import: () => import("./narrat-Cru3p5ML.mjs")
  },
  {
    id: "nextflow",
    name: "Nextflow",
    aliases: [
      "nf"
    ],
    import: () => import("./nextflow-JJGGygxI.mjs")
  },
  {
    id: "nginx",
    name: "Nginx",
    import: () => import("./nginx-DMJTzGU3.mjs")
  },
  {
    id: "nim",
    name: "Nim",
    import: () => import("./nim-tEo-v-ne.mjs")
  },
  {
    id: "nix",
    name: "Nix",
    import: () => import("./nix-DeKhqLCs.mjs")
  },
  {
    id: "nushell",
    name: "nushell",
    aliases: [
      "nu"
    ],
    import: () => import("./nushell-vZ0whCpp.mjs")
  },
  {
    id: "objective-c",
    name: "Objective-C",
    aliases: [
      "objc"
    ],
    import: () => import("./objective-c-DLUrAoO7.mjs")
  },
  {
    id: "objective-cpp",
    name: "Objective-C++",
    import: () => import("./objective-cpp-BR9pz3Y7.mjs")
  },
  {
    id: "ocaml",
    name: "OCaml",
    import: () => import("./ocaml-JmaGD6hS.mjs")
  },
  {
    id: "pascal",
    name: "Pascal",
    import: () => import("./pascal-NVmycfDo.mjs")
  },
  {
    id: "perl",
    name: "Perl",
    import: () => import("./perl-BuRaBk1L.mjs")
  },
  {
    id: "php",
    name: "PHP",
    import: () => import("./php-oHOrbTjZ.mjs")
  },
  {
    id: "plsql",
    name: "PL/SQL",
    import: () => import("./plsql-DMWd0imC.mjs")
  },
  {
    id: "po",
    name: "Gettext PO",
    aliases: [
      "pot",
      "potx"
    ],
    import: () => import("./po-GS6uwG3N.mjs")
  },
  {
    id: "polar",
    name: "Polar",
    import: () => import("./polar-kLOnm3TU.mjs")
  },
  {
    id: "postcss",
    name: "PostCSS",
    import: () => import("./postcss-BHhGrjb8.mjs")
  },
  {
    id: "powerquery",
    name: "PowerQuery",
    import: () => import("./powerquery-CMfeLaGU.mjs")
  },
  {
    id: "powershell",
    name: "PowerShell",
    aliases: [
      "ps",
      "ps1"
    ],
    import: () => import("./powershell-D1mvJxDs.mjs")
  },
  {
    id: "prisma",
    name: "Prisma",
    import: () => import("./prisma-pUoUFT3i.mjs")
  },
  {
    id: "prolog",
    name: "Prolog",
    import: () => import("./prolog-DY7WzwMi.mjs")
  },
  {
    id: "proto",
    name: "Protocol Buffer 3",
    aliases: [
      "protobuf"
    ],
    import: () => import("./proto-CNCp3VWu.mjs")
  },
  {
    id: "pug",
    name: "Pug",
    aliases: [
      "jade"
    ],
    import: () => import("./pug-CAVXGuhX.mjs")
  },
  {
    id: "puppet",
    name: "Puppet",
    import: () => import("./puppet-B0mgPBqt.mjs")
  },
  {
    id: "purescript",
    name: "PureScript",
    import: () => import("./purescript-Go548NjJ.mjs")
  },
  {
    id: "python",
    name: "Python",
    aliases: [
      "py"
    ],
    import: () => import("./python-x6NdgKMy.mjs")
  },
  {
    id: "qml",
    name: "QML",
    import: () => import("./qml-_XrKGlow.mjs")
  },
  {
    id: "qmldir",
    name: "QML Directory",
    import: () => import("./qmldir-BInDYbpo.mjs")
  },
  {
    id: "qss",
    name: "Qt Style Sheets",
    import: () => import("./qss-8QkBlVEn.mjs")
  },
  {
    id: "r",
    name: "R",
    import: () => import("./r-HSnR3oil.mjs")
  },
  {
    id: "racket",
    name: "Racket",
    import: () => import("./racket-N6wCNCGC.mjs")
  },
  {
    id: "raku",
    name: "Raku",
    aliases: [
      "perl6"
    ],
    import: () => import("./raku-DIMO1_4D.mjs")
  },
  {
    id: "razor",
    name: "ASP.NET Razor",
    import: () => import("./razor-3IbidmH5.mjs")
  },
  {
    id: "reg",
    name: "Windows Registry Script",
    import: () => import("./reg-6UpU0EA6.mjs")
  },
  {
    id: "regexp",
    name: "RegExp",
    aliases: [
      "regex"
    ],
    import: () => import("./regexp-DHtjPxOp.mjs")
  },
  {
    id: "rel",
    name: "Rel",
    import: () => import("./rel-DBIoUiKW.mjs")
  },
  {
    id: "riscv",
    name: "RISC-V",
    import: () => import("./riscv-DpWk9ieM.mjs")
  },
  {
    id: "rst",
    name: "reStructuredText",
    import: () => import("./rst-CPnjfoUr.mjs")
  },
  {
    id: "ruby",
    name: "Ruby",
    aliases: [
      "rb"
    ],
    import: () => import("./ruby-CnpR89Yz.mjs")
  },
  {
    id: "rust",
    name: "Rust",
    aliases: [
      "rs"
    ],
    import: () => import("./rust-B-KPd2nT.mjs")
  },
  {
    id: "sas",
    name: "SAS",
    import: () => import("./sas-CYKhWn_m.mjs")
  },
  {
    id: "sass",
    name: "Sass",
    import: () => import("./sass-Zos2Blmo.mjs")
  },
  {
    id: "scala",
    name: "Scala",
    import: () => import("./scala-7cAMYIqn.mjs")
  },
  {
    id: "scheme",
    name: "Scheme",
    import: () => import("./scheme-BQZQETGI.mjs")
  },
  {
    id: "scss",
    name: "SCSS",
    import: () => import("./scss-DKWoiR-u.mjs")
  },
  {
    id: "sdbl",
    name: "1C (Query)",
    aliases: [
      "1c-query"
    ],
    import: () => import("./sdbl-67k1U2sQ.mjs")
  },
  {
    id: "shaderlab",
    name: "ShaderLab",
    aliases: [
      "shader"
    ],
    import: () => import("./shaderlab-B4H_j9nc.mjs")
  },
  {
    id: "shellscript",
    name: "Shell",
    aliases: [
      "bash",
      "sh",
      "shell",
      "zsh"
    ],
    import: () => import("./shellscript-DmhSIIKI.mjs")
  },
  {
    id: "shellsession",
    name: "Shell Session",
    aliases: [
      "console"
    ],
    import: () => import("./shellsession-fTmnZnY-.mjs")
  },
  {
    id: "smalltalk",
    name: "Smalltalk",
    import: () => import("./smalltalk-WltKgyq1.mjs")
  },
  {
    id: "solidity",
    name: "Solidity",
    import: () => import("./solidity-C04s0Yy3.mjs")
  },
  {
    id: "soy",
    name: "Closure Templates",
    aliases: [
      "closure-templates"
    ],
    import: () => import("./soy-758-DfbO.mjs")
  },
  {
    id: "sparql",
    name: "SPARQL",
    import: () => import("./sparql-P6C2Je34.mjs")
  },
  {
    id: "splunk",
    name: "Splunk Query Language",
    aliases: [
      "spl"
    ],
    import: () => import("./splunk-SGh_QiTm.mjs")
  },
  {
    id: "sql",
    name: "SQL",
    import: () => import("./sql-CsvhJWkt.mjs")
  },
  {
    id: "ssh-config",
    name: "SSH Config",
    import: () => import("./ssh-config-D4I637-k.mjs")
  },
  {
    id: "stata",
    name: "Stata",
    import: () => import("./stata-CqUrtzqQ.mjs")
  },
  {
    id: "stylus",
    name: "Stylus",
    aliases: [
      "styl"
    ],
    import: () => import("./stylus-C0YS3cII.mjs")
  },
  {
    id: "svelte",
    name: "Svelte",
    import: () => import("./svelte-PT4fUUDt.mjs")
  },
  {
    id: "swift",
    name: "Swift",
    import: () => import("./swift-DvTgPjC_.mjs")
  },
  {
    id: "system-verilog",
    name: "SystemVerilog",
    import: () => import("./system-verilog-NDUJ-OOt.mjs")
  },
  {
    id: "systemd",
    name: "Systemd Units",
    import: () => import("./systemd-WbxZvB8q.mjs")
  },
  {
    id: "talonscript",
    name: "TalonScript",
    aliases: [
      "talon"
    ],
    import: () => import("./talonscript-CL368eRB.mjs")
  },
  {
    id: "tasl",
    name: "Tasl",
    import: () => import("./tasl-Dz-WwaLH.mjs")
  },
  {
    id: "tcl",
    name: "Tcl",
    import: () => import("./tcl-DlZIgGJq.mjs")
  },
  {
    id: "templ",
    name: "Templ",
    import: () => import("./templ-pbaOT3fH.mjs")
  },
  {
    id: "terraform",
    name: "Terraform",
    aliases: [
      "tf",
      "tfvars"
    ],
    import: () => import("./terraform-BlQVOgpk.mjs")
  },
  {
    id: "tex",
    name: "TeX",
    import: () => import("./tex-BJDXdWDL.mjs")
  },
  {
    id: "toml",
    name: "TOML",
    import: () => import("./toml-DMRYbshZ.mjs")
  },
  {
    id: "ts-tags",
    name: "TypeScript with Tags",
    aliases: [
      "lit"
    ],
    import: () => import("./ts-tags-DLLASl57.mjs")
  },
  {
    id: "tsv",
    name: "TSV",
    import: () => import("./tsv-BtvSkaG0.mjs")
  },
  {
    id: "tsx",
    name: "TSX",
    import: () => import("./tsx-D0IYuDPS.mjs")
  },
  {
    id: "turtle",
    name: "Turtle",
    import: () => import("./turtle-p-VV8DEc.mjs")
  },
  {
    id: "twig",
    name: "Twig",
    import: () => import("./twig-qIHzdBZb.mjs")
  },
  {
    id: "typescript",
    name: "TypeScript",
    aliases: [
      "ts"
    ],
    import: () => import("./typescript-DKfvlBCw.mjs")
  },
  {
    id: "typespec",
    name: "TypeSpec",
    aliases: [
      "tsp"
    ],
    import: () => import("./typespec-CTme0-JL.mjs")
  },
  {
    id: "typst",
    name: "Typst",
    aliases: [
      "typ"
    ],
    import: () => import("./typst-Dn4vyooU.mjs")
  },
  {
    id: "v",
    name: "V",
    import: () => import("./v-D7ebitkb.mjs")
  },
  {
    id: "vala",
    name: "Vala",
    import: () => import("./vala-TRtLMDHC.mjs")
  },
  {
    id: "vb",
    name: "Visual Basic",
    aliases: [
      "cmd"
    ],
    import: () => import("./vb-B47FrOmA.mjs")
  },
  {
    id: "verilog",
    name: "Verilog",
    import: () => import("./verilog-B2TLsC4I.mjs")
  },
  {
    id: "vhdl",
    name: "VHDL",
    import: () => import("./vhdl-CU5AEtCN.mjs")
  },
  {
    id: "viml",
    name: "Vim Script",
    aliases: [
      "vim",
      "vimscript"
    ],
    import: () => import("./viml-D-fUhqVn.mjs")
  },
  {
    id: "vue",
    name: "Vue",
    import: () => import("./vue-DbAfZKRm.mjs")
  },
  {
    id: "vue-html",
    name: "Vue HTML",
    import: () => import("./vue-html-Bv98KUW6.mjs")
  },
  {
    id: "vyper",
    name: "Vyper",
    aliases: [
      "vy"
    ],
    import: () => import("./vyper-C03y8CZF.mjs")
  },
  {
    id: "wasm",
    name: "WebAssembly",
    import: () => import("./wasm-Bq8UuFo1.mjs")
  },
  {
    id: "wenyan",
    name: "Wenyan",
    aliases: [
      "æ–‡è¨€"
    ],
    import: () => import("./wenyan-DZPWEYbu.mjs")
  },
  {
    id: "wgsl",
    name: "WGSL",
    import: () => import("./wgsl-De1GPYf9.mjs")
  },
  {
    id: "wikitext",
    name: "Wikitext",
    aliases: [
      "mediawiki",
      "wiki"
    ],
    import: () => import("./wikitext-C-THcCj2.mjs")
  },
  {
    id: "wit",
    name: "WebAssembly Interface Types",
    import: () => import("./wit-BanP67gl.mjs")
  },
  {
    id: "wolfram",
    name: "Wolfram",
    aliases: [
      "wl"
    ],
    import: () => import("./wolfram-CUT_U39K.mjs")
  },
  {
    id: "xml",
    name: "XML",
    import: () => import("./xml-DQsl7x7X.mjs")
  },
  {
    id: "xsl",
    name: "XSL",
    import: () => import("./xsl-Bi8eHqC2.mjs")
  },
  {
    id: "yaml",
    name: "YAML",
    aliases: [
      "yml"
    ],
    import: () => import("./yaml-DcQhbMrL.mjs")
  },
  {
    id: "zenscript",
    name: "ZenScript",
    import: () => import("./zenscript-8JCzLCTe.mjs")
  },
  {
    id: "zig",
    name: "Zig",
    import: () => import("./zig-DhdgDxkm.mjs")
  }
], A0 = Object.fromEntries(Xr.map((e) => [e.id, e.import])), E0 = Object.fromEntries(Xr.flatMap((e) => {
  var t;
  return ((t = e.aliases) == null ? void 0 : t.map((n) => [n, e.import])) || [];
})), S0 = {
  ...A0,
  ...E0
}, D0 = [
  {
    id: "andromeeda",
    displayName: "Andromeeda",
    type: "dark",
    import: () => import("./andromeeda-uXNdzNpk.mjs")
  },
  {
    id: "aurora-x",
    displayName: "Aurora X",
    type: "dark",
    import: () => import("./aurora-x-BwoVEUWZ.mjs")
  },
  {
    id: "ayu-dark",
    displayName: "Ayu Dark",
    type: "dark",
    import: () => import("./ayu-dark-CxPZkpb2.mjs")
  },
  {
    id: "catppuccin-frappe",
    displayName: "Catppuccin FrappÃ©",
    type: "dark",
    import: () => import("./catppuccin-frappe-MQ6irQtC.mjs")
  },
  {
    id: "catppuccin-latte",
    displayName: "Catppuccin Latte",
    type: "light",
    import: () => import("./catppuccin-latte-UMitw0Sv.mjs")
  },
  {
    id: "catppuccin-macchiato",
    displayName: "Catppuccin Macchiato",
    type: "dark",
    import: () => import("./catppuccin-macchiato-CpTwm6bY.mjs")
  },
  {
    id: "catppuccin-mocha",
    displayName: "Catppuccin Mocha",
    type: "dark",
    import: () => import("./catppuccin-mocha-DAcVHoH1.mjs")
  },
  {
    id: "dark-plus",
    displayName: "Dark Plus",
    type: "dark",
    import: () => import("./dark-plus-pUHDTVV0.mjs")
  },
  {
    id: "dracula",
    displayName: "Dracula Theme",
    type: "dark",
    import: () => import("./dracula-BtZx2Kac.mjs")
  },
  {
    id: "dracula-soft",
    displayName: "Dracula Theme Soft",
    type: "dark",
    import: () => import("./dracula-soft-BKa-aqBv.mjs")
  },
  {
    id: "everforest-dark",
    displayName: "Everforest Dark",
    type: "dark",
    import: () => import("./everforest-dark-DMCBqXCK.mjs")
  },
  {
    id: "everforest-light",
    displayName: "Everforest Light",
    type: "light",
    import: () => import("./everforest-light-BbXl82Em.mjs")
  },
  {
    id: "github-dark",
    displayName: "GitHub Dark",
    type: "dark",
    import: () => import("./github-dark-DenFmJkN.mjs")
  },
  {
    id: "github-dark-default",
    displayName: "GitHub Dark Default",
    type: "dark",
    import: () => import("./github-dark-default-BJPUVz4H.mjs")
  },
  {
    id: "github-dark-dimmed",
    displayName: "GitHub Dark Dimmed",
    type: "dark",
    import: () => import("./github-dark-dimmed-DUshB20C.mjs")
  },
  {
    id: "github-dark-high-contrast",
    displayName: "GitHub Dark High Contrast",
    type: "dark",
    import: () => import("./github-dark-high-contrast-D3aGCnF8.mjs")
  },
  {
    id: "github-light",
    displayName: "GitHub Light",
    type: "light",
    import: () => import("./github-light-JYsPkUQd.mjs")
  },
  {
    id: "github-light-default",
    displayName: "GitHub Light Default",
    type: "light",
    import: () => import("./github-light-default-D99KPAby.mjs")
  },
  {
    id: "github-light-high-contrast",
    displayName: "GitHub Light High Contrast",
    type: "light",
    import: () => import("./github-light-high-contrast-BbmZE-Mp.mjs")
  },
  {
    id: "gruvbox-dark-hard",
    displayName: "Gruvbox Dark Hard",
    type: "dark",
    import: () => import("./gruvbox-dark-hard-BDGmrmYl.mjs")
  },
  {
    id: "gruvbox-dark-medium",
    displayName: "Gruvbox Dark Medium",
    type: "dark",
    import: () => import("./gruvbox-dark-medium-D7OrvcL5.mjs")
  },
  {
    id: "gruvbox-dark-soft",
    displayName: "Gruvbox Dark Soft",
    type: "dark",
    import: () => import("./gruvbox-dark-soft-D_75PUdg.mjs")
  },
  {
    id: "gruvbox-light-hard",
    displayName: "Gruvbox Light Hard",
    type: "light",
    import: () => import("./gruvbox-light-hard-DhQt1gbs.mjs")
  },
  {
    id: "gruvbox-light-medium",
    displayName: "Gruvbox Light Medium",
    type: "light",
    import: () => import("./gruvbox-light-medium-DNXV_Sw8.mjs")
  },
  {
    id: "gruvbox-light-soft",
    displayName: "Gruvbox Light Soft",
    type: "light",
    import: () => import("./gruvbox-light-soft-C7ZspGxH.mjs")
  },
  {
    id: "houston",
    displayName: "Houston",
    type: "dark",
    import: () => import("./houston-BDYrDoDW.mjs")
  },
  {
    id: "kanagawa-dragon",
    displayName: "Kanagawa Dragon",
    type: "dark",
    import: () => import("./kanagawa-dragon-CiKur4Hl.mjs")
  },
  {
    id: "kanagawa-lotus",
    displayName: "Kanagawa Lotus",
    type: "light",
    import: () => import("./kanagawa-lotus-BKu-smKu.mjs")
  },
  {
    id: "kanagawa-wave",
    displayName: "Kanagawa Wave",
    type: "dark",
    import: () => import("./kanagawa-wave-CQwozSzG.mjs")
  },
  {
    id: "laserwave",
    displayName: "LaserWave",
    type: "dark",
    import: () => import("./laserwave-6a00oqik.mjs")
  },
  {
    id: "light-plus",
    displayName: "Light Plus",
    type: "light",
    import: () => import("./light-plus-CZuVqSLX.mjs")
  },
  {
    id: "material-theme",
    displayName: "Material Theme",
    type: "dark",
    import: () => import("./material-theme-D6KBX41T.mjs")
  },
  {
    id: "material-theme-darker",
    displayName: "Material Theme Darker",
    type: "dark",
    import: () => import("./material-theme-darker-CkRroheE.mjs")
  },
  {
    id: "material-theme-lighter",
    displayName: "Material Theme Lighter",
    type: "light",
    import: () => import("./material-theme-lighter-BUBw43Yz.mjs")
  },
  {
    id: "material-theme-ocean",
    displayName: "Material Theme Ocean",
    type: "dark",
    import: () => import("./material-theme-ocean-ClGX14Ja.mjs")
  },
  {
    id: "material-theme-palenight",
    displayName: "Material Theme Palenight",
    type: "dark",
    import: () => import("./material-theme-palenight-C1RVm8K1.mjs")
  },
  {
    id: "min-dark",
    displayName: "Min Dark",
    type: "dark",
    import: () => import("./min-dark-C7ak0t6c.mjs")
  },
  {
    id: "min-light",
    displayName: "Min Light",
    type: "light",
    import: () => import("./min-light-CKFxVcPp.mjs")
  },
  {
    id: "monokai",
    displayName: "Monokai",
    type: "dark",
    import: () => import("./monokai-C1KBYcO0.mjs")
  },
  {
    id: "night-owl",
    displayName: "Night Owl",
    type: "dark",
    import: () => import("./night-owl-Bm2rzalh.mjs")
  },
  {
    id: "nord",
    displayName: "Nord",
    type: "dark",
    import: () => import("./nord-CC5OiUXg.mjs")
  },
  {
    id: "one-dark-pro",
    displayName: "One Dark Pro",
    type: "dark",
    import: () => import("./one-dark-pro-DTA3VF0_.mjs")
  },
  {
    id: "one-light",
    displayName: "One Light",
    type: "light",
    import: () => import("./one-light-D9sNaUtq.mjs")
  },
  {
    id: "plastic",
    displayName: "Plastic",
    type: "dark",
    import: () => import("./plastic-CSTz3KZp.mjs")
  },
  {
    id: "poimandres",
    displayName: "Poimandres",
    type: "dark",
    import: () => import("./poimandres-C-VADXHD.mjs")
  },
  {
    id: "red",
    displayName: "Red",
    type: "dark",
    import: () => import("./red-7y8PH7HH.mjs")
  },
  {
    id: "rose-pine",
    displayName: "RosÃ© Pine",
    type: "dark",
    import: () => import("./rose-pine-4uTOzEpE.mjs")
  },
  {
    id: "rose-pine-dawn",
    displayName: "RosÃ© Pine Dawn",
    type: "light",
    import: () => import("./rose-pine-dawn-GMd81k-m.mjs")
  },
  {
    id: "rose-pine-moon",
    displayName: "RosÃ© Pine Moon",
    type: "dark",
    import: () => import("./rose-pine-moon-CIFp_3PJ.mjs")
  },
  {
    id: "slack-dark",
    displayName: "Slack Dark",
    type: "dark",
    import: () => import("./slack-dark-i7wN4OET.mjs")
  },
  {
    id: "slack-ochin",
    displayName: "Slack Ochin",
    type: "light",
    import: () => import("./slack-ochin-ndHf0LoP.mjs")
  },
  {
    id: "snazzy-light",
    displayName: "Snazzy Light",
    type: "light",
    import: () => import("./snazzy-light-BlSJXAu4.mjs")
  },
  {
    id: "solarized-dark",
    displayName: "Solarized Dark",
    type: "dark",
    import: () => import("./solarized-dark-UTmkh7lw.mjs")
  },
  {
    id: "solarized-light",
    displayName: "Solarized Light",
    type: "light",
    import: () => import("./solarized-light-BheCkDPT.mjs")
  },
  {
    id: "synthwave-84",
    displayName: "Synthwave '84",
    type: "dark",
    import: () => import("./synthwave-84-NU3C_KFZ.mjs")
  },
  {
    id: "tokyo-night",
    displayName: "Tokyo Night",
    type: "dark",
    import: () => import("./tokyo-night-DP4TmcQl.mjs")
  },
  {
    id: "vesper",
    displayName: "Vesper",
    type: "dark",
    import: () => import("./vesper-BckBta1U.mjs")
  },
  {
    id: "vitesse-black",
    displayName: "Vitesse Black",
    type: "dark",
    import: () => import("./vitesse-black-BoGvW84i.mjs")
  },
  {
    id: "vitesse-dark",
    displayName: "Vitesse Dark",
    type: "dark",
    import: () => import("./vitesse-dark-Cym-eLtO.mjs")
  },
  {
    id: "vitesse-light",
    displayName: "Vitesse Light",
    type: "light",
    import: () => import("./vitesse-light-CcmG315c.mjs")
  }
], F0 = Object.fromEntries(D0.map((e) => [e.id, e.import]));
class jn extends Error {
  constructor(t) {
    super(t), this.name = "ShikiError";
  }
}
function T0() {
  return 2147483648;
}
function R0() {
  return typeof performance < "u" ? performance.now() : Date.now();
}
const L0 = (e, t) => e + (t - e % t) % t;
async function P0(e) {
  let t, n;
  const u = {};
  function r(p) {
    n = p, u.HEAPU8 = new Uint8Array(p), u.HEAPU32 = new Uint32Array(p);
  }
  function i(p, h, g) {
    u.HEAPU8.copyWithin(p, h, h + g);
  }
  function a(p) {
    try {
      return t.grow(p - n.byteLength + 65535 >>> 16), r(t.buffer), 1;
    } catch {
    }
  }
  function o(p) {
    const h = u.HEAPU8.length;
    p = p >>> 0;
    const g = T0();
    if (p > g)
      return !1;
    for (let m = 1; m <= 4; m *= 2) {
      let b = h * (1 + 0.2 / m);
      b = Math.min(b, p + 100663296);
      const _ = Math.min(g, L0(Math.max(p, b), 65536));
      if (a(_))
        return !0;
    }
    return !1;
  }
  const s = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function l(p, h, g = 1024) {
    const m = h + g;
    let b = h;
    for (; p[b] && !(b >= m); ) ++b;
    if (b - h > 16 && p.buffer && s)
      return s.decode(p.subarray(h, b));
    let _ = "";
    for (; h < b; ) {
      let y = p[h++];
      if (!(y & 128)) {
        _ += String.fromCharCode(y);
        continue;
      }
      const x = p[h++] & 63;
      if ((y & 224) === 192) {
        _ += String.fromCharCode((y & 31) << 6 | x);
        continue;
      }
      const C = p[h++] & 63;
      if ((y & 240) === 224 ? y = (y & 15) << 12 | x << 6 | C : y = (y & 7) << 18 | x << 12 | C << 6 | p[h++] & 63, y < 65536)
        _ += String.fromCharCode(y);
      else {
        const v = y - 65536;
        _ += String.fromCharCode(55296 | v >> 10, 56320 | v & 1023);
      }
    }
    return _;
  }
  function c(p, h) {
    return p ? l(u.HEAPU8, p, h) : "";
  }
  const d = {
    emscripten_get_now: R0,
    emscripten_memcpy_big: i,
    emscripten_resize_heap: o,
    fd_write: () => 0
  };
  async function f() {
    const h = await e({
      env: d,
      wasi_snapshot_preview1: d
    });
    t = h.memory, r(t.buffer), Object.assign(u, h), u.UTF8ToString = c;
  }
  return await f(), u;
}
var N0 = Object.defineProperty, I0 = (e, t, n) => t in e ? N0(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, N = (e, t, n) => I0(e, typeof t != "symbol" ? t + "" : t, n);
let B = null;
function M0(e) {
  throw new jn(e.UTF8ToString(e.getLastOnigError()));
}
class Nt {
  constructor(t) {
    N(this, "utf16Length"), N(this, "utf8Length"), N(this, "utf16Value"), N(this, "utf8Value"), N(this, "utf16OffsetToUtf8"), N(this, "utf8OffsetToUtf16");
    const n = t.length, u = Nt._utf8ByteLength(t), r = u !== n, i = r ? new Uint32Array(n + 1) : null;
    r && (i[n] = u);
    const a = r ? new Uint32Array(u + 1) : null;
    r && (a[u] = n);
    const o = new Uint8Array(u);
    let s = 0;
    for (let l = 0; l < n; l++) {
      const c = t.charCodeAt(l);
      let d = c, f = !1;
      if (c >= 55296 && c <= 56319 && l + 1 < n) {
        const p = t.charCodeAt(l + 1);
        p >= 56320 && p <= 57343 && (d = (c - 55296 << 10) + 65536 | p - 56320, f = !0);
      }
      r && (i[l] = s, f && (i[l + 1] = s), d <= 127 ? a[s + 0] = l : d <= 2047 ? (a[s + 0] = l, a[s + 1] = l) : d <= 65535 ? (a[s + 0] = l, a[s + 1] = l, a[s + 2] = l) : (a[s + 0] = l, a[s + 1] = l, a[s + 2] = l, a[s + 3] = l)), d <= 127 ? o[s++] = d : d <= 2047 ? (o[s++] = 192 | (d & 1984) >>> 6, o[s++] = 128 | (d & 63) >>> 0) : d <= 65535 ? (o[s++] = 224 | (d & 61440) >>> 12, o[s++] = 128 | (d & 4032) >>> 6, o[s++] = 128 | (d & 63) >>> 0) : (o[s++] = 240 | (d & 1835008) >>> 18, o[s++] = 128 | (d & 258048) >>> 12, o[s++] = 128 | (d & 4032) >>> 6, o[s++] = 128 | (d & 63) >>> 0), f && l++;
    }
    this.utf16Length = n, this.utf8Length = u, this.utf16Value = t, this.utf8Value = o, this.utf16OffsetToUtf8 = i, this.utf8OffsetToUtf16 = a;
  }
  static _utf8ByteLength(t) {
    let n = 0;
    for (let u = 0, r = t.length; u < r; u++) {
      const i = t.charCodeAt(u);
      let a = i, o = !1;
      if (i >= 55296 && i <= 56319 && u + 1 < r) {
        const s = t.charCodeAt(u + 1);
        s >= 56320 && s <= 57343 && (a = (i - 55296 << 10) + 65536 | s - 56320, o = !0);
      }
      a <= 127 ? n += 1 : a <= 2047 ? n += 2 : a <= 65535 ? n += 3 : n += 4, o && u++;
    }
    return n;
  }
  createString(t) {
    const n = t.omalloc(this.utf8Length);
    return t.HEAPU8.set(this.utf8Value, n), n;
  }
}
const It = class te {
  constructor(t) {
    if (N(this, "id", ++te.LAST_ID), N(this, "_onigBinding"), N(this, "content"), N(this, "utf16Length"), N(this, "utf8Length"), N(this, "utf16OffsetToUtf8"), N(this, "utf8OffsetToUtf16"), N(this, "ptr"), !B)
      throw new jn("Must invoke loadWasm first.");
    this._onigBinding = B, this.content = t;
    const n = new Nt(t);
    this.utf16Length = n.utf16Length, this.utf8Length = n.utf8Length, this.utf16OffsetToUtf8 = n.utf16OffsetToUtf8, this.utf8OffsetToUtf16 = n.utf8OffsetToUtf16, this.utf8Length < 1e4 && !te._sharedPtrInUse ? (te._sharedPtr || (te._sharedPtr = B.omalloc(1e4)), te._sharedPtrInUse = !0, B.HEAPU8.set(n.utf8Value, te._sharedPtr), this.ptr = te._sharedPtr) : this.ptr = n.createString(B);
  }
  convertUtf8OffsetToUtf16(t) {
    return this.utf8OffsetToUtf16 ? t < 0 ? 0 : t > this.utf8Length ? this.utf16Length : this.utf8OffsetToUtf16[t] : t;
  }
  convertUtf16OffsetToUtf8(t) {
    return this.utf16OffsetToUtf8 ? t < 0 ? 0 : t > this.utf16Length ? this.utf8Length : this.utf16OffsetToUtf8[t] : t;
  }
  dispose() {
    this.ptr === te._sharedPtr ? te._sharedPtrInUse = !1 : this._onigBinding.ofree(this.ptr);
  }
};
N(It, "LAST_ID", 0);
N(It, "_sharedPtr", 0);
N(It, "_sharedPtrInUse", !1);
let Yr = It;
class O0 {
  constructor(t) {
    if (N(this, "_onigBinding"), N(this, "_ptr"), !B)
      throw new jn("Must invoke loadWasm first.");
    const n = [], u = [];
    for (let o = 0, s = t.length; o < s; o++) {
      const l = new Nt(t[o]);
      n[o] = l.createString(B), u[o] = l.utf8Length;
    }
    const r = B.omalloc(4 * t.length);
    B.HEAPU32.set(n, r / 4);
    const i = B.omalloc(4 * t.length);
    B.HEAPU32.set(u, i / 4);
    const a = B.createOnigScanner(r, i, t.length);
    for (let o = 0, s = t.length; o < s; o++)
      B.ofree(n[o]);
    B.ofree(i), B.ofree(r), a === 0 && M0(B), this._onigBinding = B, this._ptr = a;
  }
  dispose() {
    this._onigBinding.freeOnigScanner(this._ptr);
  }
  findNextMatchSync(t, n, u) {
    let r = 0;
    if (typeof u == "number" && (r = u), typeof t == "string") {
      t = new Yr(t);
      const i = this._findNextMatchSync(t, n, !1, r);
      return t.dispose(), i;
    }
    return this._findNextMatchSync(t, n, !1, r);
  }
  _findNextMatchSync(t, n, u, r) {
    const i = this._onigBinding, a = i.findNextOnigScannerMatch(this._ptr, t.id, t.ptr, t.utf8Length, t.convertUtf16OffsetToUtf8(n), r);
    if (a === 0)
      return null;
    const o = i.HEAPU32;
    let s = a / 4;
    const l = o[s++], c = o[s++], d = [];
    for (let f = 0; f < c; f++) {
      const p = t.convertUtf8OffsetToUtf16(o[s++]), h = t.convertUtf8OffsetToUtf16(o[s++]);
      d[f] = {
        start: p,
        end: h,
        length: h - p
      };
    }
    return {
      index: l,
      captureIndices: d
    };
  }
}
function B0(e) {
  return typeof e.instantiator == "function";
}
function j0(e) {
  return typeof e.default == "function";
}
function z0(e) {
  return typeof e.data < "u";
}
function $0(e) {
  return typeof Response < "u" && e instanceof Response;
}
function q0(e) {
  var t;
  return typeof ArrayBuffer < "u" && (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) || typeof Buffer < "u" && ((t = Buffer.isBuffer) == null ? void 0 : t.call(Buffer, e)) || typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer || typeof Uint32Array < "u" && e instanceof Uint32Array;
}
let at;
function G0(e) {
  if (at)
    return at;
  async function t() {
    B = await P0(async (n) => {
      let u = e;
      return u = await u, typeof u == "function" && (u = await u(n)), typeof u == "function" && (u = await u(n)), B0(u) ? u = await u.instantiator(n) : j0(u) ? u = await u.default(n) : (z0(u) && (u = u.data), $0(u) ? typeof WebAssembly.instantiateStreaming == "function" ? u = await H0(u)(n) : u = await U0(u)(n) : q0(u) ? u = await Yt(u)(n) : u instanceof WebAssembly.Module ? u = await Yt(u)(n) : "default" in u && u.default instanceof WebAssembly.Module && (u = await Yt(u.default)(n))), "instance" in u && (u = u.instance), "exports" in u && (u = u.exports), u;
    });
  }
  return at = t(), at;
}
function Yt(e) {
  return (t) => WebAssembly.instantiate(e, t);
}
function H0(e) {
  return (t) => WebAssembly.instantiateStreaming(e, t);
}
function U0(e) {
  return async (t) => {
    const n = await e.arrayBuffer();
    return WebAssembly.instantiate(n, t);
  };
}
async function W0(e) {
  return e && await G0(e), {
    createScanner(t) {
      return new O0(t.map((n) => typeof n == "string" ? n : n.source));
    },
    createString(t) {
      return new Yr(t);
    }
  };
}
const V0 = /* @__PURE__ */ v0({
  langs: S0,
  themes: F0,
  engine: () => W0(import("./wasm-DQxwEHae.mjs"))
});
async function Z0(e = {}) {
  const t = Array.isArray(e.themes) ? e.themes : e.themes ? [e.themes] : ["github-dark"], n = await V0({
    // @ts-ignore - ç±»å‹å…¼å®¹é—®é¢˜
    themes: t,
    // @ts-ignore - ç±»å‹å…¼å®¹é—®é¢˜
    langs: e.langs || []
  }), u = e.processors || [];
  return {
    ...n,
    codeToHtml(i, a) {
      const o = typeof a == "string" ? a : a.lang || "text", { code: s } = Os(u, i, o), l = typeof a == "object" && a.theme ? a.theme : t[0];
      let c = n.codeToHtml(s, {
        lang: o,
        // @ts-ignore - ç±»å‹å…¼å®¹é—®é¢˜
        theme: l
      });
      return c = Bs(u, c, o), c;
    },
    // ç›´æ¥é€ä¼ åŸå§‹æ–¹æ³•
    loadLanguage: (i) => n.loadLanguage(i),
    getLoadedLanguages: () => n.getLoadedLanguages(),
    getLoadedThemes: () => n.getLoadedThemes()
  };
}
const J0 = Ss("abcdefghijklmnopqrstuvwxyz", 10), K0 = {
  name: "error-level",
  handler: Rt()
};
async function Q0(e = "github-dark", t = [], n = "", u = console) {
  const r = typeof e == "string" || "name" in e, i = (m) => typeof m == "string" ? m : m.name || "github-dark", a = [
    Is(),
    Ms({ hasHighlightClass: "highlighted" }),
    Ns(),
    K0
  ], o = {
    langs: ["css", ...t],
    processors: a
  };
  r ? o.themes = [e] : o.themes = [e.dark, e.light];
  const s = await Z0(o), l = async (m) => {
    m && !s.getLoadedLanguages().includes(m) && await s.loadLanguage(m);
  };
  n && await l(n);
  const c = /<pre[^>]*(style=".*?")/, d = /^<pre(.*?)>/, f = /-vue$/, p = /:(no-)?line-numbers$/, h = /\{\{.*?\}\}/g;
  return { plugin: (m, b, _) => {
    const y = f.test(b) ? "" : "v-pre";
    b = b.replace(p, "").replace(f, "").toLowerCase() || n, b && !s.getLoadedLanguages().includes(b) && b !== "ansi" && b !== "txt" && u.warn(`
The language '${b}' is not loaded, falling back to '${n || "txt"}' for syntax highlighting.`);
    const x = (P) => P.replace(d, ($, D) => `<pre ${y}${D.replace(' tabindex="0"', "")}>`).replace(c, ($, D) => $.replace(D, "")), C = /* @__PURE__ */ new Map(), v = (P) => y ? P : P.replace(h, ($) => {
      let D = C.get($);
      return D || (D = J0(), C.set($, D)), D;
    }), A = (P) => (C.forEach(($, D) => {
      P = P.replace(new RegExp($, "gi"), D);
    }), P), S = (P) => P.replace(/(<span class="line highlighted">)(<\/span>)/g, "$1<wbr>$2");
    m = v(m);
    const L = (P) => {
      let $;
      try {
        const D = i(P);
        $ = b === "ansi" ? s.codeToHtml(m, {
          lang: "ansi",
          theme: D
        }) : s.codeToHtml(m, {
          lang: b,
          theme: D
        });
      } catch {
        const G = i(P);
        $ = s.codeToHtml(m, {
          lang: "ansi",
          theme: G
        });
      }
      return S(x(A($)));
    };
    if (r) return L(e);
    const M = He(L(e.dark), "vp-code-dark", "pre"), Z = He(L(e.light), "vp-code-light", "pre");
    return M + Z;
  }, highlighter: s, loadLang: l };
}
const en = /{([\d,-]+)}/, X0 = (e) => {
  const t = e.renderer.rules.fence;
  e.renderer.rules.fence = (...n) => {
    const [u, r] = n, i = u[r], a = i.attrs && i.attrs[0];
    let o = null;
    if (!a) {
      const s = i.info;
      if (!s || !en.test(s))
        return t(...n);
      const l = s.replace(en, "").trim();
      i.info = l, o = en.exec(s)[1];
    }
    return !o && (o = a[0], !o || !/[\d,-]+/.test(o)) ? t(...n) : (i.info += " " + o, t(...n));
  };
}, Y0 = (e) => {
  const t = e.renderer.rules.image;
  e.renderer.rules.image = (n, u, r, i, a) => {
    const o = n[u];
    let s = o.attrGet("src");
    return s && !ln.test(s) && (/^\.?\//.test(s) || (s = "./" + s), o.attrSet("src", decodeURIComponent(s))), t(n, u, r, i, a);
  };
}, ed = (e, t = !1) => {
  const n = e.renderer.rules.fence;
  e.renderer.rules.fence = (...u) => {
    const r = n(...u), [i, a] = u, o = i[a].info;
    if (!t && !/:line-numbers($| )/.test(o) || t && /:no-line-numbers($| )/.test(o))
      return r;
    const l = r.slice(
      r.indexOf("<code>"),
      r.indexOf("</code>")
    ).split(`
`), d = `<div class="line-numbers-wrapper" aria-hidden="true">${[
      ...Array(
        l.length - (l[l.length - 1] === '<span class="line"></span>' ? 1 : 0)
      )
    ].map((p, h) => `<span class="line-number">${h + 1}</span><br>`).join("")}</div>`;
    return r.replace(/<\/div>$/, `${d}</div>`).replace(/"(language-[^"]*?)"/, '"$1 line-numbers-mode"');
  };
}, td = /(^|.*\/)index.md(#?.*)$/i, nd = (e, t, n) => {
  e.renderer.rules.link_open = (i, a, o, s, l) => {
    const c = i[a], d = c.attrIndex("href");
    if (d >= 0) {
      const f = c.attrs[d], p = f[1];
      ln.test(p) ? (Object.entries(t).forEach(([g, m]) => {
        c.attrSet(g, m);
      }), p.replace(ln, "").startsWith("//localhost:") && r(p, s), f[1] = p.replace(Ds, "")) : (// internal anchor links
      !p.startsWith("#") && // mail links
      !p.startsWith("mailto:") && // links to files (other than html/md)
      !/\.(?!html|md)\w+($|\?)/i.test(p) ? u(f, s) : p.startsWith("#") && (f[1] = decodeURI(f[1])), f[1].startsWith("/") && (f[1] = `${n}${f[1]}`.replace(/\/+/g, "/"))), f[1] = f[1].replace(/\bimport\.meta/g, "import%2Emeta").replace(/\bprocess\.env/g, "process%2Eenv");
    }
    return l.renderToken(i, a, o);
  };
  function u(i, a) {
    let o = i[1];
    const s = o.match(td);
    if (s) {
      const [, l, c] = s;
      o = l + c;
    } else {
      let l = o.replace(/[?#].*$/, "");
      l.endsWith(".md") && (l = l.replace(/\.md$/, a.cleanUrls ? "" : ".html")), !a.cleanUrls && !l.endsWith(".html") && !l.endsWith("/") && (l += ".html");
      const c = new URL(o, "http://a.com");
      o = l + c.search + c.hash;
    }
    !o.startsWith("/") && !/^\.\//.test(o) && (o = "./" + o), r(o.replace(/\.html$/, ""), a), i[1] = decodeURI(o);
  }
  function r(i, a) {
    (a.links || (a.links = [])).push(i);
  }
}, ei = async (e = {}, t = "/", n = console) => {
  var o;
  const { plugin: u, highlighter: r, loadLang: i } = await Q0(e.theme, e.languages, e.defaultHighlightLang, n), a = X({
    html: !0,
    linkify: !0,
    highlight: e.highlight || u,
    ...e
  });
  return a.linkify.set({ fuzzyLink: !1 }), a.use(X0).use(Ts).use(Ls).use(Y0).use(nd, { target: "_blank", rel: "noreferrer", ...e.externalLinks }, t).use(ed, e.lineNumbers), (o = e.attrs) != null && o.disable || a.use(gs, e.attrs), a.use(vs), a.use(_e, {
    slugify: lt,
    permalink: _e.permalink.linkInsideHeader({
      symbol: "&ZeroWidthSpace;",
      renderAttrs: (s, l) => {
        const c = l.tokens.findIndex((f) => {
          const p = f.attrs, h = p == null ? void 0 : p.find((g) => g[0] === "id");
          return h && s === h[1];
        });
        return {
          "aria-label": `Permalink to "${l.tokens[c + 1].content}"`
        };
      }
    }),
    ...e.anchor
  }), e.headers && a.use(yi, {
    level: [2, 3, 4, 5, 6],
    slugify: lt,
    ...typeof e.headers == "boolean" ? void 0 : e.headers
  }), a.use(ki).use(Ci, {
    ...e.toc
  }), e.config && e.config(a), { md: a, highlighter: r, loadLang: i };
}, ud = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function rd(e, t) {
  return Q(), ne("svg", ud, t[0] || (t[0] = [
    ue("path", {
      fill: "none",
      stroke: "currentColor",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5l5-5m-5-7v12"
    }, null, -1)
  ]));
}
const id = kn({ name: "tabler-download", render: rd }), ad = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function od(e, t) {
  return Q(), ne("svg", ad, t[0] || (t[0] = [
    ue("path", {
      fill: "none",
      stroke: "currentColor",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "m5 12l5 5L20 7"
    }, null, -1)
  ]));
}
const sd = kn({ name: "tabler-check", render: od }), ld = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
function cd(e, t) {
  return Q(), ne("svg", ld, t[0] || (t[0] = [
    ue("g", {
      fill: "none",
      stroke: "currentColor",
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2"
    }, [
      ue("path", { d: "M7 9.667A2.667 2.667 0 0 1 9.667 7h8.666A2.667 2.667 0 0 1 21 9.667v8.666A2.667 2.667 0 0 1 18.333 21H9.667A2.667 2.667 0 0 1 7 18.333z" }),
      ue("path", { d: "M4.012 16.737A2 2 0 0 1 3 15V5c0-1.1.9-2 2-2h10c.75 0 1.158.385 1.5 1" })
    ], -1)
  ]));
}
const dd = kn({ name: "tabler-copy", render: cd });
async function fd(e) {
  try {
    return navigator.clipboard.writeText(e);
  } catch {
    const t = document.createElement("textarea"), n = document.activeElement;
    t.value = e, t.setAttribute("readonly", ""), t.style.contain = "strict", t.style.position = "absolute", t.style.left = "-9999px", t.style.fontSize = "12pt";
    const u = document.getSelection(), r = u ? u.rangeCount > 0 && u.getRangeAt(0) : null;
    document.body.appendChild(t), t.select(), t.selectionStart = 0, t.selectionEnd = e.length, document.execCommand("copy"), document.body.removeChild(t), r && (u.removeAllRanges(), u.addRange(r)), n && n.focus();
  }
}
const hd = (e, t = !1) => {
  const n = "ABCDEFGHJKLMNPQRSTUVWXY3456789";
  let u = "";
  for (let r = 0; r < e.valueOf(); r++)
    u += n.charAt(Math.floor(Math.random() * n.length));
  return t ? u.toLowerCase() : u;
}, pd = {
  javascript: ".js",
  python: ".py",
  java: ".java",
  c: ".c",
  cpp: ".cpp",
  "c++": ".cpp",
  "c#": ".cs",
  ruby: ".rb",
  php: ".php",
  swift: ".swift",
  "objective-c": ".m",
  kotlin: ".kt",
  typescript: ".ts",
  go: ".go",
  perl: ".pl",
  rust: ".rs",
  scala: ".scala",
  haskell: ".hs",
  lua: ".lua",
  shell: ".sh",
  sql: ".sql",
  html: ".html",
  css: ".css"
}, md = (e, t, n = "Enter file name") => {
  const u = pd[e] || ".file", r = `file-${hd(3, !0)}${u}`, i = window.prompt(n || "", r);
  if (!i)
    return;
  const a = new Blob([t], { type: "text/plain" }), o = URL.createObjectURL(a), s = document.createElement("a");
  s.download = i, s.href = o, s.style.display = "none", document.body.appendChild(s), s.click(), document.body.removeChild(s), URL.revokeObjectURL(o);
}, gd = { class: "vp-header" }, _d = { class: "ctrl" }, yn = /* @__PURE__ */ At({
  __name: "VueMarkDownHeader",
  props: {
    lang: {
      type: String,
      default: "txt"
    },
    copyTxt: {
      type: String,
      default: "Copy"
    },
    copiedTxt: {
      type: String,
      default: "Copied"
    },
    item: {
      type: String,
      default: ""
    },
    downloadTxt: {
      type: String,
      default: "Enter file name"
    }
  },
  setup(e) {
    const t = e, n = ve(!1), u = ve(null), r = tn(() => n.value ? t.copiedTxt : t.copyTxt);
    function i() {
      const o = /* @__PURE__ */ new Map();
      fd(t.item).then(() => {
        n.value = !0, clearTimeout(o.get(u.value));
        const s = setTimeout(() => {
          n.value = !1, o.delete(u.value);
        }, 2e3);
        o.set(u.value, s);
      });
    }
    function a() {
      md(t.lang, t.item, t.downloadTxt);
    }
    return (o, s) => {
      const l = dd, c = sd, d = id;
      return Q(), ne("div", gd, [
        Nu(o.$slots, "default", {}, () => [
          ue("div", null, nn(e.lang), 1)
        ]),
        ue("div", _d, [
          ue("div", {
            class: "copyRef ctrl",
            onClick: i,
            ref_key: "copyRef",
            ref: u
          }, [
            n.value ? (Q(), zn(c, { key: 1 })) : (Q(), zn(l, { key: 0 })),
            ue("span", null, nn(r.value), 1)
          ], 512),
          de(d, {
            class: "copyRef",
            onClick: a
          })
        ])
      ]);
    };
  }
}), bd = { class: "tabs" }, yd = ["onClick"], kd = ["innerHTML"], xd = /* @__PURE__ */ At({
  __name: "VueGroupCode",
  props: {
    names: {
      type: Object,
      required: !0
    },
    blocks: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = ve(0);
    function n(u) {
      t.value = u;
    }
    return (u, r) => (Q(), ne(Mt, null, [
      de(yn, null, {
        default: ui(() => [
          ue("div", bd, [
            (Q(!0), ne(Mt, null, $n(e.names, (i, a) => (Q(), ne("span", {
              key: a,
              onClick: () => n(a),
              class: un({ active: t.value === a })
            }, nn(i), 11, yd))), 128))
          ])
        ]),
        _: 1
      }),
      (Q(!0), ne(Mt, null, $n(e.blocks, (i, a) => ri((Q(), ne("div", {
        innerHTML: i.innerHTML,
        class: un(i.className),
        key: a
      }, null, 10, kd)), [
        [ii, t.value === a]
      ])), 128))
    ], 64));
  }
});
function wd(e) {
  let t = e;
  const n = /ä»¥ä¸‹æ˜¯(.+)ç»­å†™çš„ä»£ç ï¼š\n\n/, u = t.match(n);
  if (u) {
    const i = u[1];
    t = t.replace(n, `ä»¥ä¸‹æ˜¯${i}ç»­å†™çš„ä»£ç ï¼š

\`\`\`${i.toLocaleLowerCase()}

`);
  }
  const r = /\n```\n/g;
  return t = t.replace(r, "\n``` \n"), t;
}
const Dd = /* @__PURE__ */ At({
  components: {
    VueMarkDownHeader: yn
  },
  props: {
    content: {
      type: String,
      required: !0
    },
    style: {
      type: Object,
      default: () => {
      }
    },
    class: {
      type: String,
      default: ""
    },
    stream: {
      type: Boolean,
      default: !1
    }
  },
  setup(e, {
    expose: t
  }) {
    const n = ve(""), u = ve(), r = ve();
    t({
      render: n,
      md: u,
      loadLangFn: r
    });
    const i = new RegExp("(?<=```)\\S+", "g"), {
      stream: a,
      class: o,
      style: s
    } = ai(e), l = tn(() => ["vp-doc", o.value]);
    function c(g, m = "") {
      let b = "";
      const y = new DOMParser().parseFromString(g, "text/html"), x = /shellscript|shell|bash|sh|zsh/.test(m);
      return y.querySelectorAll("span.line:not(.diff.remove)").forEach((C) => b += (C.textContent || "") + `
`), x && (b = b.replace(/^ *(\$|>) /gm, "").trim()), b.slice(0, -1);
    }
    const d = tn(() => wd(e.content || ""));
    function f(g) {
      if (g.nodeType === Node.TEXT_NODE)
        return g.textContent;
      if (g.nodeType === Node.ELEMENT_NODE) {
        const m = g, b = /^language-/, _ = Array.from(m.classList).some((C) => b.test(C)), y = /vp-code-group/;
        if (Array.from(m.classList).some((C) => y.test(C))) {
          const v = Array.from(m.querySelectorAll(".tabs label")).map((S) => S.innerText), A = m.querySelectorAll(".blocks div");
          return de(xd, {
            names: v,
            blocks: A
          }, null);
        } else if (_) {
          const C = m.className.match(/language-([\w+]+)/), v = C ? C[1] : "plain", A = c(m.innerHTML, v), S = m.innerHTML;
          return de("div", {
            class: l.value,
            style: {
              ...s
            }
          }, [de(ci("slot"), {
            name: "code",
            item: A,
            html: A,
            lang: v
          }, {
            default: () => [de(yn, {
              lang: v,
              item: A
            }, null)]
          }), de("div", {
            class: m.className,
            innerHTML: S
          }, null)]);
        } else {
          const C = Array.from(m.childNodes).map(f).flat(), v = {};
          for (let A = 0; A < m.attributes.length; A++) {
            const S = m.attributes[A];
            v[S.name] = S.value;
          }
          return di(m.tagName, {
            ...v
          }, C);
        }
      }
    }
    async function p() {
      var m;
      const g = Array.from(d.value.matchAll(i)).map((b) => b[0]);
      if (g && r.value)
        for (let b = 0; b < g.length; b++) {
          const _ = g[b];
          try {
            const y = dr[_.toLocaleLowerCase()] || _;
            await r.value(y);
          } catch {
            continue;
          }
        }
      n.value = ((m = u.value) == null ? void 0 : m.render(d.value)) || "";
    }
    oi(d, async () => await p()), si(async () => {
      const {
        md: g,
        loadLang: m
      } = await li(Tn);
      u.value = g, r.value = m, await p();
    });
    function h() {
      const m = new DOMParser().parseFromString(n.value, "text/html"), b = f(m.body);
      return de("div", {
        class: [l.value, {
          "result-streaming": a.value
        }],
        style: {
          ...s.value
        }
      }, [b]);
    }
    return () => h();
  }
}), Fd = /* @__PURE__ */ At({
  __name: "VueMarkdownItProvider",
  props: {
    options: {
      type: Object,
      default: {
        theme: "dracula-soft",
        defaultHighlightLang: "javascript"
      }
    },
    class: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const t = e, n = t.class, u = ei({
      ...t.options
    });
    return fi(Tn, u), (r, i) => (Q(), ne("div", {
      class: un(hi(n))
    }, [
      Nu(r.$slots, "default")
    ], 2));
  }
}), Td = {
  install(e, t = {
    theme: "dracula-soft",
    defaultHighlightLang: "javascript"
  }) {
    const n = ei({
      ...t
    });
    e.provide(Tn, n);
  }
};
export {
  yn as VueMarkDownHeader,
  Dd as VueMarkdownIt,
  Fd as VueMarkdownItProvider,
  Td as default
};
